From b0661b79d54ba3e2a76d88c50d5c77447f0129f0 Mon Sep 17 00:00:00 2001
From: "Eric S. Raymond" <esr@thyrsus.com>
Date: Fri, 9 Dec 2016 17:54:58 -0500
Subject: [PATCH 252/268] Remove dead code and now-unused flag checks
 associated with bcast/multicast.

---
 include/ntp.h     | 17 +++++++----------
 ntpd/ntp_config.c | 10 ++--------
 ntpd/ntp_io.c     |  7 ++-----
 ntpd/ntp_peer.c   | 26 ++++----------------------
 ntpd/ntp_proto.c  | 35 ++---------------------------------
 5 files changed, 17 insertions(+), 78 deletions(-)

diff --git a/include/ntp.h b/include/ntp.h
index c86de8f..0bf90ec 100644
--- a/include/ntp.h
+++ b/include/ntp.h
@@ -696,28 +696,25 @@ struct mon_data {
 
 /*
  * Values for cast_flags in mon_entry and struct peer.  mon_entry uses
- * only the first three, MDF_UCAST, MDF_MCAST, and MDF_BCAST.
+ * only MDF_UCAST and MDF_BCAST.
  */
 #define	MDF_UCAST	0x01	/* unicast client */
-#define	MDF_MCAST	0x02	/* multicast server */
+#define	MDF_MCAST	0x02	/* multicast server (not used) */
 #define	MDF_BCAST	0x04	/* broadcast server */
 #define	MDF_POOL	0x08	/* pool client solicitor */
-#define MDF_ACAST	0x10	/* manycast client solicitor */
+#define MDF_ACAST	0x10	/* manycast client solicitor (not used) */
 #define	MDF_BCLNT	0x20	/* eph. broadcast/multicast client (not used) */
 #define MDF_UCLNT	0x40	/* preemptible manycast or pool client */
 /*
- * In the context of struct peer in ntpd, three of the cast_flags bits
+ * In the context of struct peer in ntpd, one cast_flags bit
  * represent configured associations which never receive packets, and
- * whose reach is always 0: MDF_BCAST, MDF_MCAST, and MDF_ACAST.  The
- * last can be argued as responses are received, but those responses do
- * not affect the MDF_ACAST association's reach register, rather they
- * (may) result in mobilizing ephemeral MDF_ACLNT associations.
+ * whose reach is always 0: MDF_BCAST
  */
-#define MDF_TXONLY_MASK	(MDF_BCAST | MDF_MCAST | MDF_ACAST | MDF_POOL)
+#define MDF_TXONLY_MASK	(MDF_BCAST | MDF_POOL)
 /*
  * manycastclient-like solicitor association cast_flags bits
  */
-#define MDF_SOLICIT_MASK	(MDF_ACAST | MDF_POOL)
+#define MDF_SOLICIT_MASK	MDF_POOL
 /*
  * Values used with mon_enabled to indicate reason for enabling monitoring
  */
diff --git a/ntpd/ntp_config.c b/ntpd/ntp_config.c
index 13c719d..bd67ff1 100644
--- a/ntpd/ntp_config.c
+++ b/ntpd/ntp_config.c
@@ -2664,18 +2664,12 @@ peer_config(
 	 */
 	switch (hmode) {
 	case MODE_BROADCAST:
-
-	    if (IS_MCAST(srcadr))
-			cast_flags = MDF_MCAST;
-		else
-			cast_flags = MDF_BCAST;
+		cast_flags = MDF_BCAST;
 		break;
 
 	case MODE_CLIENT:
 		if (hostname != NULL && SOCK_UNSPEC(srcadr))
 			cast_flags = MDF_POOL;
-		else if (IS_MCAST(srcadr))
-			cast_flags = MDF_ACAST;
 		else
 			cast_flags = MDF_UCAST;
 		break;
@@ -2694,7 +2688,7 @@ peer_config(
 	ctl->flags |= FLAG_CONFIG;
 	if (mode_ntpdate)
 		ctl->flags |= FLAG_IBURST;
-	if ((MDF_ACAST | MDF_POOL) & cast_flags)
+	if (MDF_POOL & cast_flags)
 		ctl->flags &= ~FLAG_PREEMPT;
 	return newpeer(srcadr, hostname, dstadr, hmode, ctl->version,
 		       ctl->minpoll, ctl->maxpoll, ctl->flags,
diff --git a/ntpd/ntp_io.c b/ntpd/ntp_io.c
index 10d0102..8930b6b 100644
--- a/ntpd/ntp_io.c
+++ b/ntpd/ntp_io.c
@@ -2422,9 +2422,7 @@ read_network_packet(
 	 * put it on the full list and do bookkeeping.
 	 */
 	rb->dstadr = itf;
-	rb->cast_flags = (uint8_t)(((rb->dstadr->flags &
-				     INT_MCASTOPEN) && rb->fd == rb->dstadr->fd) ? MDF_MCAST
-				   : rb->fd == rb->dstadr->bfd ? MDF_BCAST : MDF_UCAST);
+	rb->cast_flags = (uint8_t)(rb->fd == rb->dstadr->bfd ? MDF_BCAST : MDF_UCAST);
 	rb->fd = fd;
 #ifdef USE_PACKET_TIMESTAMP
 	/* pick up a network time stamp if possible */
@@ -2685,8 +2683,7 @@ select_peerinterface(
 	 */
 	if (IS_PEER_REFCLOCK(peer)) {
 		ep = loopback_interface;
-	} else if (peer->cast_flags &
-		   (MDF_BCLNT | MDF_ACAST | MDF_MCAST | MDF_BCAST)) {
+	} else if (peer->cast_flags & MDF_BCAST) {
 		ep = findbcastinter(srcadr);
 		if (ep != NULL)
 			DPRINTF(4, ("Found *-cast interface %s for address %s\n",
diff --git a/ntpd/ntp_peer.c b/ntpd/ntp_peer.c
index 337568e..3a70a13 100644
--- a/ntpd/ntp_peer.c
+++ b/ntpd/ntp_peer.c
@@ -216,12 +216,8 @@ findexistingpeer_addr(
 	/*
 	 * start_peer is included so we can locate instances of the
 	 * same peer through different interfaces in the hash table.
-	 * Without MDF_BCLNT, a match requires the same mode and remote
-	 * address.  MDF_BCLNT associations start out as MODE_CLIENT
-	 * if broadcastdelay is not specified, and switch to
-	 * MODE_BCLIENT after estimating the one-way delay.  Duplicate
-	 * associations are expanded in definition to match any other
-	 * MDF_BCLNT with the same srcadr (remote, unicast address).
+	 * A match requires the same mode and remote
+	 * address. 
 	 */
 	if (NULL == start_peer)
 		peer = peer_hash[NTP_HASH_ADDR(addr)];
@@ -232,9 +228,7 @@ findexistingpeer_addr(
 		DPRINTF(3, ("%s %s %d %d 0x%x 0x%x ", sockporttoa(addr),
 			sockporttoa(&peer->srcadr), mode, peer->hmode,
 			(u_int)cast_flags, (u_int)peer->cast_flags));
-		if ((-1 == mode || peer->hmode == mode ||
-		     ((MDF_BCLNT & peer->cast_flags) &&
-		      (MDF_BCLNT & cast_flags))) &&
+		if ((-1 == mode || peer->hmode == mode) &&
 		    ADDR_PORT_EQ(addr, &peer->srcadr)) {
 			DPRINTF(3, ("found.\n"));
 			break;
@@ -571,7 +565,6 @@ peer_refresh_interface(
 	)
 {
 	endpt *	niface;
-	endpt *	piface;
 
 	niface = select_peerinterface(p, &p->srcadr, NULL);
 
@@ -595,16 +588,7 @@ peer_refresh_interface(
 		DPRINTF(4, ("<NONE>\n"));
 	}
 
-	piface = p->dstadr;
 	set_peerdstadr(p, niface);
-	if (p->dstadr != NULL) {
-		/*
-		 * clear crypto if we change the local address
-		 */
-		if (p->dstadr != piface && !(MDF_ACAST & p->cast_flags)
-		    && MODE_BROADCAST != p->pmode)
-		    peer_clear(p, "XFAC", false);
-	}
 }
 
 
@@ -761,9 +745,7 @@ newpeer(
 	peer->keyid = key;
 	peer->precision = sys_precision;
 	peer->hpoll = peer->minpoll;
-	if (cast_flags & MDF_ACAST)
-		peer_clear(peer, "ACST", initializing);
-	else if (cast_flags & MDF_POOL)
+	if (cast_flags & MDF_POOL)
 		peer_clear(peer, "POOL", initializing);
 	else if (cast_flags & MDF_BCAST)
 		peer_clear(peer, "BCST", initializing);
diff --git a/ntpd/ntp_proto.c b/ntpd/ntp_proto.c
index c6d328d..adeba9f 100644
--- a/ntpd/ntp_proto.c
+++ b/ntpd/ntp_proto.c
@@ -402,8 +402,7 @@ i_require_authentication(
         bool peer_has_key = peer != NULL && peer->keyid != 0;
         bool wants_association =
             PKT_MODE(pkt->li_vn_mode) == MODE_BROADCAST ||
-            (peer == NULL && PKT_MODE(pkt->li_vn_mode == MODE_ACTIVE)) ||
-            (peer != NULL && peer->cast_flags & MDF_ACAST);
+            (peer == NULL && PKT_MODE(pkt->li_vn_mode == MODE_ACTIVE));
         bool restrict_nopeer =
             (restrict_mask & RES_NOPEER) &&
             wants_association;
@@ -836,7 +835,7 @@ transmit(
 	 * In broadcast mode the poll interval is never changed from
 	 * minpoll.
 	 */
-	if (peer->cast_flags & (MDF_BCAST | MDF_MCAST)) {
+	if (peer->cast_flags & MDF_BCAST) {
 		peer->outdate = current_time;
 		if (sys_leap != LEAP_NOTINSYNC)
 			peer_xmit(peer);
@@ -845,36 +844,6 @@ transmit(
 	}
 
 	/*
-	 * In manycast mode we start with unity ttl. The ttl is
-	 * increased by one for each poll until either sys_maxclock
-	 * servers have been found or the maximum ttl is reached. When
-	 * sys_maxclock servers are found we stop polling until one or
-	 * more servers have timed out or until less than sys_minclock
-	 * associations turn up. In this case additional better servers
-	 * are dragged in and preempt the existing ones.  Once every
-	 * sys_beacon seconds we are to transmit unconditionally, but
-	 * this code is not quite right -- peer->unreach counts polls
-	 * and is being compared with sys_beacon, so the beacons happen
-	 * every sys_beacon polls.
-	 */
-	if (peer->cast_flags & MDF_ACAST) {
-		peer->outdate = current_time;
-		if (peer->unreach > sys_beacon) {
-			peer->unreach = 0;
-			peer->ttl = 0;
-			peer_xmit(peer);
-		} else if (sys_survivors < sys_minclock ||
-		    peer_associations < sys_maxclock) {
-			if (peer->ttl < (uint32_t)sys_ttlmax)
-				peer->ttl++;
-			peer_xmit(peer);
-		}
-		peer->unreach++;
-		poll_update(peer, hpoll);
-		return;
-	}
-
-	/*
 	 * Pool associations transmit unicast solicitations when there
 	 * are less than a hard limit of 2 * sys_maxclock associations,
 	 * and either less than sys_minclock survivors or less than
-- 
2.7.4

