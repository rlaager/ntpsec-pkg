From f475053dfdd7e8f0f0b0d038fadd8d6732584744 Mon Sep 17 00:00:00 2001
From: "Eric S. Raymond" <esr@thyrsus.com>
Date: Wed, 7 Dec 2016 19:17:17 -0500
Subject: [PATCH 212/268] Directory reorganization. Clients and standalone
 tools move to ntpclients.

Yes, 'clients' is bit meretricious here because things like ntpviz
and ntpleapfetch that aren't strictly are included.  Forget theory,
this is a clutter-reduction move.
---
 INSTALL                           |   10 +-
 README                            |   35 +-
 ntpclients/ntpdig                 |  408 +++++++++
 ntpclients/ntpdig-man.txt         |   19 +
 ntpclients/ntpkeygen              |   88 ++
 ntpclients/ntpkeygen-man.txt      |   19 +
 ntpclients/ntpleapfetch           |  430 +++++++++
 ntpclients/ntpleapfetch-man.txt   |   22 +
 ntpclients/ntpq                   | 1677 +++++++++++++++++++++++++++++++++++
 ntpclients/ntpq-man.txt           |   20 +
 ntpclients/ntpsweep               |  181 ++++
 ntpclients/ntpsweep-man.txt       |   54 ++
 ntpclients/ntptrace               |  162 ++++
 ntpclients/ntptrace-man.txt       |   16 +
 ntpclients/ntpviz                 | 1738 +++++++++++++++++++++++++++++++++++++
 ntpclients/ntpviz-man.txt         |   21 +
 ntpclients/ntpwait                |  200 +++++
 ntpclients/ntpwait-man.txt        |   19 +
 ntpdig/ntpdig                     |  408 ---------
 ntpdig/ntpdig-man.txt             |   19 -
 ntpkeygen/ntpkeygen               |   88 --
 ntpkeygen/ntpkeygen-man.txt       |   19 -
 ntpleapfetch/ntpleapfetch         |  430 ---------
 ntpleapfetch/ntpleapfetch-man.txt |   22 -
 ntpq/ntpq                         | 1677 -----------------------------------
 ntpq/ntpq-man.txt                 |   20 -
 ntpstats/README                   |   15 -
 ntpstats/ntpviz                   | 1738 -------------------------------------
 ntpstats/ntpviz-man.txt           |   21 -
 ntpsweep/ntpsweep                 |  181 ----
 ntpsweep/ntpsweep-man.txt         |   54 --
 ntptrace/ntptrace                 |  162 ----
 ntptrace/ntptrace-man.txt         |   16 -
 ntpwait/ntpwait                   |  200 -----
 ntpwait/ntpwait-man.txt           |   19 -
 wscript                           |   33 +-
 36 files changed, 5106 insertions(+), 5135 deletions(-)
 create mode 100755 ntpclients/ntpdig
 create mode 100644 ntpclients/ntpdig-man.txt
 create mode 100755 ntpclients/ntpkeygen
 create mode 100644 ntpclients/ntpkeygen-man.txt
 create mode 100755 ntpclients/ntpleapfetch
 create mode 100644 ntpclients/ntpleapfetch-man.txt
 create mode 100755 ntpclients/ntpq
 create mode 100644 ntpclients/ntpq-man.txt
 create mode 100755 ntpclients/ntpsweep
 create mode 100644 ntpclients/ntpsweep-man.txt
 create mode 100755 ntpclients/ntptrace
 create mode 100644 ntpclients/ntptrace-man.txt
 create mode 100755 ntpclients/ntpviz
 create mode 100644 ntpclients/ntpviz-man.txt
 create mode 100755 ntpclients/ntpwait
 create mode 100644 ntpclients/ntpwait-man.txt
 delete mode 100755 ntpdig/ntpdig
 delete mode 100644 ntpdig/ntpdig-man.txt
 delete mode 100755 ntpkeygen/ntpkeygen
 delete mode 100644 ntpkeygen/ntpkeygen-man.txt
 delete mode 100755 ntpleapfetch/ntpleapfetch
 delete mode 100644 ntpleapfetch/ntpleapfetch-man.txt
 delete mode 100755 ntpq/ntpq
 delete mode 100644 ntpq/ntpq-man.txt
 delete mode 100644 ntpstats/README
 delete mode 100755 ntpstats/ntpviz
 delete mode 100644 ntpstats/ntpviz-man.txt
 delete mode 100755 ntpsweep/ntpsweep
 delete mode 100644 ntpsweep/ntpsweep-man.txt
 delete mode 100755 ntptrace/ntptrace
 delete mode 100644 ntptrace/ntptrace-man.txt
 delete mode 100755 ntpwait/ntpwait
 delete mode 100644 ntpwait/ntpwait-man.txt

diff --git a/INSTALL b/INSTALL
index 633542a..ebfee40 100644
--- a/INSTALL
+++ b/INSTALL
@@ -237,6 +237,14 @@ Configure NTPSec with:
 
 There are also --cross-cflags and --cross-ldflags to supply the cross compiler 
 with appropriate values.
-                                                                  
+
+== Statistics ==
+
+If you want to generate the ntpviz graphs regularly, add these lines to
+your root crontab:
+
+53 * * * * cd /usr/local/src/NTP/ntpsec/ntpstats; ./ntpviz -p 1 -o day
+45 11,23 * * * cd /usr/local/src/NTP/ntpsec/ntpstats; ./ntpviz -p 7 -o week
+
 // end
 
diff --git a/README b/README
index 646f255..a81590e 100644
--- a/README
+++ b/README
@@ -57,45 +57,22 @@ libparse/:: 	This directory contains the files making up the parser for
 		by just providing a conversion routine and the
 		appropriate NTP parameters
 
-ntpd/::		Sources for the main time-synchronization daemon.
+ntpclients/::   Directory containing sources for clients - utility programs
+		to query local and remote NTP installations for log status,
+		state variables, and other timekeeping information.  The term
+		"clients" is used quite loosely here; any tool that is not a
+		not a multi-file C program probably lives in this directory.
 
-ntpdig/::	Query an NTP or SNTP server to report or set the time.
-		(This tool was formerly sntp).
+ntpd/::		Sources for the main time-synchronization daemon.
 
 ntpfrob/::       The ntpfrob utility collects several small diagnostic
 		functions for reading and tweaking the local clock
 		hardware, including reading the clock tick rate,
 		precision, and jitter.
 
-ntpkeygen/::	Directory containing the utility program used to generate
-		NTP authentication keys.
-
-ntpleapfetch/::	Directory containing a script to be run from a cron job
-		to keep your local leap-second file properly updated.
-
-ntpq/::		Directory containing sources for a utility program to
-		query local and remote NTP peers for state variables and
-		related timekeeping information.
-
-ntpstats/::	Statistics visualization and analysis tools built around
-		the Python ntpstats.py module. Includes ntpviz.
-
-ntpsweep/::	Directory containing source for a utility program that can
-		fetch basic information about timservers, recursing through
-		peers to map the nearby topology of the time-service network.
-
 ntptime/:: 	Directory containing a utility for reading and modifying
 		kernel parameters related to the local clock.
 
-ntptrace/::	Directory containing source for a utility program that
-		can be used to reveal the chain of NTP peers from a
-		designated peer to the primary server at the root of the
-		timekeeping subnet.
-
-ntpwait/::	Directory containing a script that blocks until ntpd is
-		in state 4 (synchronized). Useful at boot time, to delay
-		the boot sequence until after "ntpd -g" has set the time.
-
 pylib/::	Installable Python helper classes for scripts.
 
 tests/::	Self-test code.
diff --git a/ntpclients/ntpdig b/ntpclients/ntpdig
new file mode 100755
index 0000000..d19e3ec
--- /dev/null
+++ b/ntpclients/ntpdig
@@ -0,0 +1,408 @@
+#!/usr/bin/python
+"""
+ntpdig - simple SNTP client
+
+"""
+# SPDX-License-Identifier: BSD-2-clause
+# This code runs identically under Python 2 and Python 3. Keep it that way!
+from __future__ import print_function, division
+
+# This code is somewhat stripped down from the legacy C version.  It
+# does however have one additional major feature; it can filter
+# out falsetickers from multiple samples, like the ntpdate of old,
+# rather than just taking the first reply it gets.
+#
+# Listening to broadcast addresses is not implemented because that is
+# impossible to secure. KOD recording is also not implemented, as it
+# can too easily be spammed.  Thus, the options -b and -K are not
+# implemented.
+#
+# There are no version 3 NTP servers left, so the -o version for setting
+# NTP version has been omitted.
+#
+# Because ntpdig doesn't use symmetric-peer mode (it never did, and NTPsec has
+# abolished that mode because it was a security hazard), there's no need to
+# set the packet source port, so -r/--usereservedport has been dropped.
+# If this option ever needs to be reinstated, the magic is described here:
+# http://stackoverflow.com/questions/2694212/socket-set-source-port-number
+# and would be s.bind(('', 123)) right after the socket creation.
+#
+# The -w/--wait and -W/--nowait options only made sense with asynchronous
+# DNS.  Asynchronous DNS was absurd overkill for this application, we are
+# not looking up 20,000 hosts here.  It has not been implemented, so neither
+# have these options.
+#
+# Finally, logging to syslog by default was a design error, violating
+# Unix principles, that has been fixed. To get this behavior when
+# running in a script, redirect standard error to logger(1). 
+#
+# The one new option in this version is -p, borrowed from ntpdate.
+
+import sys, socket, select, struct, time, getopt, datetime, math
+
+try:
+    import ntp.packet
+    import ntp.util
+    import ntp.magic
+except:
+    sys.stderr.write("ntpdig: can't find Python NTP library -- check PYTHONPATH.\n")
+    sys.exit(1)
+
+def queryhost(server, concurrent, timeout=5, port=123):
+    "Query IP addresses associated with a specified host."
+    try:
+        iptuples = socket.getaddrinfo(server, port,
+                                      af, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
+    except socket.gaierror as e:
+        log("lookup of %s failed, errno %d = %s" % (server, e[0], e[1]))
+        return []
+    sockets = []
+    packets = []
+    request = ntp.packet.SyncPacket()
+    request.transmit_timestamp = ntp.packet.SyncPacket.posix_to_ntp(time.time())
+    packet = request.flatten()
+    for (family, socktype, proto, canonname, sockaddr) in iptuples:
+        if debug:
+            log("querying %s (%s)" % (sockaddr[0], server))
+        s = socket.socket(family, socktype)
+        if keyid and keytype and passwd:
+            if debug:
+                log("authenticating with %s key %d" % (keytype, keyid))
+            mac = ntp.packet.Authenticator.compute_mac(packet,
+                                                       keyid, keytype, passwd)
+            if mac is None:
+                log("MAC generation failed while querying %s" % server)
+                raise SystemExit(1)
+            else:
+                packet += mac
+        try:
+            s.sendto(packet, sockaddr)
+        except socket.error as e:
+            log("socket error on transmission: %s" % e)
+            raise SystemExit(1)
+        if debug >= 2:
+            log("Sent to %s:" % (sockaddr[0],))
+            ntp.packet.dump_hex_printable(packet)
+        def read_append(s, packets):
+            d, a = s.recvfrom(1024)
+            if debug >= 2:
+                ntp.packet.dump_hex_printable(d)
+            if credentials:
+                if not ntp.packet.Authenticator.have_mac(d):
+                    if debug:
+                        log("no MAC on reply from %s" % packet.hostname)
+                if not credentials.verify_mac(d):
+                    packet.trusted = False
+                    log("MAC verification on reply from %s failed" % sockaddr[0])
+                elif debug:
+                    log("MAC verification on reply from %s succeeded" % sockaddr[0])
+            pkt = ntp.packet.SyncPacket(d)
+            pkt.hostname = server
+            pkt.resolved = sockaddr[0]
+            packets.append(pkt)
+            time.sleep(gap)
+        if concurrent:
+            sockets.append(s)
+        else:
+            r, _, _ = select.select([s], [], [], timeout)
+            if not r:
+                return []
+            read_append(s, packets)
+    if concurrent:
+        while sockets:
+            r, _, _ = select.select(sockets, [], [], timeout)
+            if not r:
+                return packets
+            for s in sockets:
+                read_append(s, packets)
+                sockets.remove(s)
+    return packets
+
+def clock_select(packets):
+    "Select the pick-of-the-litter clock from the samples we've got."
+    # This is a slightly simplified version of the filter ntpdate used
+    NTP_INFIN     = 15		# max stratum, infinity a la Bellman-Ford 
+    NTP_MAXAGE    = 86400	# one day in seconds
+
+    # This first chunk of code is supposed to go through all
+    # servers we know about to find the servers that
+    # are most likely to succeed. We run through the list
+    # doing the sanity checks and trying to insert anyone who
+    # looks okay. We are at all times aware that we should
+    # only keep samples from the top two strata.
+    # 
+    nlist = 0	# none yet
+    filtered = []
+    for response in packets:
+        def drop(msg):
+            log("%s: Response dropped: %s" % (response.hostname, msg))
+        if response.stratum > NTP_INFIN:
+            drop("stratum too high")
+            continue
+        if response.version() < ntp.magic.NTP_OLDVERSION:
+            drop("response version %d is too old" % response.version())
+            continue
+        if response.mode() != ntp.magic.MODE_SERVER:
+            drop("unexpected response mode %d" % response.mode())
+            continue
+        if response.version() > ntp.magic.NTP_VERSION:
+            drop("response version %d is too new" % response.version())
+            continue
+        if response.stratum == 0:
+            # FIXME: Do some kind of semi-useful diagnostic dump here
+            drop("stratum 0, probable KOD packet")
+            continue
+        if response.leap() == "unsync":
+            drop("leap not in sync")
+            continue
+        if not response.trusted:
+            drop("request was authenticated but server is untrusted")
+            continue
+        # Bypass this test if we ever support broadcast-client mode again 
+        if response.origin_timestamp == 0:
+            drop("unexpected response timestamp")
+            continue
+        filtered.append(response)
+
+    if len(filtered) <= 1:
+        return filtered
+
+    # Sort by stratum and other figures of merit
+    filtered.sort(key=lambda s: (s.stratum, s.synchd(), s.root_delay))
+
+    # Return the best
+    return filtered[:1]
+
+def report(packet, json):
+    "Report on the SNTP packet selected for display, and its adjustment."
+    say = sys.stdout.write
+
+    packet.posixize()
+
+    # Cheesy way to get local timezone offset
+    gmt_time = int(time.time())
+    local_time = int(time.mktime(time.gmtime(gmt_time)))
+    tmoffset = (local_time - gmt_time) // 60	# In minutes
+
+    # The server's idea of the time
+    t = time.localtime(int(packet.transmit_timestamp))
+    ms = int(packet.transmit_timestamp * 1000000) % 1000000
+
+    # Number of decimal digits of precision indicated by the precision field
+    digits = min(6, -int(math.log10(2**packet.precision)))
+
+    date = time.strftime("%Y-%m-%d", t)
+    tod = time.strftime("%T", t) + (".%*d" % (digits, ms))
+    sgn = ("%+d" % tmoffset)[0]
+    tz = "%s%02d%02d" % (sgn, tmoffset // 60, tmoffset % 60)
+
+    if json:
+        say('{"time":"%sT%s%s","offset":%f,"precision":%f,"host":"%s",ip:"%s","stratum":%s,"leap":"%s","adjusted":%s}\n' % \
+            (date, tod, tz,
+             packet.adjust(), packet.synchd(),
+             packet.hostname, packet.resolved or packet.hostname,
+             packet.stratum, packet.leap(),
+             "true" if adjusted else "false"))
+    else:
+        say("%s %s (%s) %+f +/- %f %s" % \
+            (date, tod, tz,
+             packet.adjust(), packet.synchd(),
+             packet.hostname))
+        if packet.resolved and packet.resolved != packet.hostname:
+            say(" " + packet.resolved)
+        say(" s%d %s\n" % (packet.stratum, packet.leap()))
+
+usage = """
+USAGE:  sntp [ -<flag> [<val>] | --<name>[{=| }<val>] ]...
+		[ hostname-or-IP ...]
+  Flg Arg Option-Name     Description
+   -4 no  ipv4           Force IPv4 DNS name resolution
+				- prohibits the option 'ipv6'
+   -6 no  ipv6           Force IPv6 DNS name resolution
+				- prohibits the option 'ipv4'
+   -a Num authentication  Enable authentication with the numbered key
+   -c yes concurrent      Hosts to be queried concurrently
+   -d no  debug           Increase debug verbosity
+   -D yes set-debug-level Set debug verbosity
+   -g yes gap             Set gap between requests
+   -j no  json            Use JSON output format
+   -l Str logfile         Log to specified logfile
+				 - prohibits the option 'syslog'
+   -p yes samples         Number of samples to take (default 1) 
+   -S no  step            Set (step) the time with clock_settime()
+				 - prohibits the option 'step'
+   -s no  slew            Set (slew) the time with adjtime()
+				 - prohibits the option 'slew'
+   -t Num timeout         Request timeout in seconds (default 5)
+   -k Str keyfile         Specify a keyfile. SNTP will look in this file
+                          for the key specified with -a
+   -V no version          Output version information and exit
+   -h no  help            Display extended usage information and exit
+"""
+
+if __name__ == '__main__':
+    try:
+        (options, arguments) = getopt.getopt(sys.argv[1:],
+                                             "46a:c:dD:g:hjk:l:M:o:p:r:Sst:wWV",
+                                             ["ipv4","ipv6",
+                                              "authentication=",
+                                              "concurrent=",
+                                              "gap=", "help", "json",
+                                              "keyfile=", "logfile=",
+                                              "replay=",
+                                              "samples=", "steplimit=",
+                                              "step", "slew",
+                                              "timeout=",
+                                              "debug", "set-debug-level=",
+                                              "version"])
+    except getopt.GetoptError as e:
+        print(e)
+        raise SystemExit(1)
+    progname = sys.argv[0]
+
+    logfp = sys.stderr
+    log = lambda m: logfp.write("ntpdig: %s\n" % m)
+
+    af = socket.AF_UNSPEC
+    authkey = None
+    concurrent_hosts = []
+    debug = 0
+    gap = 50
+    json = False
+    keyfile = None
+    steplimit = 0	# Default is intentionally zero
+    samples = 1
+    step = False
+    slew = False
+    timeout = 5
+    replay = None
+    try:
+        for (switch, val) in options:
+            if switch in ("-4", "--ipv4"):
+                af = socket.AF_INET
+            elif switch in ("-6", "--ipv6"):
+                af = socket.AF_INET6
+            elif switch in ("-a", "--authentication"):
+                authkey = int(val)
+            elif switch in ("-c", "--concurrent"):
+                concurrent_hosts.append(val)
+            elif switch in ("-d", "--debug"):
+                debug += 1
+            elif switch in ("-D", "--set-debug-level"):
+                debug = int(val)
+            elif switch in ("-j", "--json"):
+                json = True
+            elif switch in ("-k", "--keyfile"):
+                keyfile = val
+            elif switch in ("-l", "--logfile"):
+                try:
+                    logfp = open(val, "w")
+                except OSError:
+                    sys.stderr.write("logfile open of %s failed.\n" % val)
+                    raise SystemExit(1)
+            elif switch in ("-M", "--steplimit"):
+                steplimit = int(val)
+            elif switch in ("-p", "--samples"):
+                samples = int(val)
+            elif switch in ('-r', "--replay"):
+                replay = val
+            elif switch in ("-S", "--step"):
+                step = True
+            elif switch in ("-s", "--slew"):
+                slew = True
+            elif switch in ("-t", "--timeout"):
+                timeout = int(val)
+            elif switch in ("-h", "--help"):
+                print(usage)
+                raise SystemExit(0)
+            elif switch in ("-V", "--version"):
+                print(ntp.util.stdversion())
+                raise SystemExit(0)
+            else:
+                sys.stderr.write("Unknown command line switch or missing argument.\n")
+                sys.stderr.write(usage)
+                raise SystemExit(1)
+    except ValueError:
+        sys.stderr.write("Invalid argument.\n")
+        sys.stderr.write(usage)
+        raise SystemExit(1)
+
+    credentials = keyid = keytype = passwd = None
+    try:
+        credentials = ntp.packet.Authenticator(keyfile)
+    except (OSError, IOError):
+        pass
+    if credentials:
+        try:
+            (keyid, keytype, passwd) = credentials.control(authkey)
+        except ValueError:
+            # There are no trusted keys.  Barf.
+            log("cannot get authentication key")
+            raise SystemExit(1)
+
+    if not credentials and authkey and keyfile is None:
+        self.warn("-a option requires -k.\n")
+        raise SystemExit(1)
+
+    gap /= 1000	# Scale gap to milliseconds
+
+    if not arguments:
+        arguments = ["localhost"]
+
+    if replay:
+        (pkt, dst) = replay.split(":")
+        packet = ntp.packet.SyncPacket(pkt.decode("hex"))
+        packet.received = ntp.packet.SyncPacket.posix_to_ntp(float(dst))
+        returned = [packet]
+    else:
+        returned = []
+        for server in concurrent_hosts:
+            try:
+                returned += queryhost(server=server, concurrent=True, timeout=timeout)
+            except ntp.packet.SyncException as e:
+                log(e.message)
+                continue
+            if len(returned) >= samples:
+                break
+        for server in arguments:
+            try:
+                returned += queryhost(server=server, concurrent=False, timeout=timeout)
+            except ntp.packet.SyncException as e:
+                log(e.message)
+                continue
+            if len(returned) >= samples:
+                break
+        returned = clock_select(returned)
+
+    if returned:
+        pkt = returned[0]
+        if debug:
+            #print(repr(pkt))
+            def hexstamp(n):
+                return "%08x.%08x" % (n >> 32, n & 0x00000000ffffffff)
+            print("org t1: %s rec t2: %s" % (hexstamp(pkt.t1()), hexstamp(pkt.t2())))
+            print("xmt t3: %s dst t4: %s" % (hexstamp(pkt.t3()), hexstamp(pkt.t4())))
+            pkt.posixize()
+            print("org t1: %f rec t2: %f" % (pkt.t1(), pkt.t2()))
+            print("xmt t3: %f dst t4: %f" % (pkt.t3(), pkt.t4()))
+            print("rec-org t21: %f  xmt-dst t34: %f" % (pkt.t2() - pkt.t1(), pkt.t3() - pkt.t4()))
+        adjusted = step and (not slew or (slew and (abs(offset) > steplimit)))
+        report(pkt, json)
+	# If we can step but we cannot slew, then step.
+	# If we can step or slew and and |offset| > steplimit, then step.
+        rc = True
+        offset = pkt.adjust()
+        ntp.ntpc.setprogname("ntpdig")
+        if adjusted:
+		rc = ntp.ntpc.step_systime(offset)
+	elif slew:
+		rc = ntp.ntpc.adj_systime(offset)
+        if rc:
+            raise SystemExit(0)
+        else:
+            raise SystemExit(1)
+    else:
+        log("no eligible servers")
+        raise SystemExit(1)
+
+#end
diff --git a/ntpclients/ntpdig-man.txt b/ntpclients/ntpdig-man.txt
new file mode 100644
index 0000000..bf46b36
--- /dev/null
+++ b/ntpclients/ntpdig-man.txt
@@ -0,0 +1,19 @@
+= ntpdig(1) =
+:doctype: manpage
+
+== NAME ==
+ntpdig - standard Simple Network Time Protocol client program
+
+include::../docs/includes/ntpdig-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+
+// end
+
diff --git a/ntpclients/ntpkeygen b/ntpclients/ntpkeygen
new file mode 100755
index 0000000..f0d8dd6
--- /dev/null
+++ b/ntpclients/ntpkeygen
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+#
+# ntpkeygen - program to generate cryptographic keys for ntp clients and servers
+# 
+# All file names are like "ntpkey_<type>_<hostname>.<filestamp>", where
+# <type> is the file type, <hostname> the generating host name and
+# <filestamp> the generation time in NTP seconds. The NTP programs
+# expect generic names such as "ntpkey_<type>_whimsy.udel.edu" with the
+# association maintained by soft links. Following is a list of file
+# types.
+# 
+# ntpkey_MD5key_<hostname>.<filestamp>
+# MD5 (128-bit) keys used to compute message digests in symmetric
+# key cryptography
+
+import os, sys, socket, random, time, getopt, stat
+
+#
+# Cryptodefines
+# 
+MD5KEYS	= 10	# number of keys generated of each type 
+MD5SIZE	= 20	# maximum key size 
+
+def gen_md5(id, groupname):
+    "Generate semi-random MD5 and SHA1 keys compatible with NTPv3 and NTPv4."
+    with fheader("MD5key", id, groupname) as wp:
+        for i in range(1, MD5KEYS+1):
+            md5key = ""
+            for j in range(MD5SIZE):
+                while True:
+                    r = randomizer.randint(0x21, 0x7e)
+                    if r != ord('#'):
+                        break
+                md5key += chr(r)
+            wp.write("%2d MD5 %s  # MD5 key\n" % (i,  md5key))
+        for i in range(1, MD5KEYS+1):
+            sha1key = ""
+            for j in range(MD5SIZE):
+                sha1key += "%02x" % randomizer.randint(0x00, 0xff)
+            wp.write("%2d SHA1 %s  # SHA1 key\n" % (i + MD5KEYS, sha1key))
+
+#
+# Generate file header and link
+# 
+def fheader(
+	file,	# file name id 
+	ulink,	# linkname 
+	owner	# owner name 
+        ):
+    try:
+	filename = "ntpkey_%s_%s.%u" % (file,  owner, int(time.time())) 
+        orig_umask = os.umask(stat.S_IWGRP | stat.S_IRWXO)
+        wp = open(filename, "w")
+        os.umask(orig_umask)
+
+        linkname = "ntp.keys"
+        if os.path.exists(linkname):
+            os.remove(linkname)		# The symlink() line below matters 
+	os.symlink(filename, linkname)
+
+	sys.stderr.write("Generating new %s file and link\n" % ulink)
+	sys.stderr.write("%s->%s\n" % (linkname, filename))
+	wp.write("# %s\n# %s\n" % (filename, time.ctime()))
+	return wp
+    except IOError:
+        sys.stderr.write("Key file creation or link failed.\n")
+        raise SystemExit(1)
+
+if __name__ == '__main__':
+    try:
+        (options, arguments) = getopt.getopt(sys.argv[1:], "hM:", ["help"])
+    except getopt.GetoptError as e:
+        print(e)
+        raise SystemExit(1)
+
+    for (switch, val) in options:
+        if switch == '-M':
+            # dummy MD5 option for backwards compatibility 
+            pass
+        elif switch in ("-h", "--help"):
+            print("usage: ntpkeygen [-M]")
+            raise SystemExit(0)
+
+    randomizer = random.SystemRandom(time.time() + os.getpid())
+    gen_md5("md5", socket.gethostname())
+    raise SystemExit(0)
+
+#end
diff --git a/ntpclients/ntpkeygen-man.txt b/ntpclients/ntpkeygen-man.txt
new file mode 100644
index 0000000..0bd86f9
--- /dev/null
+++ b/ntpclients/ntpkeygen-man.txt
@@ -0,0 +1,19 @@
+= ntpkeygen(8) =
+:doctype: manpage
+
+== NAME ==
+ntpkeygen - create and manage NTP host keys
+
+include::../docs/includes/ntpkeygen-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+
+// end
+
diff --git a/ntpclients/ntpleapfetch b/ntpclients/ntpleapfetch
new file mode 100755
index 0000000..7d9868e
--- /dev/null
+++ b/ntpclients/ntpleapfetch
@@ -0,0 +1,430 @@
+#!/bin/bash
+
+# Copyright (C) 2014 Timothe Litt litt at acm dot org
+#
+# SPDX-License-Identifier: BSD-2-clause
+#
+# Bugfixes and improvements would be appreciated by the author.
+
+VERSION="1.003"
+
+# leap-seconds file manager/updater
+
+# Depends on:
+#  wget sed, tr, shasum, logger
+
+# ########## Default configuration ##########
+#
+# Where to get the file
+LEAPSRC="ftp://time.nist.gov/pub/leap-seconds.list"
+
+# How many times to try to download new file
+MAXTRIES=6
+INTERVAL=10
+
+# Where to find ntp config file
+NTPCONF=/etc/ntp.conf
+
+# How long before expiration to get updated file
+PREFETCH="60 days"
+
+# How to restart NTP - older NTP: service ntpd? try-restart | condrestart
+# Recent NTP checks for new file daily, so there's nothing to do
+RESTART=
+
+# Where to put temporary copy before it's validated
+TMPFILE="/tmp/leap-seconds.$$.tmp"
+
+# Syslog facility
+LOGFAC=daemon
+# ###########################################
+
+# Places to look for commands.  Allows for CRON having path to
+# old utilities on embedded systems
+
+PATHLIST="/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:"
+
+REQUIREDCMDS=" wget logger tr sed shasum"
+
+SELF="`basename $0`"
+
+function displayHelp {
+            cat <<EOF
+Usage: $SELF [options] [leapfile]
+
+Verifies and if necessary, updates leap-second definition file
+
+All arguments are optional:  Default (or current value) shown:
+    -s    Specify the URL of the master copy to download
+          $LEAPSRC
+    -4    Use only IPv4
+    -6    Use only IPv6
+    -p 4|6
+          Prefer IPv4 or IPv6 (as specified) addresses, but use either
+    -d    Specify the filename on the local system
+    -e    Specify how long before expiration the file is to be refreshed
+          Units are required, e.g. "-e 60 days"  Note that larger values
+          imply more frequent refreshes.
+          "$PREFETCH"
+    -f    Specify location of ntp.conf (used to make sure leapfile directive is
+          present and to default  leapfile)
+          $NTPCONF
+    -F    Force update even if current file is OK and not close to expiring.
+    -c    Command to restart NTP after installing a new file
+          <none> - ntpd checks file daily
+    -r    Specify number of times to retry on get failure
+          $MAXTRIES
+    -i    Specify number of minutes between retries
+          $INTERVAL
+    -l    Use syslog for output (Implied if CRONJOB is set)
+    -L    Don't use syslog for output
+    -P    Specify the syslog facility for logging
+          $LOGFAC
+    -t    Name of temporary file used in validation
+    -q    Only report errors to stdout
+    -v    Verbose output
+    -z    Specify path for utilities
+          $PATHLIST
+    -Z    Only use system path
+
+$SELF will validate the file currently on the local system
+
+Ordinarily, the file is found using the "leapfile" directive in $NTPCONF.
+However, an alternate location can be specified on the command line.
+
+If the file does not exist, is not valid, has expired, or is expiring soon,
+a new copy will be downloaded.  If the new copy validates, it is installed and
+NTP is (optionally) restarted.
+
+If the current file is acceptable, no download or restart occurs.
+
+-c can also be used to invoke another script to perform administrative
+functions, e.g. to copy the file to other local systems.
+
+This can be run as a cron job.  As the file is rarely updated, and leap
+seconds are announced at least one month in advance (usually longer), it
+need not be run more frequently than about once every three weeks.
+
+For cron-friendly behavior, define CRONJOB=1 in the crontab.
+
+This script depends on:$REQUIREDCMDS
+
+Version $VERSION
+EOF
+   return 0
+}
+
+# Default: Use syslog for logging if running under cron
+
+SYSLOG="$CRONJOB"
+
+if [ "$1" = "--help" ]; then
+    displayHelp
+    exit 0
+fi
+
+# Parse options
+
+while getopts 46p:P:s:e:f:Fc:r:i:lLt:hqvz:Z opt; do
+    case $opt in
+        4)
+            PROTO="-4"
+            ;;
+        6)
+            PROTO="-6"
+            ;;
+        p)
+            if [ "$OPTARG" = '4' -o "$OPTARG" = '6' ]; then
+                PREFER="--prefer-family=IPv$OPTARG"
+            else
+                echo "Invalid -p $OPTARG" >&2
+                exit 1;
+            fi
+            ;;
+	P)
+	    LOGFAC="$OPTARG"
+	    ;;
+        s)
+            LEAPSRC="$OPTARG"
+            ;;
+        e)
+            PREFETCH="$OPTARG"
+            ;;
+	f)
+	    NTPCONF="$OPTARG"
+	    ;;
+        F)
+            FORCE="Y"
+            ;;
+        c)
+            RESTART="$OPTARG"
+            ;;
+        r)
+            MAXTRIES="$OPTARG"
+            ;;
+        i)
+            INTERVAL="$OPTARG"
+            ;;
+        t)
+            TMPFILE="$OPTARG"
+            ;;
+	l)
+	    SYSLOG="y"
+	    ;;
+	L)
+	    SYSLOG=
+	    ;;
+        h)
+            displayHelp
+            exit 0
+            ;;
+	q)
+	    QUIET="Y"
+	    ;;
+        v)
+            VERBOSE="Y"
+            ;;
+	z)
+	    PATHLIST="$OPTARG:"
+	    ;;
+	Z)
+	    PATHLIST=
+	    ;;
+        *)
+            echo "$SELF -h for usage" >&2
+            exit 1
+            ;;
+    esac
+done
+shift $((OPTIND-1))
+
+export PATH="$PATHLIST$PATH"
+
+# Add to path to deal with embedded systems
+#
+for P in $REQUIREDCMDS ; do
+    if >/dev/null 2>&1 which "$P" ; then
+	continue
+    fi
+    [ "$P" = "logger" ] && continue
+    echo "FATAL: missing $P command, please install"
+    exit 1
+done
+
+# Handle logging
+
+if ! LOGGER="`2>/dev/null which logger`" ; then
+    LOGGER=
+fi
+
+function log {
+    # "priority" "message"
+    #
+    # Stdout unless syslog specified or logger isn't available
+    #
+    if [ -z "$SYSLOG" -o -z "$LOGGER" ]; then
+	if [ -n "$QUIET" -a \( "$1" = "info" -o "$1" = "notice" -o "$1" = "debug" \) ]; then
+	    return 0
+	fi
+	echo "`echo \"$1\" | tr a-z A-Z`: $2"
+	return 0
+    fi
+
+    # Also log to stdout if cron job && notice or higher
+    local S
+    if [ -n "$CRONJOB" -a \( "$1" != "info" \) -a \( "$1" != "debug" \) ] || [ -n "$VERBOSE" ]; then
+	S="-s"
+    fi
+    $LOGGER $S -t "$SELF[$$]" -p "$LOGFAC.$1" "$2"
+}
+
+# Verify interval
+INTERVAL=$(( $INTERVAL *1 ))
+
+# Validate a leap-seconds file checksum
+#
+# File format: (full description in files)
+# # marks comments, except:
+# #$ number : the NTP date of the last update
+# #@ number : the NTP date that the file expires
+# Date (seconds since 1900) leaps : leaps is the # of seconds to add for times >= Date
+# Date lines have comments.
+# #h hex hex hex hex hex is the SHA-1 checksum of the data & dates, excluding whitespace w/o leading zeroes
+
+function verifySHA {
+
+    if [ ! -f "$1" ]; then
+        return 1
+    fi
+
+    # Remove comments, except those that are markers for last update, expires and hash
+
+    local RAW="`sed $1 -e'/^\\([0-9]\\|#[\$@h]\)/!d' -e'/^#[\$@h]/!s/#.*\$//g'`"
+
+    # Extract just the data, removing all whitespace
+
+    local DATA="`echo \"$RAW\" | sed -e'/^#h/d' -e's/^#[\$@]//g' | tr -d '[:space:]'`"
+
+    # Compute the SHA hash of the data, removing the marker and filename
+    # Computed in binary mode, which shouldn't matter since whitespace has been removed
+    # shasum comes in several flavors; a portable one is available in Perl (with Digest::SHA)
+
+    local DSHA="`echo -n \"$DATA\" | shasum | sed -e's/[? *].*$//'`"
+
+    # Extract the file's hash. Restore any leading zeroes in hash segments.
+
+    # The sed [] includes a tab (\t) and space; #h is followed by a tab and space
+    local FSHA="`echo \"$RAW\" | sed -e'/^#h/!d' -e's/^#h//' -e's/[ 	] */ 0x/g'`"
+    FSHA=`printf '%08x%08x%08x%08x%08x' $FSHA`
+
+    if [ -n "$FSHA" -a \( "$FSHA" = "$DSHA" \) ]; then
+        if [ -n "$2" ]; then
+            log "info" "Checksum of $1 validated"
+        fi
+    else
+        log "error" "Checksum of $1 is invalid:"
+	[ -z "$FSHA" ] && FSHA="(no checksum record found in file)"
+        log "error" "EXPECTED: $FSHA"
+        log "error" "COMPUTED: $DSHA"
+        return 1
+    fi
+
+    # Check the expiration date, converting NTP epoch to Unix epoch used by date
+
+    EXPIRES="`echo \"$RAW\" | sed -e'/^#@/!d' -e's/^#@//' | tr -d '[:space:]'`"
+    EXPIRES="$(($EXPIRES - 2208988800 ))"
+
+    if [ $EXPIRES -lt `date -u +%s` ]; then
+        log "notice" "File expired on `date -u -d \"Jan 1, 1970 00:00:00 +0000 + $EXPIRES seconds\"`"
+        return 2
+    fi
+
+}
+
+# Verify ntp.conf
+
+if ! [ -f "$NTPCONF" ]; then
+    log "critical" "Missing ntp configuration $NTPCONF"
+    exit 1
+fi
+
+# Parse ntp.conf for leapfile directive
+
+LEAPFILE="`sed $NTPCONF -e'/^ *leapfile  *.*$/!d' -e's/^ *leapfile  *//'`"
+if [ -z "$LEAPFILE" ]; then
+    log "error" "$NTPCONF does not specify a leapfile"
+fi
+
+# Allow placing the file someplace else - testing
+
+if [ -n "$1" ]; then
+    if [ "$1" != "$LEAPFILE" ]; then
+	log "notice" "Requested install to $1, but $NTPCONF specifies $LEAPFILE"
+    fi
+    LEAPFILE="$1"
+fi
+
+# Verify the current file
+# If it is missing, doesn't validate or expired
+# Or is expiring soon
+#  Download a new one
+
+if [ -n "$FORCE" ] || ! verifySHA $LEAPFILE "$VERBOSE" || [ $EXPIRES -lt `date -d "NOW + $PREFETCH" +%s` ] ; then
+    TRY=0
+    while true; do
+        TRY=$(( $TRY + 1 ))
+        if [ -n "$VERBOSE" ]; then
+            log "info" "Attempting download from $LEAPSRC, try $TRY.."
+        fi
+        if wget $PROTO $PREFER -o ${TMPFILE}.log $LEAPSRC -O $TMPFILE ; then
+            log "info" "Download of $LEAPSRC succeeded"
+            if [ -n "$VERBOSE" ]; then
+                cat ${TMPFILE}.log
+            fi
+
+            if ! verifySHA $TMPFILE "$VERBOSE" ; then
+		# There is no point in retrying, as the file on the server is almost
+		# certainly corrupt.
+
+                log "warning" "Downloaded file $TMPFILE rejected -- saved for diagnosis"
+                cat ${TMPFILE}.log
+                rm -f ${TMPFILE}.log
+                exit 1
+            fi
+            rm -f ${TMPFILE}.log
+
+	    # Set correct permissions on temporary file
+
+	    REFFILE="$LEAPFILE"
+            if [ ! -f $LEAPFILE ]; then
+		log "notice" "$LEAPFILE was missing, creating new copy - check permissions"
+                touch $LEAPFILE
+		# Can't copy permissions from old file, copy from NTPCONF instead
+		REFFILE="$NTPCONF"
+            fi
+            chmod --reference $REFFILE $TMPFILE
+            chown --reference $REFFILE $TMPFILE
+	    ( which selinuxenabled && selinuxenabled && which chcon ) >/dev/null 2>&1
+            if  [ $? == 0 ] ; then
+                chcon --reference $REFFILE $TMPFILE
+            fi
+
+	    # Replace current file with validated new one
+
+            if mv -f $TMPFILE $LEAPFILE ; then
+                log "notice" "Installed new $LEAPFILE from $LEAPSRC"
+            else
+                log "error" "Install $TMPFILE => $LEAPFILE failed -- saved for diagnosis"
+                exit 1
+            fi
+
+	    # Restart NTP (or whatever else is specified)
+
+	    if [ -n "$RESTART" ]; then
+		if [ -n "$VERBOSE" ]; then
+		    log "info" "Attempting restart action: $RESTART"
+		fi
+		R="$( 2>&1 $RESTART )"
+		if [ $? -eq 0 ]; then
+		    log "notice" "Restart action succeeded"
+		    if [ -n "$VERBOSE" -a -n "$R" ]; then
+			log "info" "$R"
+		    fi
+		else
+		    log "error" "Restart action failed"
+		    if [ -n "$R" ]; then
+			log "error" "$R"
+		    fi
+		    exit 2
+		fi
+	    fi
+            exit 0
+	fi
+
+	# Failed to download.  See about trying again
+
+        rm -f $TMPFILE
+        if [ $TRY -ge $MAXTRIES ]; then
+            break;
+        fi
+        if [ -n "$VERBOSE" ]; then
+            cat ${TMPFILE}.log
+            log "info" "Waiting $INTERVAL minutes before retrying..."
+        fi
+        sleep $(( $INTERVAL * 60))
+    done
+
+    # Failed and out of retries
+
+    log "warning" "Download from $LEAPSRC failed after $TRY attempts"
+    if [ -f ${TMPFILE}.log ]; then
+        cat ${TMPFILE}.log
+        rm -f ${TMPFILE}.log $TMPFILE
+    fi
+    exit 1
+fi
+log "info" "Not time to replace $LEAPFILE"
+
+exit 0
+
+# EOF
diff --git a/ntpclients/ntpleapfetch-man.txt b/ntpclients/ntpleapfetch-man.txt
new file mode 100644
index 0000000..cb9035c
--- /dev/null
+++ b/ntpclients/ntpleapfetch-man.txt
@@ -0,0 +1,22 @@
+= ntpleapfetch(8) =
+:doctype: manpage
+
+== NAME == 
+ntpleapfetch - leap-seconds file manager/updater
+
+include::../docs/includes/ntpleapfetch-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+
+== AUTHORS ==
+
+Timothe Litt
+
+// end
diff --git a/ntpclients/ntpq b/ntpclients/ntpq
new file mode 100755
index 0000000..01a8057
--- /dev/null
+++ b/ntpclients/ntpq
@@ -0,0 +1,1677 @@
+#!/usr/bin/env python
+#
+# ntpq - query an NTP server using mode 6 commands
+#
+# Freely translated from the old C ntpq code by ESR.  The idea was to
+# cleanly separate ntpq-that-was into a thin front-end layer handling
+# mainly command interpretation and a back-end that presents the take
+# from ntpd as objects that can be re-used by other front
+# ends. Reusable pieces live in pylib.
+#
+# SPDX-License-Identifier: BSD-2-clause
+from __future__ import print_function, division
+
+import os, sys, getopt, cmd, re
+import socket, hashlib, collections
+
+try:
+    import ntp.packet
+    import ntp.util
+    import ntp.ntpc
+    import ntp.version
+    import ntp.control
+except ImportError as e:
+    sys.stderr.write("ntpq: can't find Python NTP library -- check PYTHONPATH.\n")
+    sys.stderr.write("%s\n" % e)
+    sys.exit(1)
+
+# This import only works on Unixes.  The intention is to enable
+# Ctrl-P, Ctrl-N, and friends in Cmd.
+try:
+    import readline
+except ImportError:
+    pass
+
+version = ntp.util.stdversion()
+
+# General notes on Python 2/3 compatibility:
+#
+# This code uses the following strategy to allow it to run on both Python 2
+# and Python 3:
+#
+# - Use binary I/O to read/write data from/to files and subprocesses;
+#   where the exact bytes are important (such as in checking for
+#   modified files), use the binary data directly
+#
+# - Use latin-1 encoding to transform binary data to/from Unicode when
+#   necessary for operations where Python 3 expects Unicode; the
+#   polystr and polybytes functions are used to do this so that
+#   when running on Python 2, the byte string data is used unchanged;
+#   also, the make_wrapper function constructs a text stream that can
+#   wrap a file opened in binary mode for cases where a file object
+#   that can be passed around from function to function is needed
+#
+# - Construct custom stdin, stdout, and stderr streams when running
+#   on Python 3 that force latin-1 encoding, and wrap them around the
+#   underlying binary buffers (in Python 2, the streams are binary
+#   and are used unchanged); this ensures that the same transformation
+#   is done on data from/to the standard streams, as is done on binary
+#   data from/to files and subprocesses; the make_std_wrapper function
+#   does this
+
+master_encoding = 'latin-1'
+
+if str is bytes:  # Python 2
+    polystr = str
+    polybytes = bytes
+
+    def string_escape(s):
+        return s.decode('string_escape')
+
+    def make_wrapper(fp):
+        return fp
+
+else:  # Python 3
+    import io
+
+    def polystr(o):
+        "Polymorphic string factory function"
+        if isinstance(o, str):
+            return o
+        if not isinstance(o, bytes):
+            return str(o)
+        return str(o, encoding=master_encoding)
+
+    def polybytes(s):
+        "Polymorphic string encoding function"
+        if isinstance(s, bytes):
+            return s
+        if not isinstance(s, str):
+            return bytes(s)
+        return bytes(s, encoding=master_encoding)
+
+    def string_escape(s):
+        "Polymorphic string_escape/unicode_escape"
+        # This hack is necessary because Unicode strings in Python 3 don't
+        # have a decode method, so there's no simple way to ask it for the
+        # equivalent of decode('string_escape') in Python 2. This function
+        # assumes that it will be called with a Python 3 'str' instance
+        return s.encode(master_encoding).decode('unicode_escape')
+
+    def make_wrapper(fp):
+        "Wrapper factory function to enforce master encoding"
+        # This can be used to wrap normally binary streams for API
+        # compatibility with functions that need a text stream in
+        # Python 3; it ensures that the binary bytes are decoded using
+        # the master encoding we use to turn bytes to Unicode in
+        # polystr above
+        # newline="\n" ensures that Python 3 won't mangle line breaks
+        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")
+
+    def make_std_wrapper(stream):
+        "Standard input/output wrapper factory function"
+        # This ensures that the encoding of standard output and standard
+        # error on Python 3 matches the master encoding we use to turn
+        # bytes to Unicode in polystr above
+        # line_buffering=True ensures that interactive command sessions work as expected
+        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)
+
+    sys.stdin = make_std_wrapper(sys.stdin)
+    sys.stdout = make_std_wrapper(sys.stdout)
+    sys.stderr = make_std_wrapper(sys.stderr)
+
+# NTP-specific parts resume here
+
+# Flags for forming descriptors.
+OPT		= 0x80	# this argument is optional, or'd with type */
+NO		= 0x0
+NTP_STR		= 0x1	# string argument
+NTP_UINT	= 0x2	# unsigned integer
+NTP_INT		= 0x3	# signed integer
+NTP_ADD		= 0x4	# IP network address
+IP_VERSION	= 0x5	# IP version
+NTP_ADP		= 0x6	# IP address and port
+NTP_LFP		= 0x7	# NTP timestamp
+NTP_MODE	= 0x8	# peer mode
+NTP_2BIT	= 0x9	# leap bits
+NTP_FLOAT	= 0xa	# Float value
+
+# Old CTL_PST defines for version 2.
+OLD_CTL_PST_CONFIG = 0x80
+OLD_CTL_PST_AUTHENABLE = 0x40
+OLD_CTL_PST_AUTHENTIC = 0x20
+OLD_CTL_PST_REACH = 0x10
+OLD_CTL_PST_SANE = 0x08
+OLD_CTL_PST_DISP = 0x04
+
+OLD_CTL_PST_SEL_REJECT = 0
+OLD_CTL_PST_SEL_SELCAND = 1
+OLD_CTL_PST_SEL_SYNCCAND = 2
+OLD_CTL_PST_SEL_SYSPEER = 3
+
+class Ntpq(cmd.Cmd):
+    "ntpq command interpreter"
+    def __init__(self, session):
+        cmd.Cmd.__init__(self)
+        self.session = session
+        self.prompt = "ntpq> "
+        self.interactive       = False	# set to True when we should prompt
+        #self.auth_keyid   = 0		# Keyid used for authentication.
+        #self.auth_keytype = "NID_md5"	# MD5 (FIXME: string value is a dummy)
+        #self.auth_hashlen = 16		# MD5
+        self.rawmode           = False	# Flag which indicates raw mode output.
+        self.showhostnames     = True	# If false, display numeric IPs
+        self.auth_delay    = 20		# delay time (default 20msec)
+        self.wideremote = False		# show wide remote names?
+        self.ccmds = []			# Queued commands
+        self.chosts = []		# Command-line hosts
+        self.peers = []			# Data from NTP peers.
+        self.debug = 0
+        self.pktversion = ntp.magic.NTP_OLDVERSION + 1
+        self.uservars = collections.OrderedDict()
+        self.ai_family = socket.AF_UNSPEC
+
+    def emptyline(self):
+        "Called when an empty line is entered in response to the prompt."
+        pass
+
+    def default(self, line):
+        "Called on an input line when the command prefix is not recognized."
+
+        if line.startswith(":config"):
+            line = line[1:]
+        elif line.startswith("config-from-file"):
+            line = line.replace("config-from-file ", "config_from_file")
+
+        cmd, arg, line = self.parseline(line)
+        dotext = 'do_'+cmd
+        cmdprefixlist = [a[3:] for a in self.get_names() if a.startswith(dotext)]
+        if len(cmdprefixlist) == 1:
+            line = line.replace(cmd, cmdprefixlist[0])
+            cmd = cmdprefixlist[0]
+        elif len(cmdprefixlist) > 1:
+            self.warn("***Command `%s' ambiguous\n" % cmd)
+            return
+        elif len(cmdprefixlist) == 0:
+            self.warn("***Command `%s' unknown\n" % cmd)
+            return
+
+        if cmd == "help" and arg:
+            helptext = 'help_'+arg
+            if helptext not in self.get_names():
+                argprefixlist = [a[5:] for a in self.get_names() if a.startswith(helptext)]
+                if len(argprefixlist) == 1:
+                    line = line.replace(arg, argprefixlist.pop())
+                elif len(argprefixlist) > 1:
+                    self.warn("Command `%s' is ambiguous\n" % arg)
+                    return
+                elif len(argprefixlist) == 0:
+                    self.warn("Command `%s' is unknown\n" % arg)
+                    return
+
+        self.onecmd(line)
+
+    def do_help(self, arg):
+        if arg:
+            helptext = 'help_'+arg
+            if helptext not in self.get_names():
+                argprefixlist = [a[5:] for a in self.get_names() if a.startswith(helptext)]
+                if len(argprefixlist) == 1:
+                    arg = argprefixlist.pop()
+                elif len(argprefixlist) > 1:
+                    self.warn("Command `%s' is ambiguous\n" % arg)
+                    return
+        cmd.Cmd.do_help(self, arg)
+
+    def do_shell(self, line):
+        "Called when a line that starts with ! is entered in response to the prompt."
+        self.warn("***Command `!%s' unknown\n" % line)
+        return
+
+    def say(self, msg):
+        sys.stdout.write(polystr(msg))
+        sys.stdout.flush()	# In case we're piping the output
+
+    def warn(self, msg):
+        sys.stderr.write(polystr(msg))
+
+    def help_help(self):
+        self.say("""\
+function: tell the use and syntax of commands
+usage: help [ command ]
+""")
+
+    # Unexposed helper tables and functions begin here
+
+    def __dogetassoc(self):
+        try:
+            self.peers = self.session.readstat()
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return False
+        except IOError as e:
+            print(e.strerror)
+            return False
+
+        if len(self.peers) == 0:
+            if self.chosts:
+                self.say("server=%s " % self.session.hostname)
+            self.say("No association IDs returned\n")
+            return False
+
+        if self.debug:
+            self.warn("\n%d associations total\n" % len(self.peers))
+        #sortassoc()
+        return True
+
+    def __printassoc(self, showall):
+        condition = ""
+        if not self.peers:
+            self.say("No association IDs in list\n")
+            return
+        self.say("\nind assid status  conf reach auth condition  last_event cnt\n")
+        self.say("===========================================================\n")
+        for (i, peer) in enumerate(self.peers):
+            statval = ntp.control.CTL_PEER_STATVAL(peer.status)
+            if not showall and (statval & (ntp.control.CTL_PST_CONFIG|ntp.control.CTL_PST_REACH)) == 0:
+                continue
+            event = ntp.control.CTL_PEER_EVENT(peer.status)
+            event_count = ntp.control.CTL_PEER_NEVNT(peer.status)
+            if statval & ntp.control.CTL_PST_CONFIG:
+                conf = "yes"
+            else:
+                conf = "no"
+            if statval & ntp.control.CTL_PST_BCAST:
+                    reach = "none"
+                    if statval & ntp.control.CTL_PST_AUTHENABLE:
+                            auth = "yes"
+                    else:
+                            auth = "none"
+            elif statval & ntp.control.CTL_PST_REACH:
+                reach = "yes"
+            else:
+                reach = "no"
+            if (statval & ntp.control.CTL_PST_AUTHENABLE) == 0:
+                auth = "none"
+            elif statval & ntp.control.CTL_PST_AUTHENTIC:
+                auth = "ok "
+            else:
+                auth = "bad"
+            if self.pktversion > ntp.magic.NTP_OLDVERSION:
+                seldict = {
+                    ntp.control.CTL_PST_SEL_REJECT: "reject",
+                    ntp.control.CTL_PST_SEL_SANE: "falsetick",
+                    ntp.control.CTL_PST_SEL_CORRECT: "excess",
+                    ntp.control.CTL_PST_SEL_SELCAND: "outlier",
+                    ntp.control.CTL_PST_SEL_SYNCCAND: "candidate",
+                    ntp.control.CTL_PST_SEL_EXCESS: "backup",
+                    ntp.control.CTL_PST_SEL_SYSPEER: "sys.peer",
+                    ntp.control.CTL_PST_SEL_PPS: "pps.peer",
+                    }
+                condition = seldict[statval & 0x7]
+            else:
+                if (statval & 0x3) == OLD_CTL_PST_SEL_REJECT:
+                    if (statval & OLD_CTL_PST_SANE) == 0:
+                        condition = "insane"
+                    elif (statval & OLD_CTL_PST_DISP) == 0:
+                        condition = "hi_disp"
+                    else:
+                        condition = ""
+                elif (statval & 0x3) == OLD_CTL_PST_SEL_SELCAND:
+                        condition = "sel_cand"
+                elif (statval & 0x3) == OLD_CTL_PST_SEL_SYNCCAND:
+                    condition = "sync_cand"
+                elif (statval & 0x3) == OLD_CTL_PST_SEL_SYSPEER:
+                    condition = "sys_peer"
+            event_dict = {
+                ntp.magic.PEVNT_MOBIL: "mobilize",
+                ntp.magic.PEVNT_DEMOBIL: "demobilize",
+                ntp.magic.PEVNT_REACH: "reachable",
+                ntp.magic.PEVNT_UNREACH: "unreachable",
+                ntp.magic.PEVNT_RESTART: "restart",
+                ntp.magic.PEVNT_REPLY: "no_reply",
+                ntp.magic.PEVNT_RATE: "rate_exceeded",
+                ntp.magic.PEVNT_DENY: "access_denied",
+                ntp.magic.PEVNT_ARMED: "leap_armed",
+                ntp.magic.PEVNT_NEWPEER: "sys_peer",
+                ntp.magic.PEVNT_CLOCK: "clock_alarm",
+                }
+            last_event = event_dict.get(ntp.magic.PEER_EVENT|event, "")
+            display = \
+                     "%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2lu" % \
+                     (i + 1, peer.associd,
+                     peer.status, conf, reach, auth,
+                     condition, last_event, event_count)
+            self.say(display + "\n")
+
+    def __dopeers(self, showall, mode):
+        if not self.__dogetassoc():
+            return
+        if self.showhostnames:
+            termwidth = ntp.util.termsize().width
+        else:
+            termwidth = None	# Default width
+        report = ntp.util.PeerSummary(mode,
+                                      self.pktversion,
+                                      self.showhostnames,
+                                      self.wideremote,
+                                      termwidth=termwidth,
+                                      debug=interpreter.debug)
+        try:
+            maxhostlen = 0
+            if len(self.chosts) > 1:
+                maxhostlen = max([len(host) for (host, _af) in self.chosts])
+                self.say("%-*.*s " % \
+                                 (maxhostlen, maxhostlen+1, "server"))
+            self.say(report.header() + "\n")
+            if len(self.chosts) > 1:
+                maxhostlen = max([len(host) for (host, _af) in self.chosts])
+                self.say("=" * (maxhostlen + 1))
+            self.say(("=" * report.width()) + "\n")
+            for peer in self.peers:
+                if not showall and \
+                        not (ntp.control.CTL_PEER_STATVAL(peer.status)
+                          & (ntp.control.CTL_PST_CONFIG|ntp.control.CTL_PST_REACH)):
+                    if self.debug:
+                        self.warn("eliding [%d]\n" % peer.associd)
+                    continue
+                try:
+                    variables = self.session.readvar(peer.associd)
+                except ntp.packet.ControlException as e:
+                    self.warn(e.message + "\n")
+                    return
+                except IOError as e:
+                    print(e.strerror)
+                    return
+                if not variables:
+                    if len(self.chosts) > 1:
+                        self.warn("server=%s " % self.session.hostname)
+                    self.warn("***No information returned for association %d\n" \
+                                     % associd)
+                    continue
+                if len(self.chosts) > 1:
+                    self.say(ntp.util.PeerSummary.high_truncate(self.session.hostname, maxhostlen)+ " ")
+                self.say(report.summary(self.session.rstatus,
+                                        variables, peer.associd))
+        except KeyboardInterrupt:
+            pass
+
+    def __assoc_valid(self, line, required=False):
+        "Process a numeric associd or index."
+        if not line:
+            if required:
+                self.warn("An associd argument is required.\n")
+                return -1
+            else:
+                return 0
+        if not self.peers:
+            self.__dogetassoc()
+        if line.startswith("&"):
+            try:
+                idx = int(line[1:].split()[0])
+            except:
+                self.warn("Invalid index literal.\n")
+                return -1
+            if idx < 0 or idx >= 2**16-1:
+                self.warn("%d is not a valid association number.\n" % idx)
+                return -1
+            elif idx not in range(1, len(self.peers)+1):
+                self.warn("No such association as %d.\n" % idx)
+                return -1
+            else:
+                return self.peers[idx - 1].associd
+        else:
+            try:
+                associd = int(line.split()[0])
+            except:
+                self.warn("Invalid associd literal.\n")
+                return -1
+            if associd != 0 and associd not in [peer.associd for peer in self.peers]:
+                self.warn("Unknown associd.\n")
+                return -1
+            else:
+                return associd
+
+    def __assoc_range_valid(self, line):
+        "Try to get a range of assoc IDs."
+        tokens = line.split()
+        if len(tokens) < 2:
+            return ()
+        lo = self.__assoc_valid(tokens[0])
+        hi = self.__assoc_valid(tokens[1])
+        if lo < 0 or hi < 0 or hi < lo: 
+            return ()
+        if lo == hi:
+            return(lo,)
+        return range(lo, hi+1)
+
+    def printvars(self, variables, dtype, quiet):
+        "Dump variables in raw (actually, semi-cooked) mode."
+        if self.rawmode:
+            if not quiet:
+                self.say("status=0x%04x,\n" % self.session.rstatus)
+            # C ntpq not only suppressed \r but tried to visibilize
+            # high-half characters.  We won't do that unless somebody
+            # files a bug, Mode 6 never seems to generate those in
+            # variable fetches.
+            text = polystr(session.response.replace(polybytes(",\r\n"), polybytes(",\n")))
+        else:
+            if not quiet:
+                self.say("status=%04x %s,\n" % \
+                         (self.session.rstatus,
+                          ntp.ntpc.statustoa(dtype, self.session.rstatus)))
+
+            text = ""
+            for (name, value) in variables.items():
+                item = "%s=" % name
+                if name in ("reftime", "clock", "org", "rec", "xmt"):
+                    item += ntp.ntpc.prettydate(value)
+                elif name in ("srcadr", "peeradr", "dstadr", "refid"):
+                    # C ntpq cooked these in obscure ways.  Since they
+                    # came up from the daemon as human-readable
+                    # strings this was probably a bad idea, but we'll
+                    # leave this case separated in case somebody thinks
+                    # re-cooking them is a good idea.
+                    item += value
+                elif name == "leap":
+                    item += ("00", "01", "10", "11")[value]
+                elif name == "reach":
+                    item += "%03lo" % value
+                elif name in("filtdelay", "filtoffset", "filtdisp", "filterror"):
+                    item += "\t".join(value.split())
+                elif name == "flash":
+                    item += "%02x" % value
+                    if value == 0:
+                        item += " ok"
+                    else:
+                        # flasher bits
+                        tstflagnames = (
+                            "pkt_dup",		# BOGON1
+                            "pkt_bogus",	# BOGON2
+                            "pkt_unsync",	# BOGON3
+                            "pkt_denied",	# BOGON4
+                            "pkt_auth",		# BOGON5
+                            "pkt_stratum",	# BOGON6
+                            "pkt_header",	# BOGON7
+                            "pkt_autokey",	# BOGON8
+                            "pkt_crypto",	# BOGON9
+                            "peer_stratum",	# BOGON10
+                            "peer_dist",	# BOGON11
+                            "peer_loop",	# BOGON12
+                            "peer_unreach"	# BOGON13
+                        )
+                        for (i, n) in enumerate(tstflagnames):
+                            if (1 << i) & value:
+                                item += tstflagnames[i] + " "
+                        item = item[:-1]
+                else:
+                    item += repr(value)
+                item += ", "
+                lastcount = 0
+                for c in text:
+                    if c == '\n':
+                        lastcount = 0
+                    else:
+                        lastcount += 1
+                if lastcount + len(item) > ntp.util.termsize().width - 2:
+                    text = text[:-1] + "\n"
+                text += item
+            text = text[:-2] + "\n"
+        text = text.replace("'", '"')
+        self.say(text)
+
+    def __dolist(self, varlist, associd, op, type, quiet=False):
+        "List variables associated with a specified peer."
+        try:
+            variables = self.session.readvar(associd, varlist, op)
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return False
+        except IOError as e:
+            print(e.strerror)
+            return False
+        if len(self.chosts) > 1:
+            self.say("server=%s " % self.session.hostname)
+        if not variables:
+            if associd == 0:
+                self.say("No system%s variables returned\n"%
+                                " clock" if (type == ntp.ntpc.TYPE_CLOCK) else "")
+            else:
+                self.say("No information returned for%s association %d\n"%
+                                (" clock" if (type == ntp.ntpc.TYPE_CLOCK) else "",
+                                associd))
+            return True
+        if not quiet:
+            self.say("associd=%d " % associd)
+        self.printvars(variables, type, not (not varlist))
+        return True
+
+    # Unexposed helper tables and functions end here
+
+    def do_EOF(self, _unused):
+        "exit ntpq"
+        self.say("\n")
+        self.session.close()
+        raise SystemExit(0)
+
+    def do_timeout(self, line):
+        "set the primary receive time out"
+        if line:
+            try:
+                self.session.primary_timeout = int(line)
+            except ValueError:
+                print("What?")
+        print("primary timeout %d ms" % self.session.primary_timeout)
+
+    def help_timeout(self):
+        self.say("""\
+function: set the primary receive time out
+usage: timeout [ msec ]
+""")
+
+    def collect_display(self, associd, variables, decodestatus):
+        "Query and display a collection of variables from the system."
+        try:
+            queried = self.session.readvar(associd, [v[0] for v in variables])
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return
+        except IOError as e:
+            print(e.strerror)
+            return
+        if self.rawmode:
+            self.say(self.session.response)
+            return
+        if decodestatus:
+            if associd == 0:
+                statype = ntp.ntpc.TYPE_SYS
+            else:
+                statype = ntp.ntpc.TYPE_PEER
+            self.say("associd=%u status=%04x %s,\n" %
+                             (associd,
+                              self.session.rstatus,
+                              ntp.ntpc.statustoa(statype, self.session.rstatus)))
+        try:
+            for (name, legend, fmt) in variables:
+                if name not in queried:
+                    continue
+                value = queried[name]
+                if fmt in (NTP_ADD, NTP_ADP):
+                    if self.showhostnames:
+                        if self.debug:
+                            self.say("DNS lookup begins...")
+                        value = ntp.util.canonicalize_dns(value,
+                                                          family=self.ai_family)
+                        if self.debug:
+                            self.say("DNS lookup complete.")
+                    self.say("%s  %s\n" % (legend, value))
+                elif fmt == NTP_STR:
+                    if value:
+                        self.say("%s  %s\n" % (legend, value))
+                elif fmt in (NTP_UINT, NTP_INT, NTP_FLOAT):
+                    self.say("%s  %s\n" % (legend, value))
+                elif fmt == NTP_LFP:
+                    self.say("%s  %s\n" % (legend, ntp.ntpc.prettydate(value)))
+                elif fmt == NTP_2BIT:
+                    self.say("%s  %s\n" % (legend, ("00", "01", "10", "11")[value]))
+                elif fmt == NTP_MODE:
+                    modes = (
+                        "unspec", "sym_active", "sym_passive", "client", "server",
+                        "broadcast", "control", "private", "bclient"
+                    )
+                    try:
+                        self.say("%s  %s\n" % (legend, modes[value]))
+                    except IndexError:
+                        self.say("%s  %s%d\n" % (legend, "mode#", value))
+                else:
+                    self.warn("unexpected vc type %s for %s, value %s\n" % (fmt, name, value))
+        except KeyboardInterrupt:
+            self.warn("display interrupted\n")
+
+    def do_delay(self, line):
+        "set the delay added to encryption time stamps"
+        if not line:
+            self.say("delay %d ms\n" % self.auth_delay)
+        else:
+            try:
+                self.auth_delay = int(line)
+                if self.auth_delay < 0:
+                    raise ValueError
+            except ValueError:
+                self.say("Huh?")
+
+    def help_delay(self):
+        self.say("""\
+function: set the delay added to encryption time stamps
+usage: delay [ msec ]
+""")
+
+    def do_host(self, line):
+        "specify the host whose NTP server we talk to"
+        if not line:
+            if self.session.havehost():
+                print("current host is %s" % self.session.hostname)
+            else:
+                print("no current host")
+        else:
+            tokens = line.split()
+            if tokens[0] == '-4':
+                session.ai_family = socket.AF_INET
+                tokens.pop(0)
+            elif tokens[0] == '-6':
+                session.ai_family = socket.AF_INET6
+                tokens.pop(0)
+            try:
+                if tokens and self.session.openhost(tokens[0], session.ai_family):
+                    print("current host set to %s" % self.session.hostname)
+                elif self.session.havehost():
+                    print("current host remains %s" % self.session.hostname)
+                else:
+                    print("still no current host")
+            except KeyboardInterrupt:
+                print("lookup interrupted")
+
+    def help_host(self):
+        self.say("""\
+function: specify the host whose NTP server we talk to
+usage: host [ -4|-6 ] [ hostname ]
+""")
+
+    def do_poll(self, line):
+        "poll an NTP server in client mode `n' times"
+        # And it's not in the C version, so we're off the hook here
+        print("poll not implemented yet")
+
+    def help_poll(self):
+        self.say("""\
+function: poll an NTP server in client mode `n' times
+usage: poll [ n ] [ verbose ]
+""")
+
+    def do_passwd(self, line):
+        "specify a password to use for authenticated requests"
+        try:
+            self.session.password()
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+
+    def help_passwd(self):
+        self.say("""\
+function: specify a password to use for authenticated requests
+usage: passwd [  ]
+""")
+
+    def do_hostnames(self, line):
+        "specify whether hostnames or net numbers are printed"
+        if not line:
+            pass
+        elif line == "yes":
+            self.showhostnames = True
+        elif line == "no":
+            self.showhostnames = False
+        else:
+            print("What?")
+        if self.showhostnames:
+            print("hostnames being shown")
+        else:
+            print("hostnames not being shown")
+
+    def help_hostnames(self):
+        self.say("""\
+function: specify whether hostnames or net numbers are printed
+usage: hostnames [ yes|no ]
+""")
+
+    def do_debug(self, line):
+        "set/change debugging level"
+        if not line:
+            pass
+        elif line == "more":
+            self.debug +=1
+        elif line == "less":
+            self.debug -= 1
+        elif line == "no":
+            self.debug = 0
+        else:
+            try:
+                self.debug = int(line)	# C version didn't implement this
+            except ValueError:
+                print("What?")
+        self.session.debug = self.debug
+        print("debug level is %d" % self.debug)
+
+    def help_debug(self):
+        self.say("""\
+function: set/change debugging level
+usage: debug [ no|more|less|n ]
+""")
+
+    def do_exit(self, line):
+        "exit ntpq"
+        self.session.close()
+        raise SystemExit(0)
+
+    def help_exit(self):
+        self.say("""\
+function: exit ntpq
+usage: exit
+""")
+    do_quit = do_exit
+
+    def help_quit(self):
+        self.say("""\
+function: exit ntpq
+usage: quit
+""")
+
+    def do_keyid(self, line):
+        "set keyid to use for authenticated requests"
+        if line:
+            try:
+                self.session.keyid = int(line)
+            except ValueError:
+                print("What?")
+        if self.session.keyid is None:
+            print("no keyid defined")
+        else:
+            print("keyid is %d" % self.session.keyid)
+
+    def help_keyid(self):
+        self.say("""\
+function: set keyid to use for authenticated requests
+usage: keyid [ key# ]
+""")
+
+    def do_version(self, line):
+        "print version number"
+        print(version)
+
+    def help_version(self):
+        self.say("""\
+function: print version number
+usage: version
+""")
+
+    def do_raw(self, line):
+        "do raw mode variable output"
+        self.rawmode = True
+        print("Output set to raw")
+
+    def help_raw(self):
+        self.say("""\
+function: do raw mode variable output
+usage: raw
+""")
+
+    def do_cooked(self, line):
+        "do cooked mode variable output"
+        self.rawmode = False
+        print("Output set to cooked")
+
+    def help_cooked(self):
+        self.say("""\
+function: do cooked mode variable output
+usage: cooked
+""")
+
+    def do_authenticate(self, line):
+        "always authenticate requests to this server"
+        if not line:
+            pass
+        elif line == "yes":
+            self.session.always_auth = True
+        elif line == "no":
+            self.session.always_auth = False
+        else:
+            print("What?")
+        if self.session.always_auth:
+            print("authenticated requests being sent")
+        else:
+            print("unauthenticated requests being sent")
+
+    def help_authenticate(self):
+        self.say("""\
+function: always authenticate requests to this server
+usage: authenticate [ yes|no ]
+""")
+
+    def do_ntpversion(self, line):
+        "set the NTP version number to use for requests"
+        if not line:
+            pass
+        else:
+            try:
+                newversion = int(line)
+                if newversion >= ntp.magic.NTP_OLDVERSION and newversion <= ntp.magic.NTP_VERSION:
+                    self.pktversion = newversion
+                else:
+                    print("versions %d to %d, please"
+                          % (ntp.magic.NTP_OLDVERSION, ntp.magic.NTP_VERSION))
+            except ValueError:
+                print("What?")
+        print("NTP version being claimed is %d" % self.pktversion)
+
+    def help_ntpversion(self):
+        self.say("""\
+function: set the NTP version number to use for requests
+usage: ntpversion [ version number ]
+""")
+
+    def do_keytype(self, line):
+        "set key type to use for authenticated requests"
+        if not line:
+            self.say("Keytype: %s\n" % self.session.keytype)
+        elif not line in "DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1":
+            self.warn("Keytype %s is not supported by ntpd.\n" % line)
+        elif line not in hashlib.algorithms_available:
+            self.warn("Keytype %s is not supported by ntpq.\n" % line)
+        else:
+            self.session.keytype = line
+
+    def help_keytype(self):
+        self.say("""\
+function: set key type to use for authenticated requests, one of:
+    DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1
+usage: keytype [ digest-name ]
+""")
+
+    def do_associations(self, line):
+        "print list of association IDs and statuses for the server's peers"
+        if self.__dogetassoc():
+            self.__printassoc(showall=False)
+
+    def help_associations(self):
+        self.say("""\
+function: print list of association IDs and statuses for the server's peers
+usage: associations
+""")
+
+    def do_passociations(self, line):
+        "print list of associations returned by last associations command"
+        self.__printassoc(showall=False)
+
+    def help_passociations(self):
+        self.say("""\
+function: print list of associations returned by last associations command
+usage: passociations
+""")
+
+    def do_lassociations(self, line):
+        "print list of associations including all client information"
+        if self.__dogetassoc():
+            self.__printassoc(showall=True)
+
+    def help_lassociations(self):
+        self.say("""\
+function: print list of associations including all client information
+usage: lassociations
+""")
+
+    def do_lpassociations(self, line):
+        "print last obtained list of associations, including client information"
+        self.__printassoc(showall=True)
+
+    def help_lpassociations(self):
+        self.say("""\
+function: print last obtained list of associations, including client information
+usage: lpassociations
+""")
+
+    def do_addvars(self, line):
+        "add variables to the variable list or change their values"
+        if not line:
+            self.warn("usage: addvars name[=value][,...]\n")
+            return
+        vars_to_add = line.split(',')
+        for add_var in vars_to_add:
+            try:
+                (name, val) = add_var.split("=")
+            except ValueError:
+                (name, val) = (add_var, "")
+            self.uservars[name.strip()] = val.strip()
+
+    def help_addvars(self):
+        self.say("""\
+function: add variables to the variable list or change their values
+usage: addvars name[=value][,...]
+""")
+
+    def do_rmvars(self, line):
+        "remove variables from the variable list"
+        if not line:
+            self.warn("usage: rmvars name[,...]\n")
+            return
+        vars_to_rm = line.split(',')
+        for rm_var in vars_to_rm:
+            if rm_var not in self.uservars:
+                print("%s is not in the variable list" % rm_var)
+            else:
+                del self.uservars[rm_var]
+
+    def help_rmvars(self):
+        self.say("""\
+function: remove variables from the variable list
+usage: rmvars name[,...]
+""")
+
+    def do_clearvars(self, line):
+        "remove all variables from the variable list"
+        self.uservars.clear()
+
+    def help_clearvars(self):
+        self.say("""\
+function: remove all variables from the variable list
+usage: clearvars
+""")
+
+    def do_showvars(self, line):
+        "print variables on the variable list"
+        if len(self.uservars) == 0:
+            print("No variables on list.")
+        for (name, value) in self.uservars.items():
+            if value:
+                print("%s=%s" % (name, value))
+            else:
+                print(name)
+
+    def help_showvars(self):
+        self.say("""\
+function: print variables on the variable list
+usage: showvars
+""")
+
+    def do_readlist(self, line):
+        "read the system or peer variables included in the variable list"
+        associd = self.__assoc_valid(line)
+        if associd >= 0:
+            qtype = ntp.ntpc.TYPE_SYS if associd == 0 else ntp.ntpc.TYPE_PEER
+            self.__dolist(self.uservars.keys(), associd, ntp.control.CTL_OP_READVAR, qtype)
+
+    def help_readlist(self):
+        self.say("""\
+function: read the system or peer variables included in the variable list
+usage: readlist [ assocID ]
+""")
+
+    def do_rl(self, line):
+        "read the system or peer variables included in the variable list"
+        self.do_readlist(line)
+
+    def help_rl(self):
+        self.say("""\
+function: read the system or peer variables included in the variable list
+usage: rl [ assocID ]
+""")
+
+    def do_writelist(self, line):
+        "write the system or peer variables included in the variable list"
+        pass
+
+    def help_writelist(self):
+        self.say("""\
+function: write the system or peer variables included in the variable list
+usage: writelist [ assocID ]
+""")
+
+    def do_readvar(self, line):
+        "read system or peer variables"
+        associd = self.__assoc_valid(line)
+        if associd >= 0:
+            qtype = ntp.ntpc.TYPE_SYS if associd == 0 else ntp.ntpc.TYPE_PEER
+            self.__dolist(line.split()[1:], associd, ntp.control.CTL_OP_READVAR, qtype, quiet=True)
+
+    def help_readvar(self):
+        self.say("""\
+function: read system or peer variables
+usage: readvar [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
+""")
+
+    def do_rv(self, line):
+        "read system or peer variables"
+        self.do_readvar(line)
+
+    def help_rv(self):
+        self.say("""\
+function: read system or peer variables
+usage: rv [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
+""")
+
+    def do_writevar(self, line):
+        "write system or peer variables"
+        pass
+
+    def help_writevar(self):
+        self.say("""\
+function: write system or peer variables
+usage: writevar assocID name=value,[...]
+""")
+
+    def do_mreadlist(self, line):
+        "read the peer variables in the variable list for multiple peers"
+        if not line:
+                self.warn("usage: mreadlist assocIDlow assocIDhigh\n")
+                return
+        idrange = self.__assoc_range_valid(line)
+        if not idrange:
+            return
+        varlist = line.split()[2:]
+        for associd in idrange:
+            if (associd != idrange[0]):
+                self.say("\n")
+            if not self.__dolist(self.uservars,
+                                associd, ntp.control.CTL_OP_READVAR, ntp.ntpc.TYPE_PEER):
+                return
+
+    def help_mreadlist(self):
+        self.say("""\
+function: read the peer variables in the variable list for multiple peers
+usage: mreadlist assocIDlow assocIDhigh
+""")
+
+    def do_mrl(self, line):
+        "read the peer variables in the variable list for multiple peers"
+        if not line:
+                self.warn("usage: mrl assocIDlow assocIDhigh\n")
+                return
+        self.do_mreadlist(line)
+
+    def help_mrl(self):
+        self.say("""\
+function: read the peer variables in the variable list for multiple peers
+usage: mrl assocIDlow assocIDhigh
+""")
+
+    def do_mreadvar(self, line):
+        "read peer variables from multiple peers"
+        if not line:
+                self.warn("usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]\n")
+                return
+        idrange = self.__assoc_range_valid(line)
+        if not idrange:
+            return
+        varlist = line.split()[2:]
+        for associd in idrange:
+            if (associd != idrange[0]):
+                self.say("\n")
+            if not self.__dolist(varlist, associd, ntp.control.CTL_OP_READVAR, ntp.ntpc.TYPE_PEER):
+                return
+
+    def help_mreadvar(self):
+        self.say("""\
+function: read peer variables from multiple peers
+usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]
+""")
+
+    def do_mrv(self, line):
+        "read peer variables from multiple peers"
+        if not line:
+                self.warn("usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]\n")
+                return
+        self.do_mreadvar(line)
+
+    def help_mrv(self):
+        self.say("""\
+function: read peer variables from multiple peers
+usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]
+""")
+
+    def do_clocklist(self, line):
+        "read the clock variables included in the variable list"
+        assoc = self.__assoc_valid(line)
+        if assoc >= 0:
+            self.__dolist(self.uservars.keys(),
+                          assoc, ntp.control.CTL_OP_READCLOCK, ntp.ntpc.TYPE_CLOCK)
+
+    def help_clocklist(self):
+        self.say("""\
+function: read the clock variables included in the variable list
+usage: clocklist [ assocID ]
+""")
+
+    def do_cl(self, line):
+        "read the clock variables included in the variable list"
+        self.do_clocklist(line)
+
+    def help_cl(self):
+        self.say("""\
+function: read the clock variables included in the variable list
+usage: cl [ assocID ]
+""")
+
+    def do_clockvar(self, line):
+        "read clock variables"
+        assoc = self.__assoc_valid(line)
+        if assoc == 0:
+            self.warn("This command requires the association ID of a clock.\n")
+        elif assoc > 0:
+            self.__dolist(line.split()[1:], assoc, ntp.control.CTL_OP_READCLOCK, ntp.ntpc.TYPE_CLOCK)
+
+    def help_clockvar(self):
+        self.say("""\
+function: read clock variables
+usage: clockvar [ assocID ] [ name=value[,...] ]
+""")
+
+    def do_cv(self, line):
+        "read clock variables"
+        self.do_clockvar(line)
+
+    def help_cv(self):
+        self.say("""\
+function: read clock variables
+usage: cv [ assocID ] [ name=value[,...] ]
+""")
+
+    def do_pstats(self, line):
+        "show statistics for a peer"
+        pstats = (
+            ("srcadr",		"remote host:         ", NTP_ADD),
+            ("dstadr",		"local address:       ", NTP_ADD),
+            ("timerec",		"time last received:  ", NTP_INT),
+            ("timer",		"time until next send:", NTP_INT),
+            ("timereach",	"reachability change: ", NTP_INT),
+            ("sent",		"packets sent:        ", NTP_INT),
+            ("received",	"packets received:    ", NTP_INT),
+            ("badauth",		"bad authentication:  ", NTP_INT),
+            ("bogusorg",	"bogus origin:        ", NTP_INT),
+            ("oldpkt",		"duplicate:           ", NTP_INT),
+            ("seldisp",		"bad dispersion:      ", NTP_INT),
+            ("selbroken",	"bad reference time:  ", NTP_INT),
+            ("candidate",	"candidate order:     ", NTP_INT),
+        )
+        if not line:
+                self.warn("usage: pstats assocID\n")
+                return
+        associd = self.__assoc_valid(line)
+        if associd >= 0:
+            self.collect_display(associd=associd,
+                                 variables=pstats, decodestatus=True)
+
+    def help_pstats(self):
+        self.say("""\
+function: show statistics for a peer
+usage: pstats assocID
+""")
+
+    def do_peers(self, line):
+        "obtain and print a list of the server's peers [IP version]"
+        self.__dopeers(showall=False, mode="peers")
+
+    def help_peers(self):
+        self.say("""\
+function: obtain and print a list of the server's peers [IP version]
+usage: peers
+""")
+
+    def do_apeers(self, line):
+        "obtain and print a list of the server's peers and their assocIDs [IP version]"
+        self.__dopeers(showall=False, mode="apeers")
+
+    def help_apeers(self):
+        self.say("""\
+function: obtain and print a list of the server's peers and their assocIDs [IP version]
+usage: apeers
+""")
+
+    def do_lpeers(self, line):
+        "obtain and print a list of all peers and clients [IP version]"
+        self.__dopeers(showall=True, mode="peers")
+
+    def help_lpeers(self):
+        self.say("""\
+function: obtain and print a list of all peers and clients [IP version]
+usage: lpeers
+""")
+
+    def do_opeers(self, line):
+        "print peer list the old way, with dstadr shown rather than refid [IP version]"
+        self.__dopeers(showall=False, mode="opeers")
+
+    def help_opeers(self):
+        self.say("""\
+function: print peer list the old way, with dstadr shown rather than refid [IP version]
+usage: opeers
+""")
+
+    def do_lopeers(self, line):
+        "obtain and print a list of all peers and clients showing dstadr [IP version]"
+        self.__dopeers(showall=True, mode="opeers")
+
+    def help_lopeers(self):
+        self.say("""\
+function: obtain and print a list of all peers and clients showing dstadr [IP version]
+usage: lopeers
+""")
+
+    def do_config(self, line):
+        "send a remote configuration command to ntpd"
+        try:
+            self.session.password()
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return
+        if self.debug > 2:
+            self.warn("In Config\nKeyword = :config\nCommand = %s\n" % line)
+        try:
+            self.session.config(line)
+            m = re.match("column ([0-9]+) syntax error", self.session.response)
+            if m:
+                col = int(m.group(1))
+                if col >= 0 and col <= len(line):
+                    if self.interactive:
+                        self.say("_" * (len(self.prompt) + 2 + col))
+                    else:
+                        self.say(line + "\n")
+                    self.say("_" * (col- 1))
+                self.say("^\n")
+            self.say(self.session.response + "\n")
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+
+    def help_config(self):
+        self.say("""\
+function: send a remote configuration command to ntpd
+usage: config <configuration command line>
+""")
+
+    def do_config_from_file(self, line):
+        "configure ntpd using the configuration filename"
+        try:
+            with open(line) as rfp:
+                self.say(self.session.config(rfp.read()))
+        except IOError:
+            self.warn("Could not read %s\n" % line)
+
+    def help_config_from_file(self):
+        self.say("""\
+function: configure ntpd using the configuration filename
+usage: config_from_file <configuration filename>
+""")
+
+    def do_mrulist(self, line):
+        "display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
+        cmdvars = {}
+        for item in line.split(" "):
+            if not item:
+                continue
+            if '=' not in item:
+                cmdvars[item] = True
+            else:
+                eq = item.index("=")
+                var = item[:eq].strip()
+                val = item[eq+1:].strip()
+                try:
+                    val = int(val, 0)
+                except ValueError:
+                    try:
+                        val = float(val)
+                    except ValueError:
+                        if val[0] == '"' and val[-1] == '"':
+                            val = val[1:-1]
+                cmdvars[var] = val
+
+        self.say("Ctrl-C will stop MRU retrieval and display partial results.\n")
+        if self.rawmode:
+            mruhook = lambda v: self.printvars(variables=v,
+                                               dtype=ntp.ntpc.TYPE_SYS,
+                                               quiet=True)
+        else:
+            mruhook = None
+        try:
+            span = self.session.mrulist(variables=cmdvars, rawhook=mruhook)
+            if not self.rawmode:
+                if not span.is_complete():
+                    self.say("mrulist retrieval interrupted by operator.\n"
+                             "Displaying partial client list.\n")
+                try:
+                    formatter = ntp.util.MRUSummary(interpreter.showhostnames)
+                    self.say(ntp.util.MRUSummary.header + "\n")
+                    self.say(("=" * ntp.util.MRUSummary.width) + "\n")
+                    # reversed to put most recent entries at the top.
+                    for entry in reversed(span.entries):
+                        self.say(formatter.summary(entry) + "\n")
+                except KeyboardInterrupt:
+                    pass
+        except ntp.packet.ControlException as e:
+            # Giving up after 8 restarts from the beginning.
+            # With high-traffic NTP servers, this can occur if the
+            # MRU list is limited to less than about 16 seconds' of
+            # entries.  See the 'mru' ntp.conf entry.
+            self.warn(e.message + "\n")
+
+    def help_mrulist(self):
+        self.say("""\
+function: display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x...
+usage: mrulist [ tag=value ] [ tag=value ] [ tag=value ] [ tag=value ]
+""")
+
+    def do_ifstats(self, line):
+        "show statistics for each local address ntpd is using"
+        try:
+            self.session.password()
+            entries = self.session.ifstats()
+            if self.rawmode:
+                print(self.session.response)
+            else:
+                formatter = ntp.util.IfstatsSummary()
+                self.say(ntp.util.IfstatsSummary.header)
+                self.say(("=" * ntp.util.IfstatsSummary.width) + "\n")
+                for (i, entry) in enumerate(entries):
+                    self.say(formatter.summary(i, entry))
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return
+        pass
+
+    def help_ifstats(self):
+        self.say("""\
+function: show statistics for each local address ntpd is using
+usage: ifstats
+""")
+
+    def do_reslist(self, line):
+        "show ntpd access control list"
+        try:
+            self.session.password()
+            entries = self.session.reslist()
+            if self.rawmode:
+                print(self.session.response)
+            else:
+                formatter = ntp.util.ReslistSummary()
+                self.say(ntp.util.ReslistSummary.header)
+                self.say(("=" * ntp.util.ReslistSummary.width) + "\n")
+                for entry in entries:
+                    self.say(formatter.summary(entry))
+        except ntp.packet.ControlException as e:
+            self.warn(e.message + "\n")
+            return
+
+    def help_reslist(self):
+        self.say("""\
+function: show ntpd access control list
+usage: reslist
+""")
+
+    def do_sysinfo(self, _line):
+        "display system summary"
+        sysinfo = (
+            ("peeradr",		"system peer:      ", NTP_ADP),
+            ("peermode",	"system peer mode: ", NTP_MODE),
+            ("leap",		"leap indicator:   ", NTP_2BIT),
+            ("stratum",		"stratum:          ", NTP_INT),
+            ("precision",	"log2 precision:   ", NTP_INT),
+            ("rootdelay",	"root delay:       ", NTP_FLOAT),
+            ("rootdisp",	"root dispersion:  ", NTP_FLOAT),
+            ("refid",		"reference ID:     ", NTP_STR),
+            ("reftime",		"reference time:   ", NTP_LFP),
+            ("sys_jitter",	"system jitter:    ", NTP_FLOAT),
+            ("clk_jitter",	"clock jitter:     ", NTP_FLOAT),
+            ("clk_wander",	"clock wander:     ", NTP_FLOAT),
+            ("bcastdelay",	"broadcast delay:  ", NTP_FLOAT),
+            ("authdelay",	"symm. auth. delay:", NTP_FLOAT),
+        )
+        self.collect_display(associd=0, variables=sysinfo, decodestatus=True)
+
+    def help_sysinfo(self):
+        self.say("""\
+function: display system summary
+usage: sysinfo
+""")
+
+    def do_kerninfo(self, _line):
+        "display kernel loop and PPS statistics"
+        kerninfo = (
+            ("koffset",		"pll offset:          ", NTP_FLOAT),
+            ("kfreq",		"pll frequency:       ", NTP_FLOAT),
+            ("kmaxerr",		"maximum error:       ", NTP_FLOAT),
+            ("kesterr",		"estimated error:     ", NTP_FLOAT),
+            ("kstflags",	"kernel status:       ", NTP_STR),
+            ("ktimeconst",	"pll time constant:   ", NTP_INT),
+            ("kprecis",		"precision:           ", NTP_FLOAT),
+            ("kfreqtol",	"frequency tolerance: ", NTP_INT),
+            ("kppsfreq",	"pps frequency:       ", NTP_INT),
+            ("kppsstab",	"pps stability:       ", NTP_INT),
+            ("kppsjitter",	"pps jitter:          ", NTP_INT),
+            ("kppscalibdur",	"calibration interval ", NTP_INT),
+            ("kppscalibs",	"calibration cycles:  ", NTP_INT),
+            ("kppsjitexc",	"jitter exceeded:     ", NTP_INT),
+            ("kppsstbexc",	"stability exceeded:  ", NTP_INT),
+            ("kppscaliberrs",	"calibration errors:  ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=kerninfo, decodestatus=True)
+
+    def help_kerninfo(self):
+        self.say("""\
+function: display kernel loop and PPS statistics
+usage: kerninfo
+""")
+
+    def do_sysstats(self, _line):
+        "display system uptime and packet counts"
+        sysstats = (
+            ("ss_uptime",	"uptime:               ", NTP_INT),
+            ("ss_reset",	"sysstats reset:       ", NTP_INT),
+            ("ss_received",	"packets received:     ", NTP_INT),
+            ("ss_thisver",	"current version:      ", NTP_INT),
+            ("ss_oldver",	"older version:        ", NTP_INT),
+            ("ss_badformat",	"bad length or format: ", NTP_INT),
+            ("ss_badauth",	"authentication failed:", NTP_INT),
+            ("ss_declined",	"declined:             ", NTP_INT),
+            ("ss_restricted",	"restricted:           ", NTP_INT),
+            ("ss_limited",	"rate limited:         ", NTP_INT),
+            ("ss_kodsent",	"KoD responses:        ", NTP_INT),
+            ("ss_processed",	"processed for time:   ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=sysstats, decodestatus=False)
+
+    def help_sysstats(self):
+        self.say("""\
+function: display system uptime and packet counts
+usage: sysstats
+""")
+
+    def do_monstats(self, _line):
+        "display monitor (mrulist) counters and limits"
+        monstats = (
+            ("mru_enabled",	"enabled:            ", NTP_INT),
+            ("mru_depth",	"addresses:          ", NTP_INT),
+            ("mru_deepest",	"peak addresses:     ", NTP_INT),
+            ("mru_maxdepth",	"maximum addresses:  ", NTP_INT),
+            ("mru_mindepth",	"reclaim above count:", NTP_INT),
+            ("mru_maxage",	"reclaim older than: ", NTP_INT),
+            ("mru_mem",		"kilobytes:          ", NTP_INT),
+            ("mru_maxmem",	"maximum kilobytes:  ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=monstats, decodestatus=False)
+
+    def help_monstats(self):
+        self.say("""\
+function: display monitor (mrulist) counters and limits
+usage: monstats
+""")
+
+    def do_authinfo(self, _line):
+        "display symmetric authentication counters"
+        authinfo = (
+            ("authreset",	"time since reset:", NTP_INT),
+            ("authkeys",	"stored keys:     ", NTP_INT),
+            ("authfreek",	"free keys:       ", NTP_INT),
+            ("authklookups",	"key lookups:     ", NTP_INT),
+            ("authknotfound",	"keys not found:  ", NTP_INT),
+            ("authkuncached",	"uncached keys:   ", NTP_INT),
+            ("authkexpired",	"expired keys:    ", NTP_INT),
+            ("authencrypts",	"encryptions:     ", NTP_INT),
+            ("authdecrypts",	"decryptions:     ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=authinfo, decodestatus=False)
+
+    def help_authinfo(self):
+        self.say("""\
+function: display symmetric authentication counters
+usage: authinfo
+""")
+
+    def do_iostats(self, _line):
+        "display network input and output counters"
+        iostats = (
+            ("iostats_reset",	"time since reset:     ", NTP_INT),
+            ("total_rbuf",	"receive buffers:      ", NTP_INT),
+            ("free_rbuf",	"free receive buffers: ", NTP_INT),
+            ("used_rbuf",	"used receive buffers: ", NTP_INT),
+            ("rbuf_lowater",	"low water refills:    ", NTP_INT),
+            ("io_dropped",	"dropped packets:      ", NTP_INT),
+            ("io_ignored",	"ignored packets:      ", NTP_INT),
+            ("io_received",	"received packets:     ", NTP_INT),
+            ("io_sent",		"packets sent:         ", NTP_INT),
+            ("io_sendfailed",	"packet send failures: ", NTP_INT),
+            ("io_wakeups",	"input wakeups:        ", NTP_INT),
+            ("io_goodwakeups",	"useful input wakeups: ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=iostats, decodestatus=False)
+
+    def help_iostats(self):
+        self.say("""\
+function: display network input and output counters
+usage: iostats
+""")
+
+    def do_timerstats(self, line):
+        "display interval timer counters"
+        timerstats = (
+            ("timerstats_reset",	"time since reset:  ", NTP_INT),
+            ("timer_overruns",		"timer overruns:    ", NTP_INT),
+            ("timer_xmts",		"calls to transmit: ", NTP_INT),
+        )
+        self.collect_display(associd=0, variables=timerstats, decodestatus=False)
+
+    def help_timerstats(self):
+        self.say("""\
+function: display interval timer counters
+usage: timerstats
+""")
+
+# Default values we use.
+DEFHOST 	= "localhost"	# default host name
+
+#
+# main - parse arguments and handle options
+#
+
+usage = '''
+USAGE: ntpq [-46dphinOV] [-c str] [-D lvl] [ host ...]
+  Flg Arg Option-Name    Description
+   -4 no  ipv4           Force IPv4 DNS name resolution
+                                - prohibits the option 'ipv6'
+   -6 no  ipv6           Force IPv6 DNS name resolution
+                                - prohibits the option 'ipv4'
+   -c Str command        run a command and exit
+                                - may appear multiple times
+   -d no  debug-level    Increase output debug message level
+                                - may appear multiple times
+   -D Int set-debug-level Set the output debug message level
+                                - may appear multiple times
+   -h no  help           Print a usage message.
+   -p no  peers          Print a list of the peers
+                                - prohibits the option 'interactive'
+   -i no  interactive    Force ntpq to operate in interactive mode
+                                - prohibits these options:
+                                command
+                                peers
+   -n no  numeric        numeric host addresses
+   -V opt version        Output version information and exit
+   -w no  wide           enable wide display of addresses
+'''
+
+if __name__ == '__main__':
+    ntp.ntpc.setprogname("ntpq")
+    #init_auth()
+
+    try:
+        (options, arguments) = getopt.getopt(sys.argv[1:],
+                                             "46c:dD:hinpVw",
+                                             ["ipv4","ipv6", "command=",
+                                              "debug", "set-debug-level=",
+                                              "help", "interactive", "numeric",
+                                              "peers", "version",
+                                              "wide"])
+    except getopt.GetoptError as e:
+        sys.stderr.write("%s\n" % e)
+        sys.stderr.write(usage)
+        raise SystemExit(1)
+    progname = sys.argv[0]
+
+    session = ntp.packet.ControlSession()
+    interpreter = Ntpq(session)
+
+    for (switch, val) in options:
+        if switch in ("-4", "--ipv4"):
+            interpreter.ai_family = socket.AF_INET
+        elif switch in ("-6", "--ipv6"):
+            interpreter.ai_family = socket.AF_INET6
+        elif switch in ("-c", "--command"):
+            interpreter.ccmds.append(val)
+        elif switch in ("-d", "--debug"):
+            interpreter.debug += 1
+            session.debug += 1
+        elif switch in ("-D", "--set-debug-level"):
+            try:
+                session.debug = interpreter.debug = int(val)
+            except ValueError as e:
+                sys.stderr.write("'%s' is not a recognizable number\n" % val)
+                sys.stderr.write(usage)
+                raise SystemExit(1)
+        elif switch in ("-h", "--help"):
+            print(usage)
+            raise SystemExit(0)
+        elif switch in ("-i", "--interactive"):
+            interpreter.interactive = True
+        elif switch in ("-n", "--numeric"):
+            interpreter.showhostnames = False
+        elif switch in ("-p", "--peers"):
+            interpreter.ccmds.append("peers")
+        elif switch in ("-V", "--version"):
+            print("ntpq %s" % version)
+            raise SystemExit(0)
+        elif switch in ("-w", "--wide"):
+            interpreter.wideremote = True
+
+    if interpreter.interactive and len(interpreter.ccmds) > 0:
+        interpreter.warn("%s: invalid option combination.\n" % progname)
+        raise SystemExit(1)
+
+    if len(arguments) == 0:
+        interpreter.chosts.append((DEFHOST, session.ai_family))
+    else:
+        for token in arguments:
+            if token.startswith("-"):
+                if '4' == token[1]:
+                    session.ai_family = socket.AF_INET
+                elif '6' == token[1]:
+                    session.ai_family = socket.AF_INET6
+            else:
+                interpreter.chosts.append((token, session.ai_family))
+
+    if len(interpreter.ccmds) == 0 and not interpreter.interactive and os.isatty(0) and os.isatty(1):
+        interpreter.interactive = True
+
+    try:
+        if len(interpreter.ccmds) == 0:
+            if len(interpreter.chosts) > 1:
+                interpreter.warn("ntpq can only work interactively on one host.\n")
+                interpreter.chosts = interpreter.chosts[:1]
+            session.openhost(*interpreter.chosts[0])
+            interpreter.cmdloop()
+        else:
+            for ihost in interpreter.chosts:
+                if session.openhost(*ihost):
+                    for command in interpreter.ccmds:
+                        interpreter.onecmd(command)
+                    session.close()
+        raise SystemExit(0)
+    except KeyboardInterrupt:
+        interpreter.say("\n")
+    except ntp.packet.ControlException as e:
+        interpreter.warn(e.message + "\n")
+    except IOError:
+        print("Bailing out...")
+# end
diff --git a/ntpclients/ntpq-man.txt b/ntpclients/ntpq-man.txt
new file mode 100644
index 0000000..77e1a07
--- /dev/null
+++ b/ntpclients/ntpq-man.txt
@@ -0,0 +1,20 @@
+= ntpq(1) =
+:doctype: manpage
+
+== NAME ==
+ntpq - standard NTP query program
+
+include::../docs/includes/ntpq-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+66 (EX_NOINPUT)::
+  A specified configuration file could not be loaded.
+
+// end
diff --git a/ntpclients/ntpsweep b/ntpclients/ntpsweep
new file mode 100755
index 0000000..9a335d1
--- /dev/null
+++ b/ntpclients/ntpsweep
@@ -0,0 +1,181 @@
+#!/usr/bin/env python
+"""
+ntpsweep - Print various information about given ntp servers.
+USAGE: ntpsweep [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [hostfile]
+
+    -l, --host-list=str        Host to execute actions on
+                                   - may appear multiple times
+    -p, --peers                Recursively list all peers a host synchronizes to
+    -m, --maxlevel=num         Traverse peers up to this level (4 is a reasonable number)
+    -s, --strip=str            Strip this string from hostnames
+
+Options are specified by doubled hyphens and their name or by a single
+hyphen and the flag character.
+"""
+# SPDX-License-Identifier: BSD-2-clause
+#
+# Python translation by ESR of a Perl script written long ago by
+# Hans Lambermont <ntpsweep@lambermont.dyndns.org>
+#
+# It is unclear how useful this will be under modern conditions (e.g. most
+# hosts refuse to be queried, and requests to them will just time out).
+
+from __future__ import print_function
+
+import os, sys, getopt
+import ntp.packet, ntp.util
+
+def ntp_peers(host):
+    "Return a list of peer IP addrs for a specified host, empty list if query failed."
+    try:
+        with os.popen("ntpq -npw " + host) as rp:
+            hostlines = rp.readlines()[2:]	# Drop display header
+            # Strip tally mark from first field
+            return [ln.split()[0][1:] for ln in hostlines if ln[0] in " x.-+#*o"]
+    except OSError:
+        return []
+
+def scan_host(host, level):
+    stratum = 0
+    offset = 0
+    daemonversion = ""
+    system = ""
+    processor = ""
+    peers = []
+    known_host = False
+
+    if host in known_host_info:
+        known_host = True
+    else:
+        session = ntp.packet.ControlSession()
+        session.openhost(host)
+        sysvars = session.readvar()
+
+        # got answers ? If so, go on.
+        if isinstance(sysvars, dict):
+            stratum       = sysvars['stratum']
+            offset        = sysvars['offset']
+            daemonversion = sysvars['version']
+            system        = sysvars['system']
+            processor     = sysvars['processor']
+
+            # Shorten daemon_version string.
+            #daemonversion =~ s/(|Mon|Tue|Wed|Thu|Fri|Sat|Sun).*$//
+            daemonversion = daemonversion.replace("version=", "")
+            daemonversion = daemonversion.replace("ntpd ", "")
+            daemonversion = daemonversion.replace("(", "").replace(")", "")
+            daemonversion = daemonversion.replace("beta", "b")
+            daemonversion = daemonversion.replace("multicast", "mc")
+
+            # Shorten system string. Note, the assumptions here
+            # are very old, reflecting ancient big-iron Unixes
+            system = system.replace("UNIX/", "")
+            system = system.replace("RELEASE", "r")
+            system = system.replace("CURRENT", "c")
+
+            # Shorten processor string
+            processor = processor.replace("unknown", "")
+
+        # got answers ? If so, go on.
+        if daemonversion and recurse:
+            # Consider doing something more intelligent on failure
+            # than simply returning an empty list.  Though it might
+            # be the right thing to do under modern conditions in
+            # which most hosts will refuse to be queried.
+            known_host_peers[host] = ntp_peers(host)
+
+        # Collect info on host
+        if stratum:
+            known_host_info[host] = "%2d %9.3f %-11s %-12s %s"  \
+                                    % (stratum, offset, daemonversion[:11],
+                                       system[:12], processor[0:9])
+        else:
+            # Stratum level 0 is considered invalid
+            known_host_info[host] = " ?"
+
+    if stratum or known_host: # Valid or known host
+        printhost = (' ' * level) + (ntp.util.canonicalize_dns(host) or host)
+        # Shorten host string
+        if strip:
+            printhost = printhost.replace(strip, "")
+        # append number of peers in brackets if requested and valid
+        if recurse and known_host_info[host] != " ?" and host in known_host_peers:
+            printhost += " (%d)" % len(known_host_peers[host])
+        # Finally print complete host line
+        print("%-32s %s" % (printhost[:32], known_host_info[host]))
+        if recurse and (maxlevel == 0 or level < maxlevel):
+            trace.append(host)
+            # Loop through peers
+            for peer in known_host_peers[host]:
+                if peer in trace:
+                    # we've detected a loop!
+                    printhost = (' ' * (level + 1)) + "= " + peer
+                    # Shorten host string
+                    if strip:
+                        printhost = printhost.replace(strip, "")
+                    print("%-32s" % printhost[:32])
+                else:
+                    # FIXME: Ugh! Magic-address assumption.
+                    # Needed to deal with peers running legacy NTP.
+                    # Might cause problems in the future.  First
+                    # part of the guard is an attempt to skip
+                    # NTPsec-style clock IDs.
+                    if peer[0].isdigit() and not peer.startswith("127"):
+                        scan_host(peer, level + 1)
+    else: # We did not get answers from this host
+        printhost = (' ' * level) + (ntp.util.canonicalize_dns(host) or host)
+        if strip:
+            printhost = printhost.replace(strip, "")
+        print("%-32s  ?" % printhost[:32])
+
+if __name__ == '__main__':
+    try:
+        (options, arguments) = getopt.getopt(
+            sys.argv[1:], "h:l:m:ps:?",
+            ["host=", "host-list=", "maxlevel=", "peers", "strip="])
+    except getopt.GetoptError as err:
+        sys.stderr.write(str(err) + "\n")
+        raise SystemExit(1)
+    hostlist = []
+    maxlevel = 1
+    recurse = False
+    strip = ""
+    for (switch, val) in options:
+        if switch == "-h" or switch == "--host":
+            hostlist = [val]
+        elif switch == "-l" or switch == "--host-list":
+            hostlist = val.split(",")
+        elif switch == "-m" or switch == "--maxlevel":
+            maxlevel = int(val)
+        elif switch == "-p" or switch == "--peers":
+            recurse = True
+        elif switch == "-s" or switch == "--strip":
+            strip = val
+        elif switch == "-?" or switch == "--help":
+            print(__doc__, file=sys.stderr)
+            raise SystemExit(0)
+
+    if arguments:
+        hostlist += [ln.strip() for ln in open(arguments[0]).readlines()]
+
+    if not hostlist:
+        hostlist = ["localhost"]
+
+    # Print header
+    print("""\
+Host                             st offset(s) version     system       processor
+--------------------------------+--+---------+-----------+------------+---------\
+""")
+
+    known_host_info = {}
+    known_host_peers = {}
+    trace = []
+    for host in hostlist:
+        try:
+            scan_host(host, 0)
+        except ntp.packet.ControlException as e:
+            sys.stderr.write(e.message + "\n")
+            sys.exit(1)
+    sys.exit(0)
+
+# end
diff --git a/ntpclients/ntpsweep-man.txt b/ntpclients/ntpsweep-man.txt
new file mode 100644
index 0000000..9f8dfbc
--- /dev/null
+++ b/ntpclients/ntpsweep-man.txt
@@ -0,0 +1,54 @@
+= ntpsweep(1) =
+:doctype: manpage
+
+== NAME ==
+ntpsweep - print various informations about given NTP servers
+
+== SYNOPSIS ==
++ntpsweep+ [+-l+ 'host']... [-p] [+-m+ 'number'] [+-s+ 'prefix'] [+-h+ 'string']
+
+== DESCRIPTION ==
+
+`ntpsweep` prints per host the NTP stratum level, the clock offset in
+seconds, the daemon version, the operating system and the processor.
+Optionally recursing through all peers.
+
+If no hosts are specified, `ntpsweep` reports on localhost.
+
+`ntpsweep` relies on `ntpq` and Mode 6 queries to probe servers.  This
+depends on the remote host's _restrict_ configuration allowing
+queries. Nowadays effectively all public hosts set _noquery_, so this
+script is unlikely to be useful unless you have multiple specially-
+configured timeservers on a LAN.
+
+== OPTIONS ==
+
++-l+ string, +--host-list+=_string_::
+  Host to execute actions on. This option may appear an unlimited number
+  of times.
++
+Use this option to specify the host on which this script operates. May
+appear multiple times.
+
++-p+, +--peers+::
+  Recursively list all peers a host synchronizes to.
+
++-m+ number, +--maxlevel+=_number_::
+  Traverse peers up to this level (4 is a reasonable number). This
+  option takes an integer number as its argument.
+
++-s+ string, +--strip+=_string_::
+  Strip this string from hostnames.
+
++-h+ string, +--host+=_string_::
+  Specify a single host.  Deprecated option for backwards compatibility.
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+
diff --git a/ntpclients/ntptrace b/ntpclients/ntptrace
new file mode 100755
index 0000000..a365391
--- /dev/null
+++ b/ntpclients/ntptrace
@@ -0,0 +1,162 @@
+#!/usr/bin/env python
+"""
+ntptrace - trace peers of an NTP server
+
+Usage: ntptrace [-n | --numeric] [-m number | --max-hosts=number]
+                [-r hostname | --host=hostname] [--help | --more-help]
+                hostname
+
+See the manual page for details.
+"""
+#SPDX-License-Identifier: BSD-2-Clause
+
+from __future__ import print_function
+
+import getopt
+import re
+import subprocess
+import sys
+import ntp.util
+
+def get_info(host):
+    info = ntp_read_vars(0, [], host)
+    if info is None or 'stratum' not in info:
+        return
+
+    info['offset'] = round(float(info['offset']) / 1000, 6)
+    info['syncdistance'] = \
+        (float(info['rootdisp']) + (float(info['rootdelay']) / 2)) / 1000
+
+    return info
+
+
+def get_next_host(peer, host):
+    info = ntp_read_vars(peer, ["srcadr"], host)
+    if info is None:
+        return
+    return info['srcadr']
+
+
+def ntp_read_vars(peer, vars, host):
+    obsolete = {'phase': 'offset',
+                'rootdispersion': 'rootdisp'}
+
+    if not len(vars):
+        do_all = True
+    else:
+        do_all = False
+    outvars = {}.fromkeys(vars)
+
+    if do_all:
+        outvars['status_line'] = {}
+
+    cmd = ["ntpq", "-n", "-c", "rv %s %s" % (peer, ",".join(vars))]
+    if host is not None:
+        cmd.append(host)
+
+    try:
+        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode('utf-8').splitlines()
+    except subprocess.CalledProcessError as e:
+        print("Could not start ntpq: %s" % e.output, file=sys.stderr)
+        raise SystemExit(1)
+    except OSError as e:
+        print("Could not start ntpq: %s" % e.strerror, file=sys.stderr)
+        raise SystemExit(1)
+
+    for line in output:
+        if re.search(r'Connection refused', line):
+            return
+
+        match = re.search(r'^asso?c?id=0 status=(\S{4}) (\S+), (\S+),', line, flags=re.IGNORECASE)
+        if match:
+            outvars['status_line']['status'] = match.group(1)
+            outvars['status_line']['leap'] = match.group(2)
+            outvars['status_line']['sync'] = match.group(3)
+
+        iterator = re.finditer(r'(\w+)=([^,]+),?\s?', line)
+        for match in iterator:
+            key = match.group(1)
+            val = match.group(2)
+            val = re.sub(r'^"([^"]+)"$', r'\1', val)
+            if key in obsolete:
+                key = obsolete[key]
+            if do_all or key in outvars:
+                outvars[key] = val
+
+    return outvars
+
+
+usage = r"""ntptrace - Trace peers of an NTP server.
+USAGE: ntptrace [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [host]
+
+    -n, --numeric                Print IP addresses instead of hostnames
+    -m, --max-hosts=num          Maximum number of peers to trace
+    -r, --host=str               Single remote host
+    -?, --help                   Display usage information and exit
+        --more-help              Pass the extended usage text through a pager
+
+Options are specified by doubled hyphens and their name or by a single
+hyphen and the flag character."""
+
+try:
+    (options, arguments) = getopt.getopt(
+        sys.argv[1:], "m:nr:?",
+        ["help", "host=", "max-hosts=", "more-help", "numeric"])
+except getopt.GetoptError as err:
+    sys.stderr.write(str(err) + "\n")
+    raise SystemExit(1)
+
+numeric = False
+maxhosts = 99
+host = '127.0.0.1'
+
+for (switch, val) in options:
+    if switch == "-m" or switch == "--max-hosts":
+        maxhosts = int(val)
+    elif switch == "-n" or switch == "--numeric":
+        numeric = True
+    elif switch == "-r" or switch == "--host":
+        host = val
+    elif switch == "-?" or switch == "--help" or switch == "--more-help":
+        print(usage, file=sys.stderr)
+        raise SystemExit(0)
+
+if len(arguments):
+    host = arguments[0]
+
+hostcount = 0
+
+while True:
+    hostcount += 1
+
+    info = get_info(host)
+
+    if info is None:
+        break
+
+    if not numeric:
+        host = ntp.util.canonicalize_dns(host)
+
+    print("%s: stratum %d, offset %f, synch distance %f" %
+          (host, int(info['stratum']), info['offset'], info['syncdistance']), end='')
+    if int(info['stratum']) == 1:
+        print(", refid '%s'" % info['refid'], end='')
+    print()
+
+    if int(info['stratum']) == 0 or int(info['stratum']) == 1 or int(info['stratum']) == 16:
+        break
+
+    if re.search(r'^127\.127\.\d{1,3}\.\d{1,3}$', info['refid']):
+        break
+
+    if hostcount == maxhosts:
+        break
+
+    next_host = get_next_host(info['peer'], host)
+
+    if next_host is None:
+        break
+    if re.search(r'^127\.127\.\d{1,3}\.\d{1,3}$', next_host):
+        break
+
+    host = next_host
diff --git a/ntpclients/ntptrace-man.txt b/ntpclients/ntptrace-man.txt
new file mode 100644
index 0000000..d254b2c
--- /dev/null
+++ b/ntpclients/ntptrace-man.txt
@@ -0,0 +1,16 @@
+= ntptrace(1) =
+:doctype: manpage
+
+== NAME ==
+ntptrace - trace peers of an NTP server
+
+include::../docs/includes/ntptrace-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the invocation was not valid.
diff --git a/ntpclients/ntpviz b/ntpclients/ntpviz
new file mode 100755
index 0000000..a3da517
--- /dev/null
+++ b/ntpclients/ntpviz
@@ -0,0 +1,1738 @@
+#!/usr/bin/env python
+# coding: utf-8
+"""\
+ntpviz - logfile visualizer for NTP log files
+
+ntpviz [-d LOGDIR] [-g] [-n name] [-p DAYS]
+         [-s starttime] [-e endtime]
+         [-o OUTDIR]
+         [ -c | --clip ]
+         [ -w SIZE | --width SIZE]
+         [--all-peer-jitters |
+          --all-peer-offsets |
+          --local-error |
+          --local-freq-temps |
+          --local-gps |
+          --local-jitter |
+          --local-offset |
+          --local-offset-histogram |
+          --local-offset-multiplot |
+          --local-stability |
+          --local-temps |
+          --peer-jitters=hosts |
+          --peer-offsets=hosts |
+         ]
+         [-D DLVL | --debug DLVL]
+         [-V | --version]
+         [@OPTIONFILE]
+
+See the manual page for details.
+
+Python by ESR, concept and GNUPLOT code by Dan Drown.
+"""
+#SPDX-License-Identifier: BSD-2-Clause
+from __future__ import print_function, division
+
+import argparse
+import csv
+import datetime
+import re
+import atexit, binascii, collections, os, socket, sys
+import subprocess
+import time
+import tempfile
+
+try:
+    import ntp.statfiles
+    import ntp.util
+except ImportError as e:
+    sys.stderr.write("ntpviz: can't find Python NTP library -- check PYTHONPATH.\n")
+    sys.stderr.write("%s\n" % e)
+    sys.exit(1)
+
+# overload ArgumentParser
+class MyArgumentParser(argparse.ArgumentParser):
+
+    def convert_arg_line_to_args(self, arg_line):
+        '''Make options file more tolerant'''
+        # strip out trailing comments
+        arg_line = re.sub('\s+#.*$', '', arg_line)
+
+        # ignore blank lines
+        if 0 == len(arg_line):
+            return []
+        # ignore comment lines
+        if '#' == arg_line[0]:
+            return []
+
+        return arg_line.split()
+
+
+def print_profile():
+    """called by atexit() on normal exit to print profile data"""
+    pr.disable()
+    pr.print_stats('tottime')
+    pr.print_stats('cumtime')
+
+# standard deviation functions
+# use this until we can guarantee Python 3.4 and the statistics module
+# http://stackoverflow.com/questions/15389768/standard-deviation-of-a-list#21505523
+
+def mean(data):
+    """Return the sample arithmetic mean of data."""
+    n = len(data)
+    if n < 1:
+        raise ValueError('mean requires at least one data point')
+    return sum(data)/n # in Python 2 use sum(data)/float(n)
+
+def _ss(data, mu=None):
+    """Return sum of square deviations of sequence data."""
+    if mu is None:
+        c = mean(data)
+    else:
+        c = mu
+    ss = sum((x-c)**2 for x in data)
+    return ss
+
+# fixme, need to handle mu=mean
+def pstdev(data, mu=None):
+    """Calculates the population standard deviation."""
+    n = len(data)
+    if n < 2:
+        # variance requires at least two data points
+        return 0
+    ss = _ss(data, mu)
+    pvar = ss/n # the population variance
+    return pvar**0.5
+
+# end standard deviation functions
+
+# class for calced values
+class VizStats(ntp.statfiles.NTPStats):
+    percs       = {}          # dictionary of percentages
+    title       = ''          # title
+    unit        = 's'         # display units: s, ppm, etc.
+    multiplier  = 1
+
+    # observe RFC 4180, end lines with CRLF
+    csv_head =  [
+            "Name", "Min", "1%", "5%", "50%", "95%", "99%", "Max", "",
+            "90% Range", "98% Range", "StdDev", "", "Mean", "Units"]
+
+    table_head =  """\
+<table style="text-align:right;">
+<thead>
+  <tr style="font-weight:bold;text-align:left;">
+    <td ></td>
+    <td colspan=8> Percentiles......</td>
+    <td colspan=3> Ranges......</td>
+    <td colspan=2></td>
+    <td ></td>
+  </tr>
+  <tr style="font-weight:bold;text-align:right;">
+    <td style="text-align:left;">Name</td>
+    <td>Min</td><td>1%</td><td>5%</td><td>50%</td><td>95%</td>
+    <td>99%</td><td>Max</td> <td style="width:10px;">&nbsp;</td>
+    <td>90%</td><td>95%</td><td>StdDev</td>
+    <td style="width:10px;">&nbsp;</td><td>Mean</td><td>Units</td>
+  </tr>
+</thead>
+"""
+
+    stats_html  = ''
+
+    def __init__( self, values, title, freq=0 ):
+
+        values.sort()
+        self.percs = self.percentiles( (100, 99, 95, 50, 5, 1, 0), values)
+
+        # find the target for autoranging
+        if args.clip:
+            # keep 99% and 1% under 999 in selected units
+            # clip to 1% and 99%
+            target = max(self.percs["p99"], -self.percs["p1"])
+        else:
+            # keep 99% and 1% under 999 in selected units
+            # but do not let 100% and 1% go over 5000 in selected units
+            target = max(self.percs["p99"], -self.percs["p1"],
+                         self.percs["p100"]/5, -self.percs["p0"]/5)
+
+        if 1 <= target:
+            self.multiplier = 1
+            if freq:
+                # go to ppm
+                self.unit = "ppm"
+            else:
+                # go to seconds
+                self.unit = "s"
+
+        elif 1e-3 <= target:
+            self.multiplier = 1e3
+            if freq:
+                # go to ppb
+                self.unit = "ppb"
+            else:
+                # go to millisec
+                self.unit = "ms"
+
+        elif 1e-6 <= target:
+            self.multiplier = 1e6
+            if freq:
+                self.unit = "10e-12"
+            else:
+                # go to microsec
+                self.unit = "µs"
+
+        else:
+            self.multiplier = 1e9
+            if freq:
+                self.unit = "10e-15"
+            else:
+                # go to nanosec
+                self.unit = "ns"
+
+        self.percs["mu"]      = mean( values )
+        self.percs["pstd"]    = pstdev( values, mu=self.percs["mu"] )
+
+        # range the data
+        self.percs.update({k: v * self.multiplier
+                     for k, v in list(self.percs.items())})
+
+        self.title       = title
+
+        # calculate ranges
+        self.percs["r90"] = self.percs["p95"] - self.percs["p5"]
+        self.percs["r98"] = self.percs["p99"] - self.percs["p1"]
+
+        # calculate mean +/- std dev
+        self.percs["m1sigma"] = self.percs["mu"] - self.percs["pstd"]
+        self.percs["p1sigma"] = self.percs["mu"] + self.percs["pstd"]
+
+        # pretty print the values
+        self.percs_f = {}
+        for k, v in self.percs.items():
+            self.percs[k]   = round(v, 3)
+            self.percs_f[k] = format(v, ",.3f")
+
+        # Python is stupid about nested objects, so add in some other stuff
+        self.percs_f["multiplier"] = self.percs["multiplier"] = self.multiplier
+        self.percs_f["title"]      = self.percs["title"]      = self.title
+        self.percs_f["unit"]       = self.percs["unit"]       = self.unit
+
+        if args.clip:
+            self.percs["min_y"] = self.percs["p1"]
+            self.percs["max_y"] = self.percs["p99"]
+            self.percs["clipped"] = " (clipped)"
+        else:
+            self.percs["min_y"] = self.percs["max_y"] = '*'
+            self.percs["clipped"] = ""
+
+        self.stats_html =  """\
+<br>
+<table style="margin-left:20px;border-spacing: 10px 0;">
+  <tr style="text-align:left;font-weight:bold;">
+    <td colspan=8> Percentiles......</td>
+    <td colspan=3> Ranges......</td>
+    <td colspan=2></td>
+    <td ></td>
+  </tr>
+  <tr style="font-weight:bold;font-weight:bold;text-align:right;">
+    <td style="min-width:55px;">Min</td><td style="min-width:55px;">1%%</td>
+    <td style="min-width:55px;">5%%</td><td style="min-width:55px;">50%%</td>
+    <td style="min-width:55px;">95%%</td><td style="min-width:55px;">99%%</td>
+    <td style="min-width:55px;">Max</td><td>&nbsp;</td>
+    <td style="min-width:55px;">90%%</td><td style="min-width:55px;">98%%</td>
+    <td style="min-width:55px;">StdDev</td>
+    <td>&nbsp;</td><td style="min-width:55px;">Mean</td><td>Units</td>
+  </tr>
+  <tr style="text-align:right;">
+    <td>%(p0)s</td><td>%(p1)s</td><td>%(p5)s</td><td>%(p50)s</td>
+    <td>%(p95)s</td><td>%(p95)s</td><td>%(p100)s</td><td>&nbsp;</td>
+    <td>%(r90)s</td><td>%(r98)s</td><td>%(pstd)s</td><td>&nbsp;</td>
+    <td>%(mu)s</td><td>%(unit)s</td>
+  </tr>
+</table>
+""" % self.percs_f
+
+        s =  ["%(title)s", "%(p0)s", "%(p1)s", "%(p5)s", "%(p50)s", "%(p95)s",
+              " %(p99)s", "%(p100)s", "", "%(r90)s", "%(r98)s", "%(pstd)s",
+              "", "%(mu)s", "%(unit)s"]
+
+        # csv is raw, html table is autoranged
+        self.csv   =  [ x % self.percs for x in s]
+        self.table =  [ x % self.percs_f for x in s]
+        self.table = "</td><td>".join(self.table)
+
+        self.table = '''\
+<tr style="vertical-align:top;">
+ <td style="text-align:left;">%s</td>
+</tr>
+''' % self.table
+
+        return
+
+
+# end calc things now
+
+# RMS frequency jitter - Deviation from a root-mean-square linear approximation?
+# Investigate.
+
+def gnuplot(template, outfile=None):
+    "Run a specified GNUPLOT program."
+    if not len( template ):
+        # silently ignore empty plots
+        return ''
+    if outfile is None:
+        out = None
+    else:
+        out = open(outfile, "w")
+    ##
+
+    # can be 30% faster to write to a tmp file than to pipe to gnuplot
+    # bonus, we can keep the plot file for debug.
+    tmp_file, tmp_filename = tempfile.mkstemp( suffix='.plt')
+    # note that tmp_file is a file handle, it is not a file object
+    os.write( tmp_file, template)
+    os.close(tmp_file)
+
+    # shell=True is a security hazard, do not use
+    try:
+        rcode = subprocess.call( ['gnuplot', tmp_filename], stdout=out)
+    except OSError as e:
+        if e.errno == os.errno.ENOENT:
+            # gnuplot not found
+            sys.stderr.write("ntpviz: ERROR: gnuplot not found in path\n")
+        else:
+            # Something else went wrong while trying to run gnuplot
+            sys.stderr.write("ntpviz: ERROR: gnuplot failed\n")
+        raise SystemExit(1)
+
+    if 0 != rcode:
+        sys.stderr.write("ntpviz: WARNING: plot returned %s\n" % rcode)
+        sys.stderr.write("ntpviz: WARNING: plot file %s\n" % tmp_filename)
+    elif 2 <= args.debug_level:
+        sys.stderr.write("ntpviz: INFO: plot file %s\n" % tmp_filename)
+    else:
+        # remove tmp file
+        os.remove(tmp_filename)
+
+    return rcode
+
+class NTPViz(ntp.statfiles.NTPStats):
+    "Class for visualizing statistics from a single server."
+
+    # Python takes single quotes here. Since no % substitution
+    Common = """\
+set grid
+set autoscale xfixmin
+set autoscale xfixmax
+set xdata time
+set xtic rotate by -35 scale 0
+set xlabel "Time (DDMM hh:mm UTC)"
+set format x "%d%b %H:%M"
+set timefmt "%s"
+set lmargin 10
+set rmargin 10
+"""
+
+    def __init__(self, statsdir,
+                 sitename=None, period=None, starttime=None, endtime=None):
+        ntp.statfiles.NTPStats.__init__(self, statsdir=statsdir,
+                    sitename=sitename, period=period, starttime=starttime,
+                    endtime=endtime)
+
+    def plot_slice( self, rows, item1, item2=None):
+        "slice 0,item1, maybe item2, from rows, ready for gnuplot"
+        # speed up by only sending gnuplot the data it will actually use
+        # WARNING: this is hot code, only modify if you profile
+        plot_data = ''
+        last_time = 0
+        if item2:
+            for row in rows:
+                try:
+                    if 1024000 < row[0] - last_time:
+                        # data loss, add a break in the plot line
+                        plot_data += '\n'
+                    # fields: time, fld, and rtt
+                    plot_data += row[1] + ' ' + row[item1] + ' ' + row[item2] + '\n'
+                    last_time = row[0]
+                except IndexError:
+                    pass
+        else:
+            for row in rows:
+                try:
+                    if 1024000 < row[0] - last_time:
+                        # data loss, add a break in the plot line
+                        plot_data += '\n'
+                    # fields: time, fld
+                    plot_data += row[1] + ' ' + row[item1] + '\n'
+                    last_time = row[0]
+                except IndexError:
+                    pass
+        # I know you want to replace the plot_data string concat with
+        # or more join()s, do not do it, it is slower
+        # next you'll want to try %-substitution.  it too is slower
+        plot_data += "e\n"
+        return plot_data
+
+    def local_offset_gnuplot(self):
+        "Generate GNUPLOT code graphing local clock loop statistics"
+        if not len( self.loopstats):
+            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
+            return ''
+
+        # speed up by only sending gnuplot the data it will actually use
+        # fields: time, time offset, freq offset
+        plot_data = self.plot_slice( self.loopstats, 2, 3)
+
+        # compute clock offset
+        values = [float(line[2]) for line in self.loopstats]
+        stats = VizStats( values, "Local Clock Time Offset")
+
+        # compute frequency offset
+        values_f = [float(line[3]) for line in self.loopstats]
+        stats_f = VizStats(values_f, "Local Clock Frequency Offset", freq=1)
+
+        out = stats.percs
+        out["min_y2"] = stats_f.percs["min_y"]
+        out["max_y2"] = stats_f.percs["max_y"]
+        out["unit_f"] = stats_f.percs["unit"]
+        out["multiplier_f"] = stats_f.percs["multiplier"]
+        out["sitename"] = self.sitename
+        out['size'] = args.png_size
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: Local Clock Time/Frequency Offsets%(clipped)s"
+set ytics format "%%1.1f %(unit)s" nomirror textcolor rgb '#0060ad'
+set yrange [%(min_y)s:%(max_y)s]
+set y2tics format "%%2.1f %(unit_f)s" nomirror textcolor rgb '#dd181f'
+set y2range [%(min_y2)s:%(max_y2)s]
+set key bottom right box
+set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
+set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
+plot \
+ "-" using 1:($2*%(multiplier)s) title "clock offset %(unit)s" with linespoints ls 1, \
+ "-" using 1:($3*%(multiplier_f)s) title "frequency offset %(unit_f)s" with linespoints ls 2 axis x1y2
+""" % out
+
+        exp = """\
+<p>The time and frequency offsets between the ntpd calculated time
+and the local system clock.  Showing frequency offset (red, in parts
+per million, scale on right) and the time offset (blue, in μs, scale
+on left).  Quick changes in time offset will lead to larger frequency
+offsets.</p>
+
+<p>These are fields 3 (time) and 4 (frequency) from the loopstats log
+file.</p>
+
+"""
+
+        ret = {}
+        ret['html'] = stats.stats_html + stats_f.stats_html + exp
+        ret['stats'] = [stats, stats_f]
+        ret['title'] = "Local Clock Time/Frequency Offsets"
+        ret['plot'] = plot_template + plot_data + plot_data
+        return ret
+
+    def local_freq_temps_plot(self):
+        "Generate GNUPLOT code graphing local frequency and temps"
+        if not len( self.loopstats):
+            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
+            return ''
+
+        tempsmap = self.tempssplit()
+        tempslist = tempsmap.keys()
+        tempslist.sort()
+        if not len( tempsmap) or not len( tempslist):
+            sys.stderr.write("ntpviz: WARNING: no temps to graph\n")
+            return ''
+
+        # speed up by only sending gnuplot the data it will actually use
+        # fields: time, freq offset
+        plot_data = self.plot_slice( self.loopstats, 3)
+
+        # compute frequency offset
+        values_f = [float(line[3]) for line in self.loopstats]
+        stats_f = VizStats(values_f, "Local Clock Frequency Offset", freq=1)
+
+        stats = []
+        temps_data = ()
+        plot_data_t = ''
+        for key in tempslist:
+            # speed up by only sending gnuplot the data it will actually use
+            # fields: time, temp
+            plot_data_t += self.plot_slice( tempsmap[key], 3)
+
+        #out = stats.percs
+        out = {}
+        out["min_y2"] = stats_f.percs["min_y"]
+        out["max_y2"] = stats_f.percs["max_y"]
+        out["unit_f"] = stats_f.percs["unit"]
+        out["unit"] = 'C'
+        out["multiplier_f"] = stats_f.percs["multiplier"]
+        out["sitename"] = self.sitename
+        out['size'] = args.png_size
+        if args.clip:
+            out["clipped"] = " (clipped)"
+        else:
+            out["clipped"] = ""
+
+        # let temp autoscale
+        # set yrange [%(min_y)s:%(max_y)s]
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: Local Frequency Offset/Temps%(clipped)s"
+set ytics format "%%1.1f %(unit)s" nomirror textcolor rgb '#0060ad'
+set y2tics format "%%2.1f %(unit_f)s" nomirror textcolor rgb '#dd181f'
+set y2range [%(min_y2)s:%(max_y2)s]
+set key bottom right box
+set style line 1 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
+plot \
+ "-" using 1:($2*%(multiplier_f)s) title "frequency offset %(unit_f)s" with linespoints ls 1 axis x1y2, \
+""" % out
+
+        for key in tempslist:
+            out['key'] = key
+            plot_template += "'-' using 1:2 title '%(key)s' with line, \\\n" \
+                 % out
+
+        # strip trailing ", \n"
+        plot_template = plot_template[:-4] + "\n"
+
+        exp = """\
+<p>The frequency offsets and temperatures.
+Showing frequency offset (red, in parts
+per million, scale on right) and the temeratures.</p>
+
+<p>These are field 4 (frequency) from the loopstats log
+file, and field 3 from the temp log .</p>
+
+"""
+
+        ret = {}
+        # ret['html'] = stats.stats_html + stats_f.stats_html + exp
+        ret['html'] = stats_f.stats_html + exp
+        ret['stats'] = [stats, stats_f]
+        ret['stats'] = [stats_f]
+        ret['title'] = "Local Frequency/Temp"
+        ret['plot'] = plot_template + plot_data + plot_data_t
+        return ret
+
+    def local_temps_gnuplot(self):
+        "Generate GNUPLOT code graphing local temperature statistics"
+        sitename = self.sitename
+        tempsmap = self.tempssplit()
+        tempslist = tempsmap.keys()
+        tempslist.sort()
+
+        if not len( tempsmap) or not len( tempslist):
+            sys.stderr.write("ntpviz: WARNING: no temps to graph\n")
+            return ''
+
+        stats = []
+        temps_data = ()
+        plot_data = ''
+        for key in tempslist:
+            # speed up by only sending gnuplot the data it will actually use
+            # fields: time, temp
+            plot_data += self.plot_slice( tempsmap[key], 3)
+
+        out = {}
+        out['sitename'] = sitename
+        out['size'] = args.png_size
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: Local Temparatures"
+set ytics format "%%1.1f °C" nomirror textcolor rgb '#0060ad'
+set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
+plot \\
+""" % out
+
+        for key in tempslist:
+            out['key'] = key
+            plot_template += "'-' using 1:2 title '%(key)s' with line, \\\n" \
+                 % out
+
+        # strip the trailing ", \n"
+        plot_template = plot_template[:-4] + "\n"
+        exp = """\
+<p>Local temperatures.  These will be site specific depending on what
+temperature sensors you have and collect data from.  Temperature
+changes change the local clock crystal frequency and stability.  Crystals
+oscillate faster when warmer. This the single most important
+component of frequency drift.</p>
+<p>The Local Termperatures are from field 3 from the tempstats log file.</p>
+"""
+        ret = {'html' : exp, 'stats' : stats }
+        ret['title'] = "Local Temperatures"
+        ret['plot'] = plot_template + plot_data
+        return ret
+
+    def local_gps_gnuplot(self):
+        "Generate GNUPLOT code graphing local gps statistics"
+        sitename = self.sitename
+        gpsmap = self.gpssplit()
+        gpslist = gpsmap.keys()
+        gpslist.sort()
+
+        if not len( gpsmap) or not len( gpslist):
+            if 1 <= args.debug_level:
+                sys.stderr.write("ntpviz: INFO: no gps data to graph\n")
+            return ''
+
+        stats = []
+        gps_data = ()
+        plot_data = ""
+        for key in gpslist:
+            # fields: time, tdop, nSats
+            plot_data += self.plot_slice( gpsmap[key], 3, 4)
+
+        out = {}
+        out['sitename'] = sitename
+        out['size'] = args.png_size
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: Local GPS
+set ytics format "%%1.1f tdop" nomirror textcolor rgb '#0060ad'
+set y2tics format "%%2.0f nSat"  nomirror textcolor rgb '#dd181f'
+set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
+set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
+plot \\
+""" % out
+
+        for key in gpslist:
+            plot_template += """\
+'-' using 1:2 title '%(key)s tdop' with line ls 1, \\
+'-' using 1:3 title '%(key)s nSat' with line ls 2 axis x1y2, \\
+""" % locals()
+
+        # strip the trailing ", \\n"
+        plot_template = plot_template[:-4] + "\n"
+        exp = """\
+<p>Local GPS.  The Time Dilution of Precision (tdop) is plotted in blue.
+The number of visible satellites (nSat) is plotted in red.</p>
+<p>tdop is field 3, and nSats is field 4, from the gpsd log file.  The
+gpsd log file is created by the gps-log.py program.</p>
+"""
+        ret = {'html' : exp, 'stats' : stats }
+        ret['title'] = "Local GPS"
+        ret['plot'] = plot_template + plot_data + plot_data
+        return ret
+
+    def local_error_gnuplot(self):
+        "Plot the local clock frequency error."
+        if not len( self.loopstats):
+            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
+            return ''
+
+        # grab and sort the values, no need for the timestamp, etc.
+
+        # compute freqency offset
+        values = [float(line[2]) for line in self.loopstats]
+        stats = VizStats( values, "Local Clock Frequency Offset", freq=1, )
+
+        # build the output dictionary, because Python can not format
+        # complex objects.
+        out = stats.percs
+        out["sitename"] = self.sitename
+        out['size'] = args.png_size
+
+        # speed up by only sending gnuplot the data it will actually use
+        # fields: time, freq error
+        plot_data = self.plot_slice( self.loopstats, 3)
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: Local Clock Frequency Offset%(clipped)s"
+set ytics format "%%1.1f %(unit)s" nomirror
+set yrange [%(min_y)s:%(max_y)s]
+set key bottom right box
+set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
+set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
+plot \
+ "-" using 1:($2 * %(multiplier)s) title "local clock error" with linespoints ls 2, \
+ %(p99)s title "99th percentile", \
+ %(p95)s title "95th percentile", \
+ %(p5)s title "5th percentile", \
+ %(p1)s title "1st percentile"
+""" % out
+
+        exp = """\
+<p>This shows the frequency offset of the local clock (aka drift).  The
+graph includes percentile data to show how much the frequency changes
+over a longer period of time.  The majority of this change should come
+from temperature changes (ex: HVAC, the weather, CPU usage causing local
+heating).</p>
+
+<p>Smaller changes are better.  An ideal result would be a horizontal
+line at 0ppm.  Expected values of 99%-1% percentiles: 0.4ppm</p>
+
+<p>The Frequency Offset comes from field 4 of the loopstats log file.</p>
+"""
+        ret = {'html' : stats.stats_html + exp, 'stats' : [stats] }
+        ret['title'] = "Local Clock Frequency Offset"
+        ret['plot'] = plot_template + plot_data
+        return ret
+
+    def loopstats_gnuplot(self, fld, title, legend, freq):
+        "Generate GNUPLOT code of a given loopstats field"
+        if not len( self.loopstats):
+            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
+            return ''
+
+        # speed up by only sending gnuplot the data it will actually use
+        # fields: time, fld
+        plot_data = self.plot_slice( self.loopstats, fld)
+
+        # grab and process the values
+        values = [float(line[fld]) for line in self.loopstats]
+        stats = VizStats( values, title, freq=freq )
+
+        # build the output dictionary, because Python can not format
+        # complex objects.
+        out = stats.percs
+        out["sitename"] = self.sitename
+        out["fld"]      = fld
+        out["legend"]   = legend
+        out["min_y"] = '0'
+        out['size'] = args.png_size
+
+        if freq:
+            exp = """\
+<p>This shows the RMS Frequency Jitter (aka wander) of the local
+clock's frequency.  In other words, how fast the local clock changes
+freqency.</p>
+
+<p>Lower is better.  An ideal clock would be a horizontal line at
+0ppm.</p>
+
+<p> RMS Frequency Jitter is field 6 in the loopstats log file.</p>
+"""
+        else:
+            exp = """\
+<p>This shows the RMS Jitter of the local clock offset.  In other words,
+how fast the local clock offset is changing.</p>
+
+<p>Lower is better.  An ideal system would be a horizontal line at 0μs.</p>
+
+<p>RMS jitter is field 5 in the loopstats log file.</p>
+"""
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: %(title)s%(clipped)s"
+set ytics format "%%1.1f %(unit)s" nomirror
+set yrange [%(min_y)s:%(max_y)s]
+set key top right box
+set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
+set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
+plot \
+ "-" using 1:($2*%(multiplier)s) title "%(legend)s" with linespoints ls 1, \
+ %(p99)s title "99th percentile", \
+ %(p95)s title "95th percentile", \
+ %(p5)s title "5th percentile", \
+ %(p1)s title "1st percentile"
+""" % out
+
+        ret = {'html' : stats.stats_html + exp, 'stats' : [stats],
+               'title' : title }
+        ret['plot'] = plot_template + plot_data
+        return ret
+
+    def local_offset_jitter_gnuplot(self):
+        "Generate GNUPLOT code of local clock loop standard deviation"
+        return self.loopstats_gnuplot(4, "Local RMS Time Jitter", "Jitter", 0)
+
+    def local_offset_stability_gnuplot(self):
+        "Generate GNUPLOT code graphing local clock stability"
+        return self.loopstats_gnuplot(5, "Local RMS Frequency Jitter",
+                                      "Stability", 1)
+
+    def peerstats_gnuplot(self, peerlist, fld, title, type):
+        "Plot a specified field from peerstats."
+
+        peerdict = self.peersplit()
+        if not peerlist:
+            peerlist = peerdict.keys()
+        if not len( peerlist):
+            sys.stderr.write("ntpviz: WARNING: no peer data to graph\n")
+            return ''
+        peerlist.sort() # For stability of output
+        namelist = []   # peer names
+
+        ip_todo = []
+        for key in peerlist:
+            # Trickiness - we allow peerlist elements to be DNS names.
+            # The socket.gethostbyname() call maps DNS names to IP addresses,
+            # passing through literal IPv4 addresses unaltered.  However,
+            # it barfs on either literal IPv6 addresses or refclock names.
+            try:
+                ip = socket.gethostbyname(key)
+                namelist.append(key)
+            except:
+                # ignore it
+                ip = key
+                # socket.getfqdn() is also flakey...
+                namelist.append(socket.getfqdn(key))
+
+            if ip in peerdict:
+                ip_todo.append(ip)
+            else:
+                # can this ever happen?
+                sys.stderr.write("ntpviz: ERROR: No such peer as %s" % key)
+                raise SystemExit(1)
+
+        rtt = 0
+        percentages = ""
+        stats = []
+        if len(peerlist) == 1:
+            # only one peer
+            if "offset" == type:
+                # doing offset, not jitter
+                rtt = 1
+                if "127.127." == peerlist[0][:8]:
+                    # don't do rtt for reclocks
+                    rtt = 0
+                    title = "Refclock Offset " + str(peerlist[0])
+                    exp = """\
+<p>This shows the offset of a local refclock in seconds.  This is
+useful to see how the measured offset is behaving.</p>
+
+<p>Closer to 0s is better.  An ideal system would be a horizontal line
+at 0s. Typical 90%% ranges may be: local serial GPS 200 ms; local PPS
+20µs</p>
+
+<p>Clock Offset is field 5 in the peerstats log file.</p>
+"""
+                else:
+                    title = "Peer Offset " + str(peerlist[0])
+                    exp = """\
+<p>This shows the offset of a peer or server in seconds.  This is
+useful to see how the measured offset is behaving.</p>
+
+<p>The chart also plots offset±rtt.  Where rtt is the round trip time
+to the remote.  NTP can not really know the offset of a remote chimer,
+NTP computes it by subtracting rtt/2 from the offset.  Plotting the
+offset±rtt reverses this calculation to more easily see the effects of
+rtt changes.</p>
+
+<p>Closer to 0s is better.  An ideal system would be a horizontal line
+at 0s. Typical 90% ranges may be: local LAN peer 80µs; 90% ranges for
+WAN servers may be 4ms and much larger. </p>
+
+<p>Clock Offset is field 5 in the peerstats log file.  The Round Trip
+Time (rtt) is field 6 in the peerstats file.</p>
+"""
+
+            else:
+                # doing jitter, not offset
+                if "127.127." == peerlist[0][:8]:
+                    title = "Refclock RMS Jitter " + str(peerlist[0])
+                    exp = """\
+<p>This shows the RMS Jitter of a local refclock.  Jitter is the
+current estimated dispersion; the variation in offset between samples.</p>
+
+<p>Closer to 0s is better.  An ideal system would be a horizontal
+line at 0s.</p>
+
+<p>RMS Jitter is field 8 in the peerstats log file.</p>
+"""
+                else:
+                    title = "Peer Jitter " + str(peerlist[0])
+                    exp = """\
+<p>This shows the RMS Jitter of a remote peer or server.  Jitter is
+the current estimated dispersion; the variation in offset between
+samples.</p>
+
+<p>Closer to 0s is better.  An ideal system would be a horizontal line
+at 0s.</p>
+
+<p>RMS Jitter is field 8 in the peerstats log file.</p>
+"""
+
+            # grab and sort the values, no need for the timestamp, etc.
+            values = [float(line[fld]) for line in peerdict[ip]]
+
+            stats = VizStats( values, title)
+
+            if len(namelist[0]) and peerlist[0] != namelist[0]:
+                # append hostname, if we have it
+                # after stats to keep summary short
+                title += " (%s)" % namelist[0]
+
+
+            percentages = " %(p50)s title '50th percentile', " \
+                           % stats.percs
+
+            exp = stats.stats_html + exp
+
+
+        else:
+            # many peers
+            title += "s"
+            # grab and sort the values, no need for the timestamp, etc.
+            values = [float(line[fld]) for line in self.peerstats]
+
+            stats = VizStats( values, title )
+
+            exp = stats.stats_html
+            if "offset" == type:
+                title = "Peer Offsets"
+                exp += """\
+<p>This shows the offset of all refclocks, peers and servers in
+%(unit)s.  This can be useful to see if offset changes are happening in
+a single clock or all clocks together.</p>
+
+<p>Clock Offset is field 5 in the peerstats log file.</p>
+""" % stats.percs
+            else:
+                title = "Peer Jitters"
+                exp += """\
+<p>This shows the RMS Jitter of all refclocks, peers and servers.
+Jitter is the current estimated dispersion; the variation in offset
+between samples.</p>
+
+<p>Closer to 0s is better.  An ideal system would be a horizontal line
+at 0s.</p>
+
+<p>RMS Jitter is field 8 in the peerstats log file.</p>
+"""
+
+        plot_data = ""
+        for ip in ip_todo:
+            # 20% speed up by only sending gnuplot the data it will
+            # actually use
+            if rtt:
+                # fields: time, fld, and rtt
+                plot_data += self.plot_slice( peerdict[ip], fld, 5)
+            else:
+                # fields: time, fld
+                plot_data += self.plot_slice( peerdict[ip], fld)
+
+        out = stats.percs
+        out['sitename'] = self.sitename
+        out['title'] = title
+        out['size'] = args.png_size
+
+        if 6 >= len(peerlist):
+            out['set_key'] = "set key top right box"
+        else:
+            # too many keys to show
+            out['set_key'] = "set key off"
+
+        plot_template = NTPViz.Common + """\
+set terminal png size %(size)s
+set title "%(sitename)s: %(title)s%(clipped)s"
+set ylabel ""
+set ytics format "%%1.1f %(unit)s" nomirror
+set yrange [%(min_y)s:%(max_y)s]
+%(set_key)s
+plot \
+""" % out
+
+        plot_template += percentages
+        for key in peerlist:
+            out['label'] = self.ip_label(key)
+            plot_template += "'-' using 1:($2*%(multiplier)s) title '%(label)s' with line, \\\n" \
+                 % out
+
+        if 1 == rtt:
+            plot_template += """\
+'-' using 1:(($2+$3/2)*%(multiplier)s) title 'offset+rtt/2' with line, \\
+'-' using 1:(($2-$3/2)*%(multiplier)s) title 'offset-rtt/2' with line
+""" % stats.percs
+            # sadly, gnuplot needs 3 identical copies of the data.
+            plot_template += plot_data + plot_data
+        else:
+            # strip the trailing ", \n"
+            plot_template = plot_template[:-4] + "\n"
+
+        ret = {'html' : exp, 'stats' : [stats], 'title' : title }
+        ret['plot'] = plot_template + plot_data
+        return ret
+
+    def peer_offsets_gnuplot(self, peerlist=None):
+        return self.peerstats_gnuplot(peerlist, 4, "Peer Clock Offset", "offset")
+
+    def peer_jitters_gnuplot(self, peerlist=None):
+        return self.peerstats_gnuplot(peerlist, 7, "Peer Clock Jitter", "jitter")
+
+    def local_offset_histogram_gnuplot(self):
+        "Plot a histogram of clock offset values from loopstats."
+        if not len( self.loopstats):
+            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
+            return ''
+
+        # TODO normalize to 0 to 100?
+
+        # grab and sort the values, no need for the timestamp, etc.
+        values = [float(row[2]) for row in self.loopstats]
+        stats = VizStats( values, 'Local Clock Offset' )
+        out = stats.percs
+        out['sitename'] = self.sitename
+        # flip the axis
+        out['min_x']    = out['min_y']
+        out['max_x']    = out['max_y']
+
+        rnd1 = 7        # round to 100 ns boxes
+        out['boxwidth'] = 1e-7
+
+        if 1e-6 > stats.percs["p99"] and -1e-6 < stats.percs["p1"]:
+            # go to nanosec
+            rnd1 = 9        # round to 1 ns boxes
+            out['boxwidth'] = 1e-9
+
+        cnt = collections.Counter()
+        for value in values:
+            # put into buckets
+            # for a +/- 50 microSec range that is 1,000 buckets to plot
+            cnt[ round( value, rnd1)] += 1
+
+        sigma = True
+        if args.clip:
+            if stats.percs['p1sigma'] > stats.percs['p99'] or \
+               stats.percs['m1sigma'] < stats.percs['p1']:
+                # sigma out of range, do not plot
+                sigma = ''
+
+        out['sigma'] = ''
+        if sigma:
+            # plus/minus of one sigma range
+            out['sigma'] = """\
+set style arrow 1 nohead
+set arrow from %(m1sigma)s,graph 0 to %(m1sigma)s,graph 0.90 as 1
+set style arrow 2 nohead
+set arrow from %(p1sigma)s,graph 0 to %(p1sigma)s,graph 0.90 as 2
+set label 1 "-1σ" at %(m1sigma)s, graph 0.96  left front offset -1,-1
+set label 2 "+1σ" at %(p1sigma)s, graph 0.96  left front offset -1,-1
+""" % out
+
+        out['size'] = args.png_size
+
+        # in 2016, 25% of screens are 1024x768, 42% are 1388x768
+        # but leave some room for the browser frame
+        plot_template = '''\
+set terminal png size %(size)s
+set title "%(sitename)s: Local Clock Time Offset Histogram%(clipped)s"
+set grid
+set boxwidth %(boxwidth)s
+set xtic rotate by -35 scale 0
+set xtics format "%%1.1f %(unit)s" nomirror
+set xrange [%(min_x)s:%(max_x)s]
+set yrange [0:*]
+set style arrow 3 nohead
+set arrow from %(p99)s,graph 0 to %(p99)s,graph 0.30 as 3
+set style arrow 4 nohead
+set arrow from %(p95)s,graph 0 to %(p95)s,graph 0.45 as 4
+set style arrow 5 nohead
+set arrow from %(p5)s,graph 0 to %(p5)s,graph 0.45 as 5
+set style arrow 6 nohead
+set arrow from %(p1)s,graph 0 to %(p1)s,graph 0.30 as 6
+set key off
+set lmargin 10
+set rmargin 10
+set style fill solid 0.5
+set label 3 "99%%" at %(p99)s, graph 0.35  left front offset -1,-1
+set label 4 "95%%" at %(p95)s, graph 0.50  left front offset -1,-1
+set label 5 "1%%" at %(p1)s, graph 0.35  left front offset -1,-1
+set label 6 "5%%" at %(p5)s, graph 0.50  left front offset -1,-1
+%(sigma)s
+plot \
+ "-" using ($1 * %(multiplier)s):2 title "histogram" with boxes
+''' % out
+
+        histogram_data = ["%s %s\n" % (k, v) for k,v in cnt.items() ]
+
+        exp = """\
+<p>This shows the clock offsets of the local clock as a histogram.</p>
+
+<p>The Local Clock Offset is field 3 from the loopstats log file.</p>
+"""
+        # don't return stats, it's just a dupe
+        ret = {'html' : stats.stats_html + exp, 'stats' : []}
+        ret['title'] = "Local Clock Time Offset Histogram"
+        ret['plot'] = plot_template + "".join(histogram_data) + "e\n"
+        return ret
+
+# Multiplotting can't live inside NTPViz because it consumes a list
+# of such objects, not a single one.
+
+def local_offset_multiplot(statlist):
+    "Plot comparative local offsets for a list of NTPViz objects."
+
+    out = []
+    out['size'] = args.png_size
+
+    plot = NTPViz.Common + '''\
+set terminal png size %(size)s
+set title "Multiplot Local Clock Offsets"
+set ytics format "%1.2f μs" nomirror textcolor rgb "#0060ad"
+set key bottom right box
+plot \\
+''' % out
+    # FIXME: We probably need to be more flexible about computing the plot label
+    sitenames = [os.path.basename(os.path.dirname(d)) for d in args.statsdirs]
+    for (i, stats) in enumerate(statlist):
+        plot += '"-" using 1:($2*1000000) title "%s clock offset μs" with linespoints, \\\n' % (sitenames[i])
+    plot = plot[:-4] + "\n"
+
+    plot_data = ''
+    for stats in statlist:
+        # speed up by only sending gnuplot the data it will actually use
+        # fields: time, offset
+        plot_data += self.plot_slice( stats.loopstats, 2)
+
+    ret = {'html' : '', 'stats' : [] }
+    ret['title'] = "Multiplot"
+    ret['plot'] = plot + plot_data
+    return ret
+
+# here is how to create the base64 from an image file:
+# with open("path/to/file.png", "rb") as f:
+#    data = f.read()
+#    print data.encode("base64")
+#
+ntpsec_logo = """
+iVBORw0KGgoAAAANSUhEUgAAAEAAAABKCAQAAACh+5ozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdC
+AK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dE
+AP7wiPwpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFKElEQVRo3s2ZT0wcVRzHPzMLKCwsNgqLkYPS
+xBjbRF3TcKlC4VAhFU0AdRN7a+zBEsUEL0qImqoxMTWhBzEkTdqmREhMCgpeiiV6KVE46MVE1KQg
+uxv/df81tLvzPOzsMjs7sztvd7b4ndPsfPf3vu/33vv93vs9yGCIJMLyWaKJXTSxZMMTCITilJ1k
+KENRdeoB6rHGYboNb80cpAjEQZoNr90ctiHWcyBfgD0aCZTk2CFAYylKTd7bVZYNknycwGf5ryjT
+RE2/OWVr9Bh9ahbwnuGtnRdsTZ5h0/Rbhr1PDYhNUZyt2guwRjdazi8+G0lZeMWoeExna3mzxwbO
+BDgwlIWQYhefhCkSNl8SpCpkO/JAiHFO00D+kCokGa8JpRyylSTjIlSeAPiC7/AU/JomknLM9qRb
+Ijv8XaaANNs4hyU7VcJE6UBUZeR7wLjgqgXT4jQL6JYw5Qqy/U3e6YazLWY9cJ5DDOc+/kvU9aHQ
+8HFP7m2O8/kCwoyQYgAvAD8xwja1rjUugA7e15NzgnlGCRfSvATZII1A4yv1KIqL/R/iF9IIBCGC
+itfOtEoHs/qeJURQ90elaGOCbQSCtLKhDOd/LJTiZ1KfDXGW+aFiP2h00o8CJJhX3m75PabdLMZX
+jIrdfIq6vhDDhFxtfkV9xtqXlrmgjltzHGIMSBMhXcEAeGjFAyxrX1sTLAXcAvTsHuE5tixjgga6
+NA92OUXjAS5zfzGFpXZEabb5w7Jn99LMAI3EmecGf9n4SS3lPydbskKjD3GcIM3ch4c0Y9xghgv8
+hiZvrBwBg3zIgwj+1FN9LfsZ52Uu8ikhWWPyAoY5Swu/coEZYmio+DhGD31M8CgjViG2PEwgEFyn
+3dR8GMEsHahAF+/SBezGjkums1A71xEIJtwR0K837zdwdk0HiRNnQE6ATNL1cpJWFjll4+YF5vFy
+Qi6DyAhop5MkU0Rsvsd5hzC99FZLwAB+NlktwtjkGg08US0BDcDlogstwRoQkBkE2WVYePw6ondD
+ZZUFAALssz2mVSwgHzFCPMwjAHhoY1HehKyAAF5D76aZNXyL6nF/jX+qI2CdJJ2087Ohyfw6iZcA
+sOZ8AOQm4Sqb+HmpCKOXXhKsS9iUEhDiEnCc/TbfWzmJlytcqZYAuMgG+/kgF4qN8HOWfiJMyQxA
+MRRLRoscy0s62e18GNOmu3QukF0Fc8AkfTzFN6zwJXEET9LF83QQ4RRz7vTe3gOg0McCMQQpQmyx
+RRRBnAX6LPa9rnsABEt8yxG6eFavC8dZYYqrxMvpZ3mRMM4Ci3ycqwhFC+qmVRYAsvWjsgX4GC2/
+d5SurNoK8Oo1ch9vuNFP+XN2kJjLR9Nh64asPNDEa7xKIxVNLgN8+PAzCVZRwurEGuQzGoEwr7Ni
+USmVQ5ouPsFPpgzkIFBlD+a2TpOF6txmPtXVMpkTCZ5d2jaDblaoABjUqy4mCcZ2+jlHK3CTt/gc
+xdUqmUDwIqepBzY4ykahgFbO0Q9AirCp6u8OFPz6qpvhlcLMMeZ6Wcr+iSu5E+TuTGvIyqzuA4BX
+5E5P5kAUrZuucSP42CDl2zHdLhYI2DmzsylhURYFd5F7fmOy5wJqaFbb7h5Q65PdGoDvrtEqz4HM
+APTUfn97HZW4whKPKy14sgvf9QhoQi7ARImi8KNSlZAjgewqcCfzy0DfrGUFTPORi1c0pXGbNzOb
+vV0PuFZgdAjd4/+DZZjBnbgzNSJ3f7rnq0AltrcCPMR4mro9a3/9Pwl2Z1Rsm9zNAAAAJXRFWHRk
+YXRlOmNyZWF0ZQAyMDE1LTA2LTI5VDE4OjMwOjA3LTA0OjAwZxkj2wAAACV0RVh0ZGF0ZTptb2Rp
+ZnkAMjAxNS0wNi0yOVQxODozMDowNy0wNDowMBZEm2cAAAAASUVORK5CYII=
+"""
+
+ntpsec_ico = """\
+AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/
+AAAA/wAAAP8AAAD/AAAAAAAAAP+fn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cf
+n59gn5+fYJ+fn2B/f39/AAAA/wAAAAAAAAAAAAAA/5+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+f
+n2Cfn59gn5+fYJ+fn2Cfn59gAAAA/wAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA
+/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59g
+n5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+f
+n59gn5+fYAAAAP8AAAD/AAAA/wAAAP8AAAD/n5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAA
+AAAAAAD/n5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAA/5+fn2AAAAD/AAAAAAAAAAAAAAD/AAAA/01NTWAAAAD/n5+fYAAAAP8AAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA/wAAAAAAAAAAAAAA/5+fn2AA
+AAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/n5+fYAAAAP8AAAAAAAAAAE1NTWAAAAAAAAAAAAAA
+AP+fn59gAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59gAAAA/wAAAP8AAAD/AAAA
+/wAAAP+fn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAEBAf+fn59gn5+fYJ+fn2Cfn59g
+n5+fYJ+fn2Cfn59gn5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8A
+AAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAA
+/wAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAA/wAAAAAAAAAA
+AAAAAAAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8A
+AAAAgAAAAL/+AADf/QAAwAEAAO/7AADsGwAA6+sAAOsrAADrawAA6+sAAOwbAADv+wAA4AMAAN/9
+AADRxQAAxBEAAA==
+"""
+
+if __name__ == '__main__':
+
+    parser = MyArgumentParser(description="ntpd stats visualizer",
+                fromfile_prefix_chars='@',
+                epilog = """
+You can place command line options in a file, one per line.
+
+See the manual page for details.
+
+Python by ESR, concept and GNUPLOT code by Dan Drown.
+""")
+    group = parser.add_mutually_exclusive_group()
+
+    parser.add_argument('-c', '--clip',
+                action="store_true",
+                default = None,
+                dest='clip',
+                help="Clip plots at 1%% and 99%%")
+    parser.add_argument('-d', '--datadir',
+                default = "/var/log/ntpstats",
+                dest='statsdirs',
+                help="one or more logfile directories to read",
+                type=str)
+    parser.add_argument('-e', '--endtime',
+                default=None,
+                dest='endtime',
+                help="End time in POSIX (seconds) or ISO 8601",
+                type=str)
+    parser.add_argument('-g', '--generate',
+                action="store_true",
+                default=False,
+                dest='generate',
+                help="Run plot through gnuplot to make png")
+    parser.add_argument('-n', '--name',
+                default=socket.getfqdn(),
+                dest='sitename',
+                help="sitename (title)",
+                type=str)
+    parser.add_argument('-o', '--outdir',
+                default = "ntpgraphs",
+                dest='outdir',
+                help="output directory",
+                type=str)
+    parser.add_argument('-p', '--period',
+                default = 7,    # default to 7 days
+                dest='period',
+                help="period in days to graph (float)",
+                type=float)
+    parser.add_argument('-s', '--starttime',
+                default=None,
+                dest='starttime',
+                help="Start time in POSIX (seconds) or ISO 8601",
+                type=str)
+    parser.add_argument('-w', '--width',
+                choices=['s', 'm', 'l'],
+                default='m',
+                dest='width',
+                help="PNG width: s, m, or l",
+                type=str)
+    group.add_argument( '--all-peer-jitters',
+                default = False,
+                action="store_true",
+                dest='show_peer_jitters',
+                help="Plot all peer jitters")
+    group.add_argument( '--peer-jitters',
+                default = '',
+                dest='peer_jitters',
+                help="Plot peer jitters.  Comma separated host list.",
+                type=str)
+    group.add_argument( '--all-peer-offsets',
+                default = False,
+                action="store_true",
+                dest='show_peer_offsets',
+                help="Plot all peer offsets")
+    group.add_argument( '--peer-offsets',
+                default = '',
+                dest='peer_offsets',
+                help="Plot peer offsets.  Comma separated host list.",
+                type=str)
+    group.add_argument( '--local-error',
+                default=False,
+                action="store_true",
+                dest='show_local_error',
+                help="Plot local clock frequency offsets")
+    group.add_argument( '--local-freq-temps',
+                default = False,
+                action="store_true",
+                dest='show_freq_temps',
+                help="Plot local frequency vs temperature data")
+    group.add_argument( '--local-gps',
+                default = False,
+                action="store_true",
+                dest='show_gps',
+                help="Plot gpsd tdop and nSats")
+    group.add_argument( '--local-jitter',
+                default=False,
+                action="store_true",
+                dest='show_local_jitter',
+                help="Plot clock time jitter")
+    group.add_argument( '--local-offset',
+                default=False,
+                action="store_true",
+                dest='show_local_offset',
+                help="Plot Clock frequency offset")
+    group.add_argument( '--local-offset-histogram',
+                default=False,
+                action="store_true",
+                dest='show_local_offset_histogram',
+                help="Plot histogram of loopstats time offsets")
+    group.add_argument( '--local-offset-multiplot',
+                default = False,
+                action="store_true",
+                dest='show_local_offset_multiplot',
+                help="Plot comparative local offsets for multiple directories")
+    group.add_argument( '--local-stability',
+                default=False,
+                action="store_true",
+                dest='show_local_stability',
+                help="Plot RMS frequency-jitter")
+    group.add_argument( '--local-temps',
+                default = False,
+                action="store_true",
+                dest='show_temps',
+                help="Plot local temperature data")
+    parser.add_argument('-D', '--debug',
+                default=0,
+                dest='debug_level',
+                help="debug level, 0 (none) to 9 (most)",
+                type=int)
+    parser.add_argument('-V', '--version',
+                action="store_true",
+                default=False,
+                dest='version',
+                help="Print version and exit")
+
+    args = parser.parse_args()
+
+    version = ntp.util.stdversion()
+
+    if args.version:
+        print(version)
+        raise SystemExit(1)
+
+    if 's' == args.width:
+        # fit in 1024x768 browser
+        # in 2016 this is 22% of all browsers
+        args.png_size = '1000,720'
+    elif 'l' == args.width:
+        # fit in 1920x1080 browser
+        args.png_size = '1850,1000'
+    else:
+        # fit in 1388x768 browser
+        # in 2016 this is 42% of all browsers
+        args.png_size = '1340,720'
+
+    args.period = int( float(args.period) * ntp.statfiles.NTPStats.SecondsInDay)
+    if args.endtime is not None:
+        args.endtime = iso_to_posix(args.endtime)
+    if args.starttime is not None:
+        args.starttime = iso_to_posix(args.starttime)
+
+    args.statsdirs = [os.path.expanduser(path)
+                     for path in args.statsdirs.split(",")]
+
+    if True == args.show_peer_offsets:
+        args.show_peer_offsets = []
+    elif 0 < len(args.peer_offsets):
+        args.show_peer_offsets = args.peer_offsets.split(",")
+    else:
+        args.show_peer_offsets = None
+
+    if True == args.show_peer_jitters:
+        args.show_peer_jitters = []
+    elif 0 < len(args.peer_jitters):
+        args.show_peer_jitters = args.peer_jitters.split(",")
+    else:
+        args.show_peer_jitters = None
+
+    if 0 < args.debug_level:
+        sys.stderr.write("ntpviz: INFO: now running at debug: %s\n" % \
+            args.debug_level)
+        sys.stderr.write("ntpviz: INFO: Version: %s\n" % version)
+        sys.stderr.write("ntpviz: INFO: Parsed Options %s\n" % args)
+
+        if 9 == args.debug_level:
+            # crazy debug, also profile
+            import cProfile, pstats
+            pr = cProfile.Profile()
+            pr.enable()
+
+            # register to dump debug on all normal exits
+            atexit.register( print_profile )
+
+    nice = 19       # always run nicely
+    if 0 != nice:
+        try:
+            import psutil
+            # set ionice() to idle
+            p = psutil.Process(os.getpid())
+            p.ionice(psutil.IOPRIO_CLASS_IDLE)
+
+        except ImportError:
+            if 0 < args.debug_level:
+                sys.stderr.write("ntpviz: INFO: psutils not found\n")
+            pass
+
+        # set nice()
+        nice = os.nice( nice )
+        if 2 < args.debug_level:
+            sys.stderr.write("ntpviz: INFO: now running at nice: %s\n" % \
+                nice)
+
+    for fontpath in ("/usr/share/fonts/liberation",
+                     "/usr/share/fonts/liberation-fonts",
+                     "/usr/share/fonts/truetype/liberation"):
+
+        if os.path.exists(fontpath):
+            os.environ["GDFONTPATH"] = fontpath
+            break
+    else:
+        sys.stderr.write("ntpviz: WARNING: liberation truetype fonts not found\n")
+    os.environ["GNUPLOT_DEFAULT_GDFONT"] = "LiberationSans-Regular"
+
+    plot = None
+
+    if 1 == len(args.statsdirs):
+        statlist = [NTPViz(statsdir=args.statsdirs[0], sitename=args.sitename,
+                        period=args.period, starttime=args.starttime,
+                        endtime=args.endtime)]
+    else:
+        statlist = [NTPViz(statsdir=d, sitename=d,
+                        period=args.period, starttime=args.starttime,
+                        endtime=args.endtime)
+                for d in args.statsdirs]
+
+    if len(statlist) == 1:
+        stats = statlist[0]
+
+        if args.show_local_offset or \
+           args.show_local_error or \
+           args.show_local_jitter or \
+           args.show_local_stability or \
+           args.show_local_offset_histogram:
+            if not len( stats.loopstats ):
+                sys.stderr.write("ntpviz: ERROR: missing loopstats data\n")
+                raise SystemExit(1)
+
+            if args.show_local_offset:
+                plot = stats.local_offset_gnuplot()
+            elif args.show_local_error:
+                plot = stats.local_error_gnuplot()
+            elif args.show_local_jitter:
+                plot = stats.local_offset_jitter_gnuplot()
+            elif args.show_local_stability:
+                plot = stats.local_offset_stability_gnuplot()
+            elif args.show_local_offset_histogram:
+                plot = stats.local_offset_histogram_gnuplot()
+
+        if None != args.show_peer_offsets or \
+           None != args.show_peer_jitters:
+            if not len( stats.peerstats ):
+                sys.stderr.write("ntpviz: ERROR:  missing peerstats data\n")
+                raise SystemExit(1)
+            if None != args.show_peer_offsets:
+                plot = stats.peer_offsets_gnuplot(args.show_peer_offsets)
+            if None != args.show_peer_jitters:
+                plot = stats.peer_jitters_gnuplot(args.show_peer_jitters)
+
+        if args.show_freq_temps:
+            if not len( stats.temps):
+                sys.stderr.write("ntpviz: ERROR: missing temps data\n")
+                raise SystemExit(1)
+            plot = stats.local_freq_temps_plot()
+
+        if args.show_temps:
+            if not len( stats.temps):
+                sys.stderr.write("ntpviz: ERROR: missing temps data\n")
+                raise SystemExit(1)
+            plot = stats.local_temps_gnuplot()
+
+        if args.show_gps:
+            if not len( stats.gpsd):
+                sys.stderr.write("ntpviz: ERROR: missing gps data\n")
+                raise SystemExit(1)
+            plot = stats.local_gps_gnuplot()
+
+    if args.show_local_offset_multiplot:
+        plot = local_offset_multiplot(statlist)
+
+    if None != plot:
+        # finish up the plot, and exit
+        if args.generate:
+            gnuplot(plot['plot'])
+        else:
+            sys.stdout.write(plot['plot'])
+        raise SystemExit(0)
+
+    # Fall through to HTML code generation
+    if not os.path.isdir(args.outdir):
+        try:
+            os.mkdir(args.outdir)
+        except SystemError:
+            sys.stderr.write("ntpviz: ERROR: %s can't be created.\n" \
+                 % args.outdir)
+            raise SystemExit(1)
+
+    # if no ntpsec favicon.ico, write one.
+    ico_filename = os.path.join(args.outdir, "favicon.ico")
+    if not os.path.lexists( ico_filename ):
+        with open( ico_filename, "w" ) as wp:
+            wp.write(binascii.a2b_base64(ntpsec_ico))
+
+    # if no ntpsec logo, write one.
+    logo_filename = os.path.join(args.outdir, "ntpsec-logo.png")
+    if not os.path.lexists( logo_filename ):
+        with open( logo_filename, "w" ) as wp:
+            wp.write(binascii.a2b_base64(ntpsec_logo))
+
+    report_time = datetime.datetime.utcnow() # the time now is...
+    report_time = report_time.strftime("%c") # format it nicely
+
+    title = args.sitename
+
+    index_header = '''\
+<!DOCTYPE html>
+<html lang="en">
+<head>
+<link rel="shortcut icon" href="favicon.ico">
+<meta charset="UTF-8">
+<meta http-equiv="refresh" content="1800">
+<meta name="expires" content="0">
+<title>%(title)s</title>
+<style>
+dt {
+    font-weight: bold;
+    margin-left: 20px;
+}
+dd {
+    margin-top: 4px;
+    margin-bottom: 10px;
+}
+</style>
+</head>
+<body>
+<div style="width:910px">
+<a href='https://www.ntpsec.org/'>
+<img src="ntpsec-logo.png" alt="NTPsec" style="float:left;margin:20px 70px;">
+</a>
+<div>
+<h1 style="margin-bottom:10px;">%(title)s</h1>
+<b>Report generated:</b> %(report_time)s UTC <br>
+''' % locals()
+
+    # Ugh.  Not clear what to do in the multiplot case
+    if len(statlist) == 1:
+        start_time = datetime.datetime.utcfromtimestamp( stats.starttime
+                         ).strftime('%c')
+        end_time = datetime.datetime.utcfromtimestamp( stats.endtime
+                         ).strftime('%c')
+
+        index_header += '<b>Start Time:</b> %s UTC<br>\n' \
+                        '<b>End Time:</b> %s UTC<br>\n' \
+                 % (start_time, end_time)
+        index_header += '<b>Report Period:</b> %1.1f days <br>\n' \
+                 % (float(stats.period) / \
+                     float(ntp.statfiles.NTPStats.SecondsInDay))
+
+    if args.clip:
+        index_header += """\
+<span style="color:red;font-weight:bold;">Warning: plots clipped</span><br>
+"""
+
+    index_header += '</div>\n<div style="clear:both;"></div>'
+
+    index_trailer = '''\
+<h2>Glossary:</h2>
+
+<dl>
+<dt>frequency offset:</dt>
+<dd>The difference between the ntpd calculated frequency and the local
+system clock frequency (usually in parts per million, ppm)</dd>
+
+<dt>jitter, dispersion:</dt>
+<dd>The short term change in a value</dd>
+
+<dt>ms, millisecond:</dt>
+<dd>One thousandth of a second = 0.001s</dd>
+
+<dt>mu, mean:</dt>
+<dd>The arithmetic mean: the sum of all the values divided by the
+number of values.</dd>
+
+<dt>ns, nanosecond:</dt>
+<dd>One billionth of a second, also one thousandth of a microsecond,
+0.000000001s.</dd>
+
+<dt>percentile:</dt>
+<dd>The value below which a given percentage of values fall.</dd>
+
+<dt>ppb, parts per billion:</dt>
+<dd>Ratio between two values. These following are all the same:
+    1 ppb, one in one billion, 1/1,000,000,000, 0.000,000,001, and
+    0.000,000,1%</dd>
+
+<dt>ppm, parts per million:</dt>
+<dd>Ratio between two values. These following are all the same:
+    1 ppm, one in one million, 1/1,000,000, 0.000,001, and 0.000,1%</dd>
+
+<dt>ppt, parts per thousand:</dt>
+<dd>Ratio between two values. These following are all the same:
+    1 ppt, one in one thousand, 1/1,000, 0.001, and 0.1%</dd>
+
+<dt>refclock:</dt>
+<dd>Reference clock, a local GPS module or other local source of time.</dd>
+
+<dt>remote clock:</dt>
+<dd>Any clock reached over the network, LAN or WAN.  Also called a peer
+or server.</dd>
+
+<dt>time offset:</dt>
+<dd>The difference between the ntpd calculated time and the local system
+ clock's time.  (Also can be called phase offset)</dd>
+
+<dt>upstream clock:</dt>
+<dd>Any remote clock or reference clock used as a source of time.</dd>
+
+<dt>σ, sigma:</dt>
+<dd>Sigma denotes the standard deviation (SD) and is centered on the
+arithmetic mean of the data set. The SD is simply the square root of
+the variance of the data set.  Two sigma is simply twice the standard
+deviation.  Three sigma is three times sigma.  Smaller is better.</dd>
+
+<dt>µs, us, microsecond:</dt>
+<dd>One millionth of a second, also one thousandth of a millisecond,
+0.000,001s.</dd>
+</dl>
+
+<br>
+<br>
+<br>
+<div style="float:left">
+This page autogenerated by <a href="https://docs.ntpsec.org/latest/ntpviz.html">
+ntpviz</a>, part of the <a href="https://www.ntpsec.org/">NTPsec project</a>
+</div>
+<div style="float:left;margin-left:350px;">
+    <a href="https://validator.w3.org/nu/">
+    <img src="https://www.w3.org/html/logo/downloads/HTML5_Logo_32.png"
+        alt="html 5">
+    </a>
+&nbsp;&nbsp;
+    <a href="https://jigsaw.w3.org/css-validator/check/referer">
+        <img style="border:0;width:88px;height:31px"
+            src="https://jigsaw.w3.org/css-validator/images/vcss"
+            alt="Valid CSS!" />
+    </a>
+</div>
+<div style="clear:both;"></div>
+</div>
+</body>
+</html>
+'''
+    imagewrapper = "<img src='%s.png' alt='%s plot'>\n"
+
+    # buffer the index.html output so the index.html is not empty
+    # during the run
+    index_buffer = index_header
+    # if header file, add it to index.html
+    header = os.path.join(args.outdir, "header")
+    if os.path.isfile(header):
+        try:
+            header_file = open( header, 'r')
+            header_txt = header_file.read()
+            index_buffer += '<br>\n' + header_txt + '\n'
+        except IOError:
+            pass
+
+    if len(statlist) > 1:
+        index_buffer += local_offset_multiplot(statlist)
+    else:
+        # imagepairs in the order of the heml entries
+        imagepairs = [
+            ("local-offset", stats.local_offset_gnuplot()),
+            # skipa next one, redundant to one above
+            #("local-error", stats.local_error_gnuplot()),
+            ("local-jitter", stats.local_offset_jitter_gnuplot()),
+            ("local-stability", stats.local_offset_stability_gnuplot()),
+            ("local-offset-histogram", stats.local_offset_histogram_gnuplot()),
+            ("local-temps", stats.local_temps_gnuplot()),
+            ("local-freq-temps", stats.local_freq_temps_plot()),
+            ("local-gps", stats.local_gps_gnuplot()),
+            ("peer-offsets", stats.peer_offsets_gnuplot()),
+        ]
+
+        peerlist = stats.peersplit().keys()
+        # sort for output order stability
+        peerlist.sort()
+        for key in peerlist:
+            imagepairs.append(("peer-offset-" + key,
+                           stats.peer_offsets_gnuplot([key])))
+
+        imagepairs.append(("peer-jitters",
+                           stats.peer_jitters_gnuplot()))
+        for key in peerlist:
+            imagepairs.append(("peer-jitter-" + key,
+                           stats.peer_jitters_gnuplot([key])))
+
+        stats = []
+        for (imagename, image) in imagepairs:
+            if not image:
+                continue
+            if 1 <= args.debug_level:
+                sys.stderr.write("ntpviz: plotting %s\n" % image['title'])
+            stats.append( image['stats'] )
+            # give each H2 an unique ID.
+            id = image['title'].lower()
+            id = id.replace(' ', '_').replace(':', '_')
+            index_buffer += """\
+<div>\n<h2 id="%s">%s:</h2>
+""" % (id, image['title'])
+
+            div_name = imagename.replace('-', ' ')
+            index_buffer += imagewrapper % \
+                             (imagename.replace(':', '%3A'), div_name)
+            if image['html']:
+                index_buffer += "<div>\n%s</div>\n" % image['html']
+            index_buffer += "<br><br>\n"
+            gnuplot(image['plot'], os.path.join(args.outdir, imagename + ".png"))
+            index_buffer += "</div>\n"
+
+    # dump stats
+    csvs = []
+    if True:
+        index_buffer += '<div id="Summary"><h2>Summary</h2>\n'
+        index_buffer += VizStats.table_head
+        for stat in stats:
+            if [] == stat:
+                continue
+            for sta in stat:
+                index_buffer += str( sta.table )
+                csvs.append(sta.csv)
+        # RFC 4180 specifies the mime-type of a csv
+        # your webserver should be programmed the same
+        index_buffer += """\
+</table>
+<a href="summary.csv" target="_blank"
+  type="text/csv;charset=UTF-8;header=present;">Summary as CSV file</a><br>
+</div>
+"""
+
+    # if footer file, add it to index.html
+    footer = os.path.join(args.outdir, "footer")
+    if os.path.isfile(footer):
+        try:
+            footer_file = open( footer, 'r')
+            footer_txt = footer_file.read()
+            index_buffer += '<br>\n' + footer_txt + '\n'
+        except IOError:
+            pass
+    index_buffer += index_trailer
+
+    # and send the file buffer
+    index_filename = os.path.join(args.outdir, "index.html")
+    with open(index_filename + ".tmp", "wb") as ifile:
+        ifile.write(index_buffer)
+
+    # create csv file, as a tmp file
+    csv_filename = os.path.join(args.outdir, "summary.csv")
+    with open( csv_filename + ".tmp", "wb" ) as csv_file:
+        csv_ob = csv.writer(csv_file)
+        csv_ob.writerow(VizStats.csv_head)
+        for row in csvs:
+            csv_ob.writerow(row)
+
+    # move new index and summary into place
+    # windows python 2.7, 3.6 has no working rename, so delete and move
+    try:
+        os.remove(csv_filename)
+        os.remove( index_filename)
+    except:
+        pass
+
+    os.rename( csv_filename + ".tmp", csv_filename)
+    os.rename( index_filename + ".tmp", index_filename)
+
+
+# end
diff --git a/ntpclients/ntpviz-man.txt b/ntpclients/ntpviz-man.txt
new file mode 100644
index 0000000..a891da1
--- /dev/null
+++ b/ntpclients/ntpviz-man.txt
@@ -0,0 +1,21 @@
+= ntpviz(1) =
+:doctype: manpage
+
+== NAME ==
+ntpviz - make visualizations of offset, jitter, etc. from stats file data
+
+include::../docs/includes/ntpviz-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0::
+  Successful program execution.
+1::
+  The operation failed, usually due to a missing logfile required for
+  a plot.
+2::
+  Illegal command-line option.
+
+// end
diff --git a/ntpclients/ntpwait b/ntpclients/ntpwait
new file mode 100755
index 0000000..22da0b8
--- /dev/null
+++ b/ntpclients/ntpwait
@@ -0,0 +1,200 @@
+#!/usr/bin/env python
+"""\
+ntpwait - Wait for ntpd to stabilize the system clock.
+USAGE: ntpwait [-n tries] [-s sleeptime] [-v] [-h]
+
+    -n, --tries=num              Number of times to check ntpd
+    -s, --sleep=num              How long to sleep between tries
+    -v, --verbose                Be verbose
+    -h, --help                   Issue help
+
+Options are specified by doubled hyphens and their name or by a single
+hyphen and the flag character.
+
+A spurious 'not running' message can result from queries being disabled.
+"""
+#SPDX-License-Identifier: BSD-2-Clause
+from __future__ import print_function, division
+
+import sys, getopt, re, time
+import socket
+import ntp.magic
+import ntp.packet
+
+# General notes on Python 2/3 compatibility:
+#
+# This code uses the following strategy to allow it to run on both Python 2
+# and Python 3:
+#
+# - Use binary I/O to read/write data from/to files and subprocesses;
+#   where the exact bytes are important (such as in checking for
+#   modified files), use the binary data directly
+#
+# - Use latin-1 encoding to transform binary data to/from Unicode when
+#   necessary for operations where Python 3 expects Unicode; the
+#   polystr and polybytes functions are used to do this so that
+#   when running on Python 2, the byte string data is used unchanged;
+#   also, the make_wrapper function constructs a text stream that can
+#   wrap a file opened in binary mode for cases where a file object
+#   that can be passed around from function to function is needed
+#
+# - Construct custom stdin, stdout, and stderr streams when running
+#   on Python 3 that force latin-1 encoding, and wrap them around the
+#   underlying binary buffers (in Python 2, the streams are binary
+#   and are used unchanged); this ensures that the same transformation
+#   is done on data from/to the standard streams, as is done on binary
+#   data from/to files and subprocesses; the make_std_wrapper function
+#   does this
+
+master_encoding = 'latin-1'
+
+if str is bytes:  # Python 2
+    polystr = str
+    polybytes = bytes
+
+    def string_escape(s):
+        return s.decode('string_escape')
+
+    def make_wrapper(fp):
+        return fp
+
+else:  # Python 3
+    import io
+
+    def polystr(o):
+        "Polymorphic string factory function"
+        if isinstance(o, str):
+            return o
+        if not isinstance(o, bytes):
+            return str(o)
+        return str(o, encoding=master_encoding)
+
+    def polybytes(s):
+        "Polymorphic string encoding function"
+        if isinstance(s, bytes):
+            return s
+        if not isinstance(s, str):
+            return bytes(s)
+        return bytes(s, encoding=master_encoding)
+
+    def string_escape(s):
+        "Polymorphic string_escape/unicode_escape"
+        # This hack is necessary because Unicode strings in Python 3 don't
+        # have a decode method, so there's no simple way to ask it for the
+        # equivalent of decode('string_escape') in Python 2. This function
+        # assumes that it will be called with a Python 3 'str' instance
+        return s.encode(master_encoding).decode('unicode_escape')
+
+    def make_wrapper(fp):
+        "Wrapper factory function to enforce master encoding"
+        # This can be used to wrap normally binary streams for API
+        # compatibility with functions that need a text stream in
+        # Python 3; it ensures that the binary bytes are decoded using
+        # the master encoding we use to turn bytes to Unicode in
+        # polystr above
+        # newline="\n" ensures that Python 3 won't mangle line breaks
+        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")
+
+    def make_std_wrapper(stream):
+        "Standard input/output wrapper factory function"
+        # This ensures that the encoding of standard output and standard
+        # error on Python 3 matches the master encoding we use to turn
+        # bytes to Unicode in polystr above
+        # line_buffering=True ensures that interactive command sessions work as expected
+        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)
+
+    sys.stdin = make_std_wrapper(sys.stdin)
+    sys.stdout = make_std_wrapper(sys.stdout)
+    sys.stderr = make_std_wrapper(sys.stderr)
+
+class Unbuffered(object):
+    def __init__(self, stream):
+        self.stream = stream
+
+    def write(self, data):
+        self.stream.write(data)
+        self.stream.flush()
+
+    def __getattr__(self, attr):
+        return getattr(self.stream, attr)
+
+if __name__ == "__main__":
+    try:
+        (options, arguments) = getopt.getopt(sys.argv[1:], "hn:s:v", [
+            "tries=", "sleep=", "verbose", "help"
+        ])
+    except getopt.GetoptError as err:
+        sys.stderr.write(str(err) + "\n")
+        raise SystemExit(2)
+    tries = 100
+    sleep = 6
+    verbose = 0
+    for (switch, val) in options:
+        if switch in ("-n", "--tries"):
+            tries = int(val)
+        elif switch in ("-s", "--sleep"):
+            sleep = int(val)
+        elif switch in ("-v", "--verbose"):
+            verbose += 1
+        elif switch in ("-h", "--help"):
+            sys.stdout.write(__doc__)
+            raise SystemExit(0)
+
+    # Autoflush stdout
+    sys.stdout = Unbuffered(sys.stdout)
+
+    if verbose:
+        sys.stdout.write("Waiting for ntpd to synchronize...  ")
+
+    for i in range(1, tries):
+        session = ntp.packet.ControlSession()
+        #session.debug = 4
+        if not session.openhost("localhost"):
+            if verbose:
+                sys.stdout.write("\bntpd is not running!\n")
+            continue
+
+        try:
+            msg = session.doquery(2)	# Request system variables
+        except socket.error:
+            if verbose:
+                sys.stdout.write("\b" + "*+:."[i % 4])
+            time.sleep(sleep)
+            continue
+
+        if verbose >= 2:
+            sys.stderr.write(repr(session.response) + "\n")
+
+        if msg and msg.startswith("***"):
+            if verbose:
+                sys.stdout.write("\b" + msg + "\n")
+            sys.exit(1)
+
+        m = re.search(r"leap=([^,]*),", session.response)
+        if m:
+            leap = int(m.group(1))
+        else:
+            sys.stdout.write("\bLeap status not available\n")
+            sys.exit(1)
+
+        if leap == ntp.magic.LEAP_NOTINSYNC:
+            if verbose:
+                sys.stdout.write("\b" + "*+:."[i % 4])
+            if i < tries:
+                time.sleep(sleep)
+            continue
+
+        if leap in (ntp.magic.LEAP_NOWARNING, ntp.magic.LEAP_ADDSECOND, ntp.magic.LEAP_DELSECOND):
+            # We could check "sync" here to make sure we like the source...
+            if verbose:
+                sys.stdout.write("\bOK!\n")
+            sys.exit(0)
+
+        sys.stdout.write("\bUnexpected 'leap' status <%s>\n" % leap)
+        sys.exit(1)
+
+    if verbose:
+        sys.stdout.write("\bNo!\nntpd did not synchronize.\n")
+    sys.exit(1)
+
+# end
diff --git a/ntpclients/ntpwait-man.txt b/ntpclients/ntpwait-man.txt
new file mode 100644
index 0000000..7ffb6bb
--- /dev/null
+++ b/ntpclients/ntpwait-man.txt
@@ -0,0 +1,19 @@
+= ntpwait(8) =
+:doctype: manpage
+
+== NAME ==
+ntpwait - Wait for ntpd to stabilize the system clock
+
+include::../docs/includes/ntpwait-body.txt[]
+
+== EXIT STATUS ==
+
+One of the following exit values will be returned:
+
+0 (EXIT_SUCCESS)::
+  Successful program execution.
+1 (EXIT_FAILURE)::
+  The operation failed or the command syntax was not valid.
+
+// end
+
diff --git a/ntpdig/ntpdig b/ntpdig/ntpdig
deleted file mode 100755
index d19e3ec..0000000
--- a/ntpdig/ntpdig
+++ /dev/null
@@ -1,408 +0,0 @@
-#!/usr/bin/python
-"""
-ntpdig - simple SNTP client
-
-"""
-# SPDX-License-Identifier: BSD-2-clause
-# This code runs identically under Python 2 and Python 3. Keep it that way!
-from __future__ import print_function, division
-
-# This code is somewhat stripped down from the legacy C version.  It
-# does however have one additional major feature; it can filter
-# out falsetickers from multiple samples, like the ntpdate of old,
-# rather than just taking the first reply it gets.
-#
-# Listening to broadcast addresses is not implemented because that is
-# impossible to secure. KOD recording is also not implemented, as it
-# can too easily be spammed.  Thus, the options -b and -K are not
-# implemented.
-#
-# There are no version 3 NTP servers left, so the -o version for setting
-# NTP version has been omitted.
-#
-# Because ntpdig doesn't use symmetric-peer mode (it never did, and NTPsec has
-# abolished that mode because it was a security hazard), there's no need to
-# set the packet source port, so -r/--usereservedport has been dropped.
-# If this option ever needs to be reinstated, the magic is described here:
-# http://stackoverflow.com/questions/2694212/socket-set-source-port-number
-# and would be s.bind(('', 123)) right after the socket creation.
-#
-# The -w/--wait and -W/--nowait options only made sense with asynchronous
-# DNS.  Asynchronous DNS was absurd overkill for this application, we are
-# not looking up 20,000 hosts here.  It has not been implemented, so neither
-# have these options.
-#
-# Finally, logging to syslog by default was a design error, violating
-# Unix principles, that has been fixed. To get this behavior when
-# running in a script, redirect standard error to logger(1). 
-#
-# The one new option in this version is -p, borrowed from ntpdate.
-
-import sys, socket, select, struct, time, getopt, datetime, math
-
-try:
-    import ntp.packet
-    import ntp.util
-    import ntp.magic
-except:
-    sys.stderr.write("ntpdig: can't find Python NTP library -- check PYTHONPATH.\n")
-    sys.exit(1)
-
-def queryhost(server, concurrent, timeout=5, port=123):
-    "Query IP addresses associated with a specified host."
-    try:
-        iptuples = socket.getaddrinfo(server, port,
-                                      af, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
-    except socket.gaierror as e:
-        log("lookup of %s failed, errno %d = %s" % (server, e[0], e[1]))
-        return []
-    sockets = []
-    packets = []
-    request = ntp.packet.SyncPacket()
-    request.transmit_timestamp = ntp.packet.SyncPacket.posix_to_ntp(time.time())
-    packet = request.flatten()
-    for (family, socktype, proto, canonname, sockaddr) in iptuples:
-        if debug:
-            log("querying %s (%s)" % (sockaddr[0], server))
-        s = socket.socket(family, socktype)
-        if keyid and keytype and passwd:
-            if debug:
-                log("authenticating with %s key %d" % (keytype, keyid))
-            mac = ntp.packet.Authenticator.compute_mac(packet,
-                                                       keyid, keytype, passwd)
-            if mac is None:
-                log("MAC generation failed while querying %s" % server)
-                raise SystemExit(1)
-            else:
-                packet += mac
-        try:
-            s.sendto(packet, sockaddr)
-        except socket.error as e:
-            log("socket error on transmission: %s" % e)
-            raise SystemExit(1)
-        if debug >= 2:
-            log("Sent to %s:" % (sockaddr[0],))
-            ntp.packet.dump_hex_printable(packet)
-        def read_append(s, packets):
-            d, a = s.recvfrom(1024)
-            if debug >= 2:
-                ntp.packet.dump_hex_printable(d)
-            if credentials:
-                if not ntp.packet.Authenticator.have_mac(d):
-                    if debug:
-                        log("no MAC on reply from %s" % packet.hostname)
-                if not credentials.verify_mac(d):
-                    packet.trusted = False
-                    log("MAC verification on reply from %s failed" % sockaddr[0])
-                elif debug:
-                    log("MAC verification on reply from %s succeeded" % sockaddr[0])
-            pkt = ntp.packet.SyncPacket(d)
-            pkt.hostname = server
-            pkt.resolved = sockaddr[0]
-            packets.append(pkt)
-            time.sleep(gap)
-        if concurrent:
-            sockets.append(s)
-        else:
-            r, _, _ = select.select([s], [], [], timeout)
-            if not r:
-                return []
-            read_append(s, packets)
-    if concurrent:
-        while sockets:
-            r, _, _ = select.select(sockets, [], [], timeout)
-            if not r:
-                return packets
-            for s in sockets:
-                read_append(s, packets)
-                sockets.remove(s)
-    return packets
-
-def clock_select(packets):
-    "Select the pick-of-the-litter clock from the samples we've got."
-    # This is a slightly simplified version of the filter ntpdate used
-    NTP_INFIN     = 15		# max stratum, infinity a la Bellman-Ford 
-    NTP_MAXAGE    = 86400	# one day in seconds
-
-    # This first chunk of code is supposed to go through all
-    # servers we know about to find the servers that
-    # are most likely to succeed. We run through the list
-    # doing the sanity checks and trying to insert anyone who
-    # looks okay. We are at all times aware that we should
-    # only keep samples from the top two strata.
-    # 
-    nlist = 0	# none yet
-    filtered = []
-    for response in packets:
-        def drop(msg):
-            log("%s: Response dropped: %s" % (response.hostname, msg))
-        if response.stratum > NTP_INFIN:
-            drop("stratum too high")
-            continue
-        if response.version() < ntp.magic.NTP_OLDVERSION:
-            drop("response version %d is too old" % response.version())
-            continue
-        if response.mode() != ntp.magic.MODE_SERVER:
-            drop("unexpected response mode %d" % response.mode())
-            continue
-        if response.version() > ntp.magic.NTP_VERSION:
-            drop("response version %d is too new" % response.version())
-            continue
-        if response.stratum == 0:
-            # FIXME: Do some kind of semi-useful diagnostic dump here
-            drop("stratum 0, probable KOD packet")
-            continue
-        if response.leap() == "unsync":
-            drop("leap not in sync")
-            continue
-        if not response.trusted:
-            drop("request was authenticated but server is untrusted")
-            continue
-        # Bypass this test if we ever support broadcast-client mode again 
-        if response.origin_timestamp == 0:
-            drop("unexpected response timestamp")
-            continue
-        filtered.append(response)
-
-    if len(filtered) <= 1:
-        return filtered
-
-    # Sort by stratum and other figures of merit
-    filtered.sort(key=lambda s: (s.stratum, s.synchd(), s.root_delay))
-
-    # Return the best
-    return filtered[:1]
-
-def report(packet, json):
-    "Report on the SNTP packet selected for display, and its adjustment."
-    say = sys.stdout.write
-
-    packet.posixize()
-
-    # Cheesy way to get local timezone offset
-    gmt_time = int(time.time())
-    local_time = int(time.mktime(time.gmtime(gmt_time)))
-    tmoffset = (local_time - gmt_time) // 60	# In minutes
-
-    # The server's idea of the time
-    t = time.localtime(int(packet.transmit_timestamp))
-    ms = int(packet.transmit_timestamp * 1000000) % 1000000
-
-    # Number of decimal digits of precision indicated by the precision field
-    digits = min(6, -int(math.log10(2**packet.precision)))
-
-    date = time.strftime("%Y-%m-%d", t)
-    tod = time.strftime("%T", t) + (".%*d" % (digits, ms))
-    sgn = ("%+d" % tmoffset)[0]
-    tz = "%s%02d%02d" % (sgn, tmoffset // 60, tmoffset % 60)
-
-    if json:
-        say('{"time":"%sT%s%s","offset":%f,"precision":%f,"host":"%s",ip:"%s","stratum":%s,"leap":"%s","adjusted":%s}\n' % \
-            (date, tod, tz,
-             packet.adjust(), packet.synchd(),
-             packet.hostname, packet.resolved or packet.hostname,
-             packet.stratum, packet.leap(),
-             "true" if adjusted else "false"))
-    else:
-        say("%s %s (%s) %+f +/- %f %s" % \
-            (date, tod, tz,
-             packet.adjust(), packet.synchd(),
-             packet.hostname))
-        if packet.resolved and packet.resolved != packet.hostname:
-            say(" " + packet.resolved)
-        say(" s%d %s\n" % (packet.stratum, packet.leap()))
-
-usage = """
-USAGE:  sntp [ -<flag> [<val>] | --<name>[{=| }<val>] ]...
-		[ hostname-or-IP ...]
-  Flg Arg Option-Name     Description
-   -4 no  ipv4           Force IPv4 DNS name resolution
-				- prohibits the option 'ipv6'
-   -6 no  ipv6           Force IPv6 DNS name resolution
-				- prohibits the option 'ipv4'
-   -a Num authentication  Enable authentication with the numbered key
-   -c yes concurrent      Hosts to be queried concurrently
-   -d no  debug           Increase debug verbosity
-   -D yes set-debug-level Set debug verbosity
-   -g yes gap             Set gap between requests
-   -j no  json            Use JSON output format
-   -l Str logfile         Log to specified logfile
-				 - prohibits the option 'syslog'
-   -p yes samples         Number of samples to take (default 1) 
-   -S no  step            Set (step) the time with clock_settime()
-				 - prohibits the option 'step'
-   -s no  slew            Set (slew) the time with adjtime()
-				 - prohibits the option 'slew'
-   -t Num timeout         Request timeout in seconds (default 5)
-   -k Str keyfile         Specify a keyfile. SNTP will look in this file
-                          for the key specified with -a
-   -V no version          Output version information and exit
-   -h no  help            Display extended usage information and exit
-"""
-
-if __name__ == '__main__':
-    try:
-        (options, arguments) = getopt.getopt(sys.argv[1:],
-                                             "46a:c:dD:g:hjk:l:M:o:p:r:Sst:wWV",
-                                             ["ipv4","ipv6",
-                                              "authentication=",
-                                              "concurrent=",
-                                              "gap=", "help", "json",
-                                              "keyfile=", "logfile=",
-                                              "replay=",
-                                              "samples=", "steplimit=",
-                                              "step", "slew",
-                                              "timeout=",
-                                              "debug", "set-debug-level=",
-                                              "version"])
-    except getopt.GetoptError as e:
-        print(e)
-        raise SystemExit(1)
-    progname = sys.argv[0]
-
-    logfp = sys.stderr
-    log = lambda m: logfp.write("ntpdig: %s\n" % m)
-
-    af = socket.AF_UNSPEC
-    authkey = None
-    concurrent_hosts = []
-    debug = 0
-    gap = 50
-    json = False
-    keyfile = None
-    steplimit = 0	# Default is intentionally zero
-    samples = 1
-    step = False
-    slew = False
-    timeout = 5
-    replay = None
-    try:
-        for (switch, val) in options:
-            if switch in ("-4", "--ipv4"):
-                af = socket.AF_INET
-            elif switch in ("-6", "--ipv6"):
-                af = socket.AF_INET6
-            elif switch in ("-a", "--authentication"):
-                authkey = int(val)
-            elif switch in ("-c", "--concurrent"):
-                concurrent_hosts.append(val)
-            elif switch in ("-d", "--debug"):
-                debug += 1
-            elif switch in ("-D", "--set-debug-level"):
-                debug = int(val)
-            elif switch in ("-j", "--json"):
-                json = True
-            elif switch in ("-k", "--keyfile"):
-                keyfile = val
-            elif switch in ("-l", "--logfile"):
-                try:
-                    logfp = open(val, "w")
-                except OSError:
-                    sys.stderr.write("logfile open of %s failed.\n" % val)
-                    raise SystemExit(1)
-            elif switch in ("-M", "--steplimit"):
-                steplimit = int(val)
-            elif switch in ("-p", "--samples"):
-                samples = int(val)
-            elif switch in ('-r', "--replay"):
-                replay = val
-            elif switch in ("-S", "--step"):
-                step = True
-            elif switch in ("-s", "--slew"):
-                slew = True
-            elif switch in ("-t", "--timeout"):
-                timeout = int(val)
-            elif switch in ("-h", "--help"):
-                print(usage)
-                raise SystemExit(0)
-            elif switch in ("-V", "--version"):
-                print(ntp.util.stdversion())
-                raise SystemExit(0)
-            else:
-                sys.stderr.write("Unknown command line switch or missing argument.\n")
-                sys.stderr.write(usage)
-                raise SystemExit(1)
-    except ValueError:
-        sys.stderr.write("Invalid argument.\n")
-        sys.stderr.write(usage)
-        raise SystemExit(1)
-
-    credentials = keyid = keytype = passwd = None
-    try:
-        credentials = ntp.packet.Authenticator(keyfile)
-    except (OSError, IOError):
-        pass
-    if credentials:
-        try:
-            (keyid, keytype, passwd) = credentials.control(authkey)
-        except ValueError:
-            # There are no trusted keys.  Barf.
-            log("cannot get authentication key")
-            raise SystemExit(1)
-
-    if not credentials and authkey and keyfile is None:
-        self.warn("-a option requires -k.\n")
-        raise SystemExit(1)
-
-    gap /= 1000	# Scale gap to milliseconds
-
-    if not arguments:
-        arguments = ["localhost"]
-
-    if replay:
-        (pkt, dst) = replay.split(":")
-        packet = ntp.packet.SyncPacket(pkt.decode("hex"))
-        packet.received = ntp.packet.SyncPacket.posix_to_ntp(float(dst))
-        returned = [packet]
-    else:
-        returned = []
-        for server in concurrent_hosts:
-            try:
-                returned += queryhost(server=server, concurrent=True, timeout=timeout)
-            except ntp.packet.SyncException as e:
-                log(e.message)
-                continue
-            if len(returned) >= samples:
-                break
-        for server in arguments:
-            try:
-                returned += queryhost(server=server, concurrent=False, timeout=timeout)
-            except ntp.packet.SyncException as e:
-                log(e.message)
-                continue
-            if len(returned) >= samples:
-                break
-        returned = clock_select(returned)
-
-    if returned:
-        pkt = returned[0]
-        if debug:
-            #print(repr(pkt))
-            def hexstamp(n):
-                return "%08x.%08x" % (n >> 32, n & 0x00000000ffffffff)
-            print("org t1: %s rec t2: %s" % (hexstamp(pkt.t1()), hexstamp(pkt.t2())))
-            print("xmt t3: %s dst t4: %s" % (hexstamp(pkt.t3()), hexstamp(pkt.t4())))
-            pkt.posixize()
-            print("org t1: %f rec t2: %f" % (pkt.t1(), pkt.t2()))
-            print("xmt t3: %f dst t4: %f" % (pkt.t3(), pkt.t4()))
-            print("rec-org t21: %f  xmt-dst t34: %f" % (pkt.t2() - pkt.t1(), pkt.t3() - pkt.t4()))
-        adjusted = step and (not slew or (slew and (abs(offset) > steplimit)))
-        report(pkt, json)
-	# If we can step but we cannot slew, then step.
-	# If we can step or slew and and |offset| > steplimit, then step.
-        rc = True
-        offset = pkt.adjust()
-        ntp.ntpc.setprogname("ntpdig")
-        if adjusted:
-		rc = ntp.ntpc.step_systime(offset)
-	elif slew:
-		rc = ntp.ntpc.adj_systime(offset)
-        if rc:
-            raise SystemExit(0)
-        else:
-            raise SystemExit(1)
-    else:
-        log("no eligible servers")
-        raise SystemExit(1)
-
-#end
diff --git a/ntpdig/ntpdig-man.txt b/ntpdig/ntpdig-man.txt
deleted file mode 100644
index bf46b36..0000000
--- a/ntpdig/ntpdig-man.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-= ntpdig(1) =
-:doctype: manpage
-
-== NAME ==
-ntpdig - standard Simple Network Time Protocol client program
-
-include::../docs/includes/ntpdig-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-
-// end
-
diff --git a/ntpkeygen/ntpkeygen b/ntpkeygen/ntpkeygen
deleted file mode 100755
index f0d8dd6..0000000
--- a/ntpkeygen/ntpkeygen
+++ /dev/null
@@ -1,88 +0,0 @@
-#!/usr/bin/env python
-#
-# ntpkeygen - program to generate cryptographic keys for ntp clients and servers
-# 
-# All file names are like "ntpkey_<type>_<hostname>.<filestamp>", where
-# <type> is the file type, <hostname> the generating host name and
-# <filestamp> the generation time in NTP seconds. The NTP programs
-# expect generic names such as "ntpkey_<type>_whimsy.udel.edu" with the
-# association maintained by soft links. Following is a list of file
-# types.
-# 
-# ntpkey_MD5key_<hostname>.<filestamp>
-# MD5 (128-bit) keys used to compute message digests in symmetric
-# key cryptography
-
-import os, sys, socket, random, time, getopt, stat
-
-#
-# Cryptodefines
-# 
-MD5KEYS	= 10	# number of keys generated of each type 
-MD5SIZE	= 20	# maximum key size 
-
-def gen_md5(id, groupname):
-    "Generate semi-random MD5 and SHA1 keys compatible with NTPv3 and NTPv4."
-    with fheader("MD5key", id, groupname) as wp:
-        for i in range(1, MD5KEYS+1):
-            md5key = ""
-            for j in range(MD5SIZE):
-                while True:
-                    r = randomizer.randint(0x21, 0x7e)
-                    if r != ord('#'):
-                        break
-                md5key += chr(r)
-            wp.write("%2d MD5 %s  # MD5 key\n" % (i,  md5key))
-        for i in range(1, MD5KEYS+1):
-            sha1key = ""
-            for j in range(MD5SIZE):
-                sha1key += "%02x" % randomizer.randint(0x00, 0xff)
-            wp.write("%2d SHA1 %s  # SHA1 key\n" % (i + MD5KEYS, sha1key))
-
-#
-# Generate file header and link
-# 
-def fheader(
-	file,	# file name id 
-	ulink,	# linkname 
-	owner	# owner name 
-        ):
-    try:
-	filename = "ntpkey_%s_%s.%u" % (file,  owner, int(time.time())) 
-        orig_umask = os.umask(stat.S_IWGRP | stat.S_IRWXO)
-        wp = open(filename, "w")
-        os.umask(orig_umask)
-
-        linkname = "ntp.keys"
-        if os.path.exists(linkname):
-            os.remove(linkname)		# The symlink() line below matters 
-	os.symlink(filename, linkname)
-
-	sys.stderr.write("Generating new %s file and link\n" % ulink)
-	sys.stderr.write("%s->%s\n" % (linkname, filename))
-	wp.write("# %s\n# %s\n" % (filename, time.ctime()))
-	return wp
-    except IOError:
-        sys.stderr.write("Key file creation or link failed.\n")
-        raise SystemExit(1)
-
-if __name__ == '__main__':
-    try:
-        (options, arguments) = getopt.getopt(sys.argv[1:], "hM:", ["help"])
-    except getopt.GetoptError as e:
-        print(e)
-        raise SystemExit(1)
-
-    for (switch, val) in options:
-        if switch == '-M':
-            # dummy MD5 option for backwards compatibility 
-            pass
-        elif switch in ("-h", "--help"):
-            print("usage: ntpkeygen [-M]")
-            raise SystemExit(0)
-
-    randomizer = random.SystemRandom(time.time() + os.getpid())
-    gen_md5("md5", socket.gethostname())
-    raise SystemExit(0)
-
-#end
diff --git a/ntpkeygen/ntpkeygen-man.txt b/ntpkeygen/ntpkeygen-man.txt
deleted file mode 100644
index 0bd86f9..0000000
--- a/ntpkeygen/ntpkeygen-man.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-= ntpkeygen(8) =
-:doctype: manpage
-
-== NAME ==
-ntpkeygen - create and manage NTP host keys
-
-include::../docs/includes/ntpkeygen-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-
-// end
-
diff --git a/ntpleapfetch/ntpleapfetch b/ntpleapfetch/ntpleapfetch
deleted file mode 100755
index 7d9868e..0000000
--- a/ntpleapfetch/ntpleapfetch
+++ /dev/null
@@ -1,430 +0,0 @@
-#!/bin/bash
-
-# Copyright (C) 2014 Timothe Litt litt at acm dot org
-#
-# SPDX-License-Identifier: BSD-2-clause
-#
-# Bugfixes and improvements would be appreciated by the author.
-
-VERSION="1.003"
-
-# leap-seconds file manager/updater
-
-# Depends on:
-#  wget sed, tr, shasum, logger
-
-# ########## Default configuration ##########
-#
-# Where to get the file
-LEAPSRC="ftp://time.nist.gov/pub/leap-seconds.list"
-
-# How many times to try to download new file
-MAXTRIES=6
-INTERVAL=10
-
-# Where to find ntp config file
-NTPCONF=/etc/ntp.conf
-
-# How long before expiration to get updated file
-PREFETCH="60 days"
-
-# How to restart NTP - older NTP: service ntpd? try-restart | condrestart
-# Recent NTP checks for new file daily, so there's nothing to do
-RESTART=
-
-# Where to put temporary copy before it's validated
-TMPFILE="/tmp/leap-seconds.$$.tmp"
-
-# Syslog facility
-LOGFAC=daemon
-# ###########################################
-
-# Places to look for commands.  Allows for CRON having path to
-# old utilities on embedded systems
-
-PATHLIST="/opt/sbin:/opt/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:"
-
-REQUIREDCMDS=" wget logger tr sed shasum"
-
-SELF="`basename $0`"
-
-function displayHelp {
-            cat <<EOF
-Usage: $SELF [options] [leapfile]
-
-Verifies and if necessary, updates leap-second definition file
-
-All arguments are optional:  Default (or current value) shown:
-    -s    Specify the URL of the master copy to download
-          $LEAPSRC
-    -4    Use only IPv4
-    -6    Use only IPv6
-    -p 4|6
-          Prefer IPv4 or IPv6 (as specified) addresses, but use either
-    -d    Specify the filename on the local system
-    -e    Specify how long before expiration the file is to be refreshed
-          Units are required, e.g. "-e 60 days"  Note that larger values
-          imply more frequent refreshes.
-          "$PREFETCH"
-    -f    Specify location of ntp.conf (used to make sure leapfile directive is
-          present and to default  leapfile)
-          $NTPCONF
-    -F    Force update even if current file is OK and not close to expiring.
-    -c    Command to restart NTP after installing a new file
-          <none> - ntpd checks file daily
-    -r    Specify number of times to retry on get failure
-          $MAXTRIES
-    -i    Specify number of minutes between retries
-          $INTERVAL
-    -l    Use syslog for output (Implied if CRONJOB is set)
-    -L    Don't use syslog for output
-    -P    Specify the syslog facility for logging
-          $LOGFAC
-    -t    Name of temporary file used in validation
-    -q    Only report errors to stdout
-    -v    Verbose output
-    -z    Specify path for utilities
-          $PATHLIST
-    -Z    Only use system path
-
-$SELF will validate the file currently on the local system
-
-Ordinarily, the file is found using the "leapfile" directive in $NTPCONF.
-However, an alternate location can be specified on the command line.
-
-If the file does not exist, is not valid, has expired, or is expiring soon,
-a new copy will be downloaded.  If the new copy validates, it is installed and
-NTP is (optionally) restarted.
-
-If the current file is acceptable, no download or restart occurs.
-
--c can also be used to invoke another script to perform administrative
-functions, e.g. to copy the file to other local systems.
-
-This can be run as a cron job.  As the file is rarely updated, and leap
-seconds are announced at least one month in advance (usually longer), it
-need not be run more frequently than about once every three weeks.
-
-For cron-friendly behavior, define CRONJOB=1 in the crontab.
-
-This script depends on:$REQUIREDCMDS
-
-Version $VERSION
-EOF
-   return 0
-}
-
-# Default: Use syslog for logging if running under cron
-
-SYSLOG="$CRONJOB"
-
-if [ "$1" = "--help" ]; then
-    displayHelp
-    exit 0
-fi
-
-# Parse options
-
-while getopts 46p:P:s:e:f:Fc:r:i:lLt:hqvz:Z opt; do
-    case $opt in
-        4)
-            PROTO="-4"
-            ;;
-        6)
-            PROTO="-6"
-            ;;
-        p)
-            if [ "$OPTARG" = '4' -o "$OPTARG" = '6' ]; then
-                PREFER="--prefer-family=IPv$OPTARG"
-            else
-                echo "Invalid -p $OPTARG" >&2
-                exit 1;
-            fi
-            ;;
-	P)
-	    LOGFAC="$OPTARG"
-	    ;;
-        s)
-            LEAPSRC="$OPTARG"
-            ;;
-        e)
-            PREFETCH="$OPTARG"
-            ;;
-	f)
-	    NTPCONF="$OPTARG"
-	    ;;
-        F)
-            FORCE="Y"
-            ;;
-        c)
-            RESTART="$OPTARG"
-            ;;
-        r)
-            MAXTRIES="$OPTARG"
-            ;;
-        i)
-            INTERVAL="$OPTARG"
-            ;;
-        t)
-            TMPFILE="$OPTARG"
-            ;;
-	l)
-	    SYSLOG="y"
-	    ;;
-	L)
-	    SYSLOG=
-	    ;;
-        h)
-            displayHelp
-            exit 0
-            ;;
-	q)
-	    QUIET="Y"
-	    ;;
-        v)
-            VERBOSE="Y"
-            ;;
-	z)
-	    PATHLIST="$OPTARG:"
-	    ;;
-	Z)
-	    PATHLIST=
-	    ;;
-        *)
-            echo "$SELF -h for usage" >&2
-            exit 1
-            ;;
-    esac
-done
-shift $((OPTIND-1))
-
-export PATH="$PATHLIST$PATH"
-
-# Add to path to deal with embedded systems
-#
-for P in $REQUIREDCMDS ; do
-    if >/dev/null 2>&1 which "$P" ; then
-	continue
-    fi
-    [ "$P" = "logger" ] && continue
-    echo "FATAL: missing $P command, please install"
-    exit 1
-done
-
-# Handle logging
-
-if ! LOGGER="`2>/dev/null which logger`" ; then
-    LOGGER=
-fi
-
-function log {
-    # "priority" "message"
-    #
-    # Stdout unless syslog specified or logger isn't available
-    #
-    if [ -z "$SYSLOG" -o -z "$LOGGER" ]; then
-	if [ -n "$QUIET" -a \( "$1" = "info" -o "$1" = "notice" -o "$1" = "debug" \) ]; then
-	    return 0
-	fi
-	echo "`echo \"$1\" | tr a-z A-Z`: $2"
-	return 0
-    fi
-
-    # Also log to stdout if cron job && notice or higher
-    local S
-    if [ -n "$CRONJOB" -a \( "$1" != "info" \) -a \( "$1" != "debug" \) ] || [ -n "$VERBOSE" ]; then
-	S="-s"
-    fi
-    $LOGGER $S -t "$SELF[$$]" -p "$LOGFAC.$1" "$2"
-}
-
-# Verify interval
-INTERVAL=$(( $INTERVAL *1 ))
-
-# Validate a leap-seconds file checksum
-#
-# File format: (full description in files)
-# # marks comments, except:
-# #$ number : the NTP date of the last update
-# #@ number : the NTP date that the file expires
-# Date (seconds since 1900) leaps : leaps is the # of seconds to add for times >= Date
-# Date lines have comments.
-# #h hex hex hex hex hex is the SHA-1 checksum of the data & dates, excluding whitespace w/o leading zeroes
-
-function verifySHA {
-
-    if [ ! -f "$1" ]; then
-        return 1
-    fi
-
-    # Remove comments, except those that are markers for last update, expires and hash
-
-    local RAW="`sed $1 -e'/^\\([0-9]\\|#[\$@h]\)/!d' -e'/^#[\$@h]/!s/#.*\$//g'`"
-
-    # Extract just the data, removing all whitespace
-
-    local DATA="`echo \"$RAW\" | sed -e'/^#h/d' -e's/^#[\$@]//g' | tr -d '[:space:]'`"
-
-    # Compute the SHA hash of the data, removing the marker and filename
-    # Computed in binary mode, which shouldn't matter since whitespace has been removed
-    # shasum comes in several flavors; a portable one is available in Perl (with Digest::SHA)
-
-    local DSHA="`echo -n \"$DATA\" | shasum | sed -e's/[? *].*$//'`"
-
-    # Extract the file's hash. Restore any leading zeroes in hash segments.
-
-    # The sed [] includes a tab (\t) and space; #h is followed by a tab and space
-    local FSHA="`echo \"$RAW\" | sed -e'/^#h/!d' -e's/^#h//' -e's/[ 	] */ 0x/g'`"
-    FSHA=`printf '%08x%08x%08x%08x%08x' $FSHA`
-
-    if [ -n "$FSHA" -a \( "$FSHA" = "$DSHA" \) ]; then
-        if [ -n "$2" ]; then
-            log "info" "Checksum of $1 validated"
-        fi
-    else
-        log "error" "Checksum of $1 is invalid:"
-	[ -z "$FSHA" ] && FSHA="(no checksum record found in file)"
-        log "error" "EXPECTED: $FSHA"
-        log "error" "COMPUTED: $DSHA"
-        return 1
-    fi
-
-    # Check the expiration date, converting NTP epoch to Unix epoch used by date
-
-    EXPIRES="`echo \"$RAW\" | sed -e'/^#@/!d' -e's/^#@//' | tr -d '[:space:]'`"
-    EXPIRES="$(($EXPIRES - 2208988800 ))"
-
-    if [ $EXPIRES -lt `date -u +%s` ]; then
-        log "notice" "File expired on `date -u -d \"Jan 1, 1970 00:00:00 +0000 + $EXPIRES seconds\"`"
-        return 2
-    fi
-
-}
-
-# Verify ntp.conf
-
-if ! [ -f "$NTPCONF" ]; then
-    log "critical" "Missing ntp configuration $NTPCONF"
-    exit 1
-fi
-
-# Parse ntp.conf for leapfile directive
-
-LEAPFILE="`sed $NTPCONF -e'/^ *leapfile  *.*$/!d' -e's/^ *leapfile  *//'`"
-if [ -z "$LEAPFILE" ]; then
-    log "error" "$NTPCONF does not specify a leapfile"
-fi
-
-# Allow placing the file someplace else - testing
-
-if [ -n "$1" ]; then
-    if [ "$1" != "$LEAPFILE" ]; then
-	log "notice" "Requested install to $1, but $NTPCONF specifies $LEAPFILE"
-    fi
-    LEAPFILE="$1"
-fi
-
-# Verify the current file
-# If it is missing, doesn't validate or expired
-# Or is expiring soon
-#  Download a new one
-
-if [ -n "$FORCE" ] || ! verifySHA $LEAPFILE "$VERBOSE" || [ $EXPIRES -lt `date -d "NOW + $PREFETCH" +%s` ] ; then
-    TRY=0
-    while true; do
-        TRY=$(( $TRY + 1 ))
-        if [ -n "$VERBOSE" ]; then
-            log "info" "Attempting download from $LEAPSRC, try $TRY.."
-        fi
-        if wget $PROTO $PREFER -o ${TMPFILE}.log $LEAPSRC -O $TMPFILE ; then
-            log "info" "Download of $LEAPSRC succeeded"
-            if [ -n "$VERBOSE" ]; then
-                cat ${TMPFILE}.log
-            fi
-
-            if ! verifySHA $TMPFILE "$VERBOSE" ; then
-		# There is no point in retrying, as the file on the server is almost
-		# certainly corrupt.
-
-                log "warning" "Downloaded file $TMPFILE rejected -- saved for diagnosis"
-                cat ${TMPFILE}.log
-                rm -f ${TMPFILE}.log
-                exit 1
-            fi
-            rm -f ${TMPFILE}.log
-
-	    # Set correct permissions on temporary file
-
-	    REFFILE="$LEAPFILE"
-            if [ ! -f $LEAPFILE ]; then
-		log "notice" "$LEAPFILE was missing, creating new copy - check permissions"
-                touch $LEAPFILE
-		# Can't copy permissions from old file, copy from NTPCONF instead
-		REFFILE="$NTPCONF"
-            fi
-            chmod --reference $REFFILE $TMPFILE
-            chown --reference $REFFILE $TMPFILE
-	    ( which selinuxenabled && selinuxenabled && which chcon ) >/dev/null 2>&1
-            if  [ $? == 0 ] ; then
-                chcon --reference $REFFILE $TMPFILE
-            fi
-
-	    # Replace current file with validated new one
-
-            if mv -f $TMPFILE $LEAPFILE ; then
-                log "notice" "Installed new $LEAPFILE from $LEAPSRC"
-            else
-                log "error" "Install $TMPFILE => $LEAPFILE failed -- saved for diagnosis"
-                exit 1
-            fi
-
-	    # Restart NTP (or whatever else is specified)
-
-	    if [ -n "$RESTART" ]; then
-		if [ -n "$VERBOSE" ]; then
-		    log "info" "Attempting restart action: $RESTART"
-		fi
-		R="$( 2>&1 $RESTART )"
-		if [ $? -eq 0 ]; then
-		    log "notice" "Restart action succeeded"
-		    if [ -n "$VERBOSE" -a -n "$R" ]; then
-			log "info" "$R"
-		    fi
-		else
-		    log "error" "Restart action failed"
-		    if [ -n "$R" ]; then
-			log "error" "$R"
-		    fi
-		    exit 2
-		fi
-	    fi
-            exit 0
-	fi
-
-	# Failed to download.  See about trying again
-
-        rm -f $TMPFILE
-        if [ $TRY -ge $MAXTRIES ]; then
-            break;
-        fi
-        if [ -n "$VERBOSE" ]; then
-            cat ${TMPFILE}.log
-            log "info" "Waiting $INTERVAL minutes before retrying..."
-        fi
-        sleep $(( $INTERVAL * 60))
-    done
-
-    # Failed and out of retries
-
-    log "warning" "Download from $LEAPSRC failed after $TRY attempts"
-    if [ -f ${TMPFILE}.log ]; then
-        cat ${TMPFILE}.log
-        rm -f ${TMPFILE}.log $TMPFILE
-    fi
-    exit 1
-fi
-log "info" "Not time to replace $LEAPFILE"
-
-exit 0
-
-# EOF
diff --git a/ntpleapfetch/ntpleapfetch-man.txt b/ntpleapfetch/ntpleapfetch-man.txt
deleted file mode 100644
index cb9035c..0000000
--- a/ntpleapfetch/ntpleapfetch-man.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-= ntpleapfetch(8) =
-:doctype: manpage
-
-== NAME == 
-ntpleapfetch - leap-seconds file manager/updater
-
-include::../docs/includes/ntpleapfetch-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-
-== AUTHORS ==
-
-Timothe Litt
-
-// end
diff --git a/ntpq/ntpq b/ntpq/ntpq
deleted file mode 100755
index 01a8057..0000000
--- a/ntpq/ntpq
+++ /dev/null
@@ -1,1677 +0,0 @@
-#!/usr/bin/env python
-#
-# ntpq - query an NTP server using mode 6 commands
-#
-# Freely translated from the old C ntpq code by ESR.  The idea was to
-# cleanly separate ntpq-that-was into a thin front-end layer handling
-# mainly command interpretation and a back-end that presents the take
-# from ntpd as objects that can be re-used by other front
-# ends. Reusable pieces live in pylib.
-#
-# SPDX-License-Identifier: BSD-2-clause
-from __future__ import print_function, division
-
-import os, sys, getopt, cmd, re
-import socket, hashlib, collections
-
-try:
-    import ntp.packet
-    import ntp.util
-    import ntp.ntpc
-    import ntp.version
-    import ntp.control
-except ImportError as e:
-    sys.stderr.write("ntpq: can't find Python NTP library -- check PYTHONPATH.\n")
-    sys.stderr.write("%s\n" % e)
-    sys.exit(1)
-
-# This import only works on Unixes.  The intention is to enable
-# Ctrl-P, Ctrl-N, and friends in Cmd.
-try:
-    import readline
-except ImportError:
-    pass
-
-version = ntp.util.stdversion()
-
-# General notes on Python 2/3 compatibility:
-#
-# This code uses the following strategy to allow it to run on both Python 2
-# and Python 3:
-#
-# - Use binary I/O to read/write data from/to files and subprocesses;
-#   where the exact bytes are important (such as in checking for
-#   modified files), use the binary data directly
-#
-# - Use latin-1 encoding to transform binary data to/from Unicode when
-#   necessary for operations where Python 3 expects Unicode; the
-#   polystr and polybytes functions are used to do this so that
-#   when running on Python 2, the byte string data is used unchanged;
-#   also, the make_wrapper function constructs a text stream that can
-#   wrap a file opened in binary mode for cases where a file object
-#   that can be passed around from function to function is needed
-#
-# - Construct custom stdin, stdout, and stderr streams when running
-#   on Python 3 that force latin-1 encoding, and wrap them around the
-#   underlying binary buffers (in Python 2, the streams are binary
-#   and are used unchanged); this ensures that the same transformation
-#   is done on data from/to the standard streams, as is done on binary
-#   data from/to files and subprocesses; the make_std_wrapper function
-#   does this
-
-master_encoding = 'latin-1'
-
-if str is bytes:  # Python 2
-    polystr = str
-    polybytes = bytes
-
-    def string_escape(s):
-        return s.decode('string_escape')
-
-    def make_wrapper(fp):
-        return fp
-
-else:  # Python 3
-    import io
-
-    def polystr(o):
-        "Polymorphic string factory function"
-        if isinstance(o, str):
-            return o
-        if not isinstance(o, bytes):
-            return str(o)
-        return str(o, encoding=master_encoding)
-
-    def polybytes(s):
-        "Polymorphic string encoding function"
-        if isinstance(s, bytes):
-            return s
-        if not isinstance(s, str):
-            return bytes(s)
-        return bytes(s, encoding=master_encoding)
-
-    def string_escape(s):
-        "Polymorphic string_escape/unicode_escape"
-        # This hack is necessary because Unicode strings in Python 3 don't
-        # have a decode method, so there's no simple way to ask it for the
-        # equivalent of decode('string_escape') in Python 2. This function
-        # assumes that it will be called with a Python 3 'str' instance
-        return s.encode(master_encoding).decode('unicode_escape')
-
-    def make_wrapper(fp):
-        "Wrapper factory function to enforce master encoding"
-        # This can be used to wrap normally binary streams for API
-        # compatibility with functions that need a text stream in
-        # Python 3; it ensures that the binary bytes are decoded using
-        # the master encoding we use to turn bytes to Unicode in
-        # polystr above
-        # newline="\n" ensures that Python 3 won't mangle line breaks
-        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")
-
-    def make_std_wrapper(stream):
-        "Standard input/output wrapper factory function"
-        # This ensures that the encoding of standard output and standard
-        # error on Python 3 matches the master encoding we use to turn
-        # bytes to Unicode in polystr above
-        # line_buffering=True ensures that interactive command sessions work as expected
-        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)
-
-    sys.stdin = make_std_wrapper(sys.stdin)
-    sys.stdout = make_std_wrapper(sys.stdout)
-    sys.stderr = make_std_wrapper(sys.stderr)
-
-# NTP-specific parts resume here
-
-# Flags for forming descriptors.
-OPT		= 0x80	# this argument is optional, or'd with type */
-NO		= 0x0
-NTP_STR		= 0x1	# string argument
-NTP_UINT	= 0x2	# unsigned integer
-NTP_INT		= 0x3	# signed integer
-NTP_ADD		= 0x4	# IP network address
-IP_VERSION	= 0x5	# IP version
-NTP_ADP		= 0x6	# IP address and port
-NTP_LFP		= 0x7	# NTP timestamp
-NTP_MODE	= 0x8	# peer mode
-NTP_2BIT	= 0x9	# leap bits
-NTP_FLOAT	= 0xa	# Float value
-
-# Old CTL_PST defines for version 2.
-OLD_CTL_PST_CONFIG = 0x80
-OLD_CTL_PST_AUTHENABLE = 0x40
-OLD_CTL_PST_AUTHENTIC = 0x20
-OLD_CTL_PST_REACH = 0x10
-OLD_CTL_PST_SANE = 0x08
-OLD_CTL_PST_DISP = 0x04
-
-OLD_CTL_PST_SEL_REJECT = 0
-OLD_CTL_PST_SEL_SELCAND = 1
-OLD_CTL_PST_SEL_SYNCCAND = 2
-OLD_CTL_PST_SEL_SYSPEER = 3
-
-class Ntpq(cmd.Cmd):
-    "ntpq command interpreter"
-    def __init__(self, session):
-        cmd.Cmd.__init__(self)
-        self.session = session
-        self.prompt = "ntpq> "
-        self.interactive       = False	# set to True when we should prompt
-        #self.auth_keyid   = 0		# Keyid used for authentication.
-        #self.auth_keytype = "NID_md5"	# MD5 (FIXME: string value is a dummy)
-        #self.auth_hashlen = 16		# MD5
-        self.rawmode           = False	# Flag which indicates raw mode output.
-        self.showhostnames     = True	# If false, display numeric IPs
-        self.auth_delay    = 20		# delay time (default 20msec)
-        self.wideremote = False		# show wide remote names?
-        self.ccmds = []			# Queued commands
-        self.chosts = []		# Command-line hosts
-        self.peers = []			# Data from NTP peers.
-        self.debug = 0
-        self.pktversion = ntp.magic.NTP_OLDVERSION + 1
-        self.uservars = collections.OrderedDict()
-        self.ai_family = socket.AF_UNSPEC
-
-    def emptyline(self):
-        "Called when an empty line is entered in response to the prompt."
-        pass
-
-    def default(self, line):
-        "Called on an input line when the command prefix is not recognized."
-
-        if line.startswith(":config"):
-            line = line[1:]
-        elif line.startswith("config-from-file"):
-            line = line.replace("config-from-file ", "config_from_file")
-
-        cmd, arg, line = self.parseline(line)
-        dotext = 'do_'+cmd
-        cmdprefixlist = [a[3:] for a in self.get_names() if a.startswith(dotext)]
-        if len(cmdprefixlist) == 1:
-            line = line.replace(cmd, cmdprefixlist[0])
-            cmd = cmdprefixlist[0]
-        elif len(cmdprefixlist) > 1:
-            self.warn("***Command `%s' ambiguous\n" % cmd)
-            return
-        elif len(cmdprefixlist) == 0:
-            self.warn("***Command `%s' unknown\n" % cmd)
-            return
-
-        if cmd == "help" and arg:
-            helptext = 'help_'+arg
-            if helptext not in self.get_names():
-                argprefixlist = [a[5:] for a in self.get_names() if a.startswith(helptext)]
-                if len(argprefixlist) == 1:
-                    line = line.replace(arg, argprefixlist.pop())
-                elif len(argprefixlist) > 1:
-                    self.warn("Command `%s' is ambiguous\n" % arg)
-                    return
-                elif len(argprefixlist) == 0:
-                    self.warn("Command `%s' is unknown\n" % arg)
-                    return
-
-        self.onecmd(line)
-
-    def do_help(self, arg):
-        if arg:
-            helptext = 'help_'+arg
-            if helptext not in self.get_names():
-                argprefixlist = [a[5:] for a in self.get_names() if a.startswith(helptext)]
-                if len(argprefixlist) == 1:
-                    arg = argprefixlist.pop()
-                elif len(argprefixlist) > 1:
-                    self.warn("Command `%s' is ambiguous\n" % arg)
-                    return
-        cmd.Cmd.do_help(self, arg)
-
-    def do_shell(self, line):
-        "Called when a line that starts with ! is entered in response to the prompt."
-        self.warn("***Command `!%s' unknown\n" % line)
-        return
-
-    def say(self, msg):
-        sys.stdout.write(polystr(msg))
-        sys.stdout.flush()	# In case we're piping the output
-
-    def warn(self, msg):
-        sys.stderr.write(polystr(msg))
-
-    def help_help(self):
-        self.say("""\
-function: tell the use and syntax of commands
-usage: help [ command ]
-""")
-
-    # Unexposed helper tables and functions begin here
-
-    def __dogetassoc(self):
-        try:
-            self.peers = self.session.readstat()
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return False
-        except IOError as e:
-            print(e.strerror)
-            return False
-
-        if len(self.peers) == 0:
-            if self.chosts:
-                self.say("server=%s " % self.session.hostname)
-            self.say("No association IDs returned\n")
-            return False
-
-        if self.debug:
-            self.warn("\n%d associations total\n" % len(self.peers))
-        #sortassoc()
-        return True
-
-    def __printassoc(self, showall):
-        condition = ""
-        if not self.peers:
-            self.say("No association IDs in list\n")
-            return
-        self.say("\nind assid status  conf reach auth condition  last_event cnt\n")
-        self.say("===========================================================\n")
-        for (i, peer) in enumerate(self.peers):
-            statval = ntp.control.CTL_PEER_STATVAL(peer.status)
-            if not showall and (statval & (ntp.control.CTL_PST_CONFIG|ntp.control.CTL_PST_REACH)) == 0:
-                continue
-            event = ntp.control.CTL_PEER_EVENT(peer.status)
-            event_count = ntp.control.CTL_PEER_NEVNT(peer.status)
-            if statval & ntp.control.CTL_PST_CONFIG:
-                conf = "yes"
-            else:
-                conf = "no"
-            if statval & ntp.control.CTL_PST_BCAST:
-                    reach = "none"
-                    if statval & ntp.control.CTL_PST_AUTHENABLE:
-                            auth = "yes"
-                    else:
-                            auth = "none"
-            elif statval & ntp.control.CTL_PST_REACH:
-                reach = "yes"
-            else:
-                reach = "no"
-            if (statval & ntp.control.CTL_PST_AUTHENABLE) == 0:
-                auth = "none"
-            elif statval & ntp.control.CTL_PST_AUTHENTIC:
-                auth = "ok "
-            else:
-                auth = "bad"
-            if self.pktversion > ntp.magic.NTP_OLDVERSION:
-                seldict = {
-                    ntp.control.CTL_PST_SEL_REJECT: "reject",
-                    ntp.control.CTL_PST_SEL_SANE: "falsetick",
-                    ntp.control.CTL_PST_SEL_CORRECT: "excess",
-                    ntp.control.CTL_PST_SEL_SELCAND: "outlier",
-                    ntp.control.CTL_PST_SEL_SYNCCAND: "candidate",
-                    ntp.control.CTL_PST_SEL_EXCESS: "backup",
-                    ntp.control.CTL_PST_SEL_SYSPEER: "sys.peer",
-                    ntp.control.CTL_PST_SEL_PPS: "pps.peer",
-                    }
-                condition = seldict[statval & 0x7]
-            else:
-                if (statval & 0x3) == OLD_CTL_PST_SEL_REJECT:
-                    if (statval & OLD_CTL_PST_SANE) == 0:
-                        condition = "insane"
-                    elif (statval & OLD_CTL_PST_DISP) == 0:
-                        condition = "hi_disp"
-                    else:
-                        condition = ""
-                elif (statval & 0x3) == OLD_CTL_PST_SEL_SELCAND:
-                        condition = "sel_cand"
-                elif (statval & 0x3) == OLD_CTL_PST_SEL_SYNCCAND:
-                    condition = "sync_cand"
-                elif (statval & 0x3) == OLD_CTL_PST_SEL_SYSPEER:
-                    condition = "sys_peer"
-            event_dict = {
-                ntp.magic.PEVNT_MOBIL: "mobilize",
-                ntp.magic.PEVNT_DEMOBIL: "demobilize",
-                ntp.magic.PEVNT_REACH: "reachable",
-                ntp.magic.PEVNT_UNREACH: "unreachable",
-                ntp.magic.PEVNT_RESTART: "restart",
-                ntp.magic.PEVNT_REPLY: "no_reply",
-                ntp.magic.PEVNT_RATE: "rate_exceeded",
-                ntp.magic.PEVNT_DENY: "access_denied",
-                ntp.magic.PEVNT_ARMED: "leap_armed",
-                ntp.magic.PEVNT_NEWPEER: "sys_peer",
-                ntp.magic.PEVNT_CLOCK: "clock_alarm",
-                }
-            last_event = event_dict.get(ntp.magic.PEER_EVENT|event, "")
-            display = \
-                     "%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2lu" % \
-                     (i + 1, peer.associd,
-                     peer.status, conf, reach, auth,
-                     condition, last_event, event_count)
-            self.say(display + "\n")
-
-    def __dopeers(self, showall, mode):
-        if not self.__dogetassoc():
-            return
-        if self.showhostnames:
-            termwidth = ntp.util.termsize().width
-        else:
-            termwidth = None	# Default width
-        report = ntp.util.PeerSummary(mode,
-                                      self.pktversion,
-                                      self.showhostnames,
-                                      self.wideremote,
-                                      termwidth=termwidth,
-                                      debug=interpreter.debug)
-        try:
-            maxhostlen = 0
-            if len(self.chosts) > 1:
-                maxhostlen = max([len(host) for (host, _af) in self.chosts])
-                self.say("%-*.*s " % \
-                                 (maxhostlen, maxhostlen+1, "server"))
-            self.say(report.header() + "\n")
-            if len(self.chosts) > 1:
-                maxhostlen = max([len(host) for (host, _af) in self.chosts])
-                self.say("=" * (maxhostlen + 1))
-            self.say(("=" * report.width()) + "\n")
-            for peer in self.peers:
-                if not showall and \
-                        not (ntp.control.CTL_PEER_STATVAL(peer.status)
-                          & (ntp.control.CTL_PST_CONFIG|ntp.control.CTL_PST_REACH)):
-                    if self.debug:
-                        self.warn("eliding [%d]\n" % peer.associd)
-                    continue
-                try:
-                    variables = self.session.readvar(peer.associd)
-                except ntp.packet.ControlException as e:
-                    self.warn(e.message + "\n")
-                    return
-                except IOError as e:
-                    print(e.strerror)
-                    return
-                if not variables:
-                    if len(self.chosts) > 1:
-                        self.warn("server=%s " % self.session.hostname)
-                    self.warn("***No information returned for association %d\n" \
-                                     % associd)
-                    continue
-                if len(self.chosts) > 1:
-                    self.say(ntp.util.PeerSummary.high_truncate(self.session.hostname, maxhostlen)+ " ")
-                self.say(report.summary(self.session.rstatus,
-                                        variables, peer.associd))
-        except KeyboardInterrupt:
-            pass
-
-    def __assoc_valid(self, line, required=False):
-        "Process a numeric associd or index."
-        if not line:
-            if required:
-                self.warn("An associd argument is required.\n")
-                return -1
-            else:
-                return 0
-        if not self.peers:
-            self.__dogetassoc()
-        if line.startswith("&"):
-            try:
-                idx = int(line[1:].split()[0])
-            except:
-                self.warn("Invalid index literal.\n")
-                return -1
-            if idx < 0 or idx >= 2**16-1:
-                self.warn("%d is not a valid association number.\n" % idx)
-                return -1
-            elif idx not in range(1, len(self.peers)+1):
-                self.warn("No such association as %d.\n" % idx)
-                return -1
-            else:
-                return self.peers[idx - 1].associd
-        else:
-            try:
-                associd = int(line.split()[0])
-            except:
-                self.warn("Invalid associd literal.\n")
-                return -1
-            if associd != 0 and associd not in [peer.associd for peer in self.peers]:
-                self.warn("Unknown associd.\n")
-                return -1
-            else:
-                return associd
-
-    def __assoc_range_valid(self, line):
-        "Try to get a range of assoc IDs."
-        tokens = line.split()
-        if len(tokens) < 2:
-            return ()
-        lo = self.__assoc_valid(tokens[0])
-        hi = self.__assoc_valid(tokens[1])
-        if lo < 0 or hi < 0 or hi < lo: 
-            return ()
-        if lo == hi:
-            return(lo,)
-        return range(lo, hi+1)
-
-    def printvars(self, variables, dtype, quiet):
-        "Dump variables in raw (actually, semi-cooked) mode."
-        if self.rawmode:
-            if not quiet:
-                self.say("status=0x%04x,\n" % self.session.rstatus)
-            # C ntpq not only suppressed \r but tried to visibilize
-            # high-half characters.  We won't do that unless somebody
-            # files a bug, Mode 6 never seems to generate those in
-            # variable fetches.
-            text = polystr(session.response.replace(polybytes(",\r\n"), polybytes(",\n")))
-        else:
-            if not quiet:
-                self.say("status=%04x %s,\n" % \
-                         (self.session.rstatus,
-                          ntp.ntpc.statustoa(dtype, self.session.rstatus)))
-
-            text = ""
-            for (name, value) in variables.items():
-                item = "%s=" % name
-                if name in ("reftime", "clock", "org", "rec", "xmt"):
-                    item += ntp.ntpc.prettydate(value)
-                elif name in ("srcadr", "peeradr", "dstadr", "refid"):
-                    # C ntpq cooked these in obscure ways.  Since they
-                    # came up from the daemon as human-readable
-                    # strings this was probably a bad idea, but we'll
-                    # leave this case separated in case somebody thinks
-                    # re-cooking them is a good idea.
-                    item += value
-                elif name == "leap":
-                    item += ("00", "01", "10", "11")[value]
-                elif name == "reach":
-                    item += "%03lo" % value
-                elif name in("filtdelay", "filtoffset", "filtdisp", "filterror"):
-                    item += "\t".join(value.split())
-                elif name == "flash":
-                    item += "%02x" % value
-                    if value == 0:
-                        item += " ok"
-                    else:
-                        # flasher bits
-                        tstflagnames = (
-                            "pkt_dup",		# BOGON1
-                            "pkt_bogus",	# BOGON2
-                            "pkt_unsync",	# BOGON3
-                            "pkt_denied",	# BOGON4
-                            "pkt_auth",		# BOGON5
-                            "pkt_stratum",	# BOGON6
-                            "pkt_header",	# BOGON7
-                            "pkt_autokey",	# BOGON8
-                            "pkt_crypto",	# BOGON9
-                            "peer_stratum",	# BOGON10
-                            "peer_dist",	# BOGON11
-                            "peer_loop",	# BOGON12
-                            "peer_unreach"	# BOGON13
-                        )
-                        for (i, n) in enumerate(tstflagnames):
-                            if (1 << i) & value:
-                                item += tstflagnames[i] + " "
-                        item = item[:-1]
-                else:
-                    item += repr(value)
-                item += ", "
-                lastcount = 0
-                for c in text:
-                    if c == '\n':
-                        lastcount = 0
-                    else:
-                        lastcount += 1
-                if lastcount + len(item) > ntp.util.termsize().width - 2:
-                    text = text[:-1] + "\n"
-                text += item
-            text = text[:-2] + "\n"
-        text = text.replace("'", '"')
-        self.say(text)
-
-    def __dolist(self, varlist, associd, op, type, quiet=False):
-        "List variables associated with a specified peer."
-        try:
-            variables = self.session.readvar(associd, varlist, op)
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return False
-        except IOError as e:
-            print(e.strerror)
-            return False
-        if len(self.chosts) > 1:
-            self.say("server=%s " % self.session.hostname)
-        if not variables:
-            if associd == 0:
-                self.say("No system%s variables returned\n"%
-                                " clock" if (type == ntp.ntpc.TYPE_CLOCK) else "")
-            else:
-                self.say("No information returned for%s association %d\n"%
-                                (" clock" if (type == ntp.ntpc.TYPE_CLOCK) else "",
-                                associd))
-            return True
-        if not quiet:
-            self.say("associd=%d " % associd)
-        self.printvars(variables, type, not (not varlist))
-        return True
-
-    # Unexposed helper tables and functions end here
-
-    def do_EOF(self, _unused):
-        "exit ntpq"
-        self.say("\n")
-        self.session.close()
-        raise SystemExit(0)
-
-    def do_timeout(self, line):
-        "set the primary receive time out"
-        if line:
-            try:
-                self.session.primary_timeout = int(line)
-            except ValueError:
-                print("What?")
-        print("primary timeout %d ms" % self.session.primary_timeout)
-
-    def help_timeout(self):
-        self.say("""\
-function: set the primary receive time out
-usage: timeout [ msec ]
-""")
-
-    def collect_display(self, associd, variables, decodestatus):
-        "Query and display a collection of variables from the system."
-        try:
-            queried = self.session.readvar(associd, [v[0] for v in variables])
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return
-        except IOError as e:
-            print(e.strerror)
-            return
-        if self.rawmode:
-            self.say(self.session.response)
-            return
-        if decodestatus:
-            if associd == 0:
-                statype = ntp.ntpc.TYPE_SYS
-            else:
-                statype = ntp.ntpc.TYPE_PEER
-            self.say("associd=%u status=%04x %s,\n" %
-                             (associd,
-                              self.session.rstatus,
-                              ntp.ntpc.statustoa(statype, self.session.rstatus)))
-        try:
-            for (name, legend, fmt) in variables:
-                if name not in queried:
-                    continue
-                value = queried[name]
-                if fmt in (NTP_ADD, NTP_ADP):
-                    if self.showhostnames:
-                        if self.debug:
-                            self.say("DNS lookup begins...")
-                        value = ntp.util.canonicalize_dns(value,
-                                                          family=self.ai_family)
-                        if self.debug:
-                            self.say("DNS lookup complete.")
-                    self.say("%s  %s\n" % (legend, value))
-                elif fmt == NTP_STR:
-                    if value:
-                        self.say("%s  %s\n" % (legend, value))
-                elif fmt in (NTP_UINT, NTP_INT, NTP_FLOAT):
-                    self.say("%s  %s\n" % (legend, value))
-                elif fmt == NTP_LFP:
-                    self.say("%s  %s\n" % (legend, ntp.ntpc.prettydate(value)))
-                elif fmt == NTP_2BIT:
-                    self.say("%s  %s\n" % (legend, ("00", "01", "10", "11")[value]))
-                elif fmt == NTP_MODE:
-                    modes = (
-                        "unspec", "sym_active", "sym_passive", "client", "server",
-                        "broadcast", "control", "private", "bclient"
-                    )
-                    try:
-                        self.say("%s  %s\n" % (legend, modes[value]))
-                    except IndexError:
-                        self.say("%s  %s%d\n" % (legend, "mode#", value))
-                else:
-                    self.warn("unexpected vc type %s for %s, value %s\n" % (fmt, name, value))
-        except KeyboardInterrupt:
-            self.warn("display interrupted\n")
-
-    def do_delay(self, line):
-        "set the delay added to encryption time stamps"
-        if not line:
-            self.say("delay %d ms\n" % self.auth_delay)
-        else:
-            try:
-                self.auth_delay = int(line)
-                if self.auth_delay < 0:
-                    raise ValueError
-            except ValueError:
-                self.say("Huh?")
-
-    def help_delay(self):
-        self.say("""\
-function: set the delay added to encryption time stamps
-usage: delay [ msec ]
-""")
-
-    def do_host(self, line):
-        "specify the host whose NTP server we talk to"
-        if not line:
-            if self.session.havehost():
-                print("current host is %s" % self.session.hostname)
-            else:
-                print("no current host")
-        else:
-            tokens = line.split()
-            if tokens[0] == '-4':
-                session.ai_family = socket.AF_INET
-                tokens.pop(0)
-            elif tokens[0] == '-6':
-                session.ai_family = socket.AF_INET6
-                tokens.pop(0)
-            try:
-                if tokens and self.session.openhost(tokens[0], session.ai_family):
-                    print("current host set to %s" % self.session.hostname)
-                elif self.session.havehost():
-                    print("current host remains %s" % self.session.hostname)
-                else:
-                    print("still no current host")
-            except KeyboardInterrupt:
-                print("lookup interrupted")
-
-    def help_host(self):
-        self.say("""\
-function: specify the host whose NTP server we talk to
-usage: host [ -4|-6 ] [ hostname ]
-""")
-
-    def do_poll(self, line):
-        "poll an NTP server in client mode `n' times"
-        # And it's not in the C version, so we're off the hook here
-        print("poll not implemented yet")
-
-    def help_poll(self):
-        self.say("""\
-function: poll an NTP server in client mode `n' times
-usage: poll [ n ] [ verbose ]
-""")
-
-    def do_passwd(self, line):
-        "specify a password to use for authenticated requests"
-        try:
-            self.session.password()
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-
-    def help_passwd(self):
-        self.say("""\
-function: specify a password to use for authenticated requests
-usage: passwd [  ]
-""")
-
-    def do_hostnames(self, line):
-        "specify whether hostnames or net numbers are printed"
-        if not line:
-            pass
-        elif line == "yes":
-            self.showhostnames = True
-        elif line == "no":
-            self.showhostnames = False
-        else:
-            print("What?")
-        if self.showhostnames:
-            print("hostnames being shown")
-        else:
-            print("hostnames not being shown")
-
-    def help_hostnames(self):
-        self.say("""\
-function: specify whether hostnames or net numbers are printed
-usage: hostnames [ yes|no ]
-""")
-
-    def do_debug(self, line):
-        "set/change debugging level"
-        if not line:
-            pass
-        elif line == "more":
-            self.debug +=1
-        elif line == "less":
-            self.debug -= 1
-        elif line == "no":
-            self.debug = 0
-        else:
-            try:
-                self.debug = int(line)	# C version didn't implement this
-            except ValueError:
-                print("What?")
-        self.session.debug = self.debug
-        print("debug level is %d" % self.debug)
-
-    def help_debug(self):
-        self.say("""\
-function: set/change debugging level
-usage: debug [ no|more|less|n ]
-""")
-
-    def do_exit(self, line):
-        "exit ntpq"
-        self.session.close()
-        raise SystemExit(0)
-
-    def help_exit(self):
-        self.say("""\
-function: exit ntpq
-usage: exit
-""")
-    do_quit = do_exit
-
-    def help_quit(self):
-        self.say("""\
-function: exit ntpq
-usage: quit
-""")
-
-    def do_keyid(self, line):
-        "set keyid to use for authenticated requests"
-        if line:
-            try:
-                self.session.keyid = int(line)
-            except ValueError:
-                print("What?")
-        if self.session.keyid is None:
-            print("no keyid defined")
-        else:
-            print("keyid is %d" % self.session.keyid)
-
-    def help_keyid(self):
-        self.say("""\
-function: set keyid to use for authenticated requests
-usage: keyid [ key# ]
-""")
-
-    def do_version(self, line):
-        "print version number"
-        print(version)
-
-    def help_version(self):
-        self.say("""\
-function: print version number
-usage: version
-""")
-
-    def do_raw(self, line):
-        "do raw mode variable output"
-        self.rawmode = True
-        print("Output set to raw")
-
-    def help_raw(self):
-        self.say("""\
-function: do raw mode variable output
-usage: raw
-""")
-
-    def do_cooked(self, line):
-        "do cooked mode variable output"
-        self.rawmode = False
-        print("Output set to cooked")
-
-    def help_cooked(self):
-        self.say("""\
-function: do cooked mode variable output
-usage: cooked
-""")
-
-    def do_authenticate(self, line):
-        "always authenticate requests to this server"
-        if not line:
-            pass
-        elif line == "yes":
-            self.session.always_auth = True
-        elif line == "no":
-            self.session.always_auth = False
-        else:
-            print("What?")
-        if self.session.always_auth:
-            print("authenticated requests being sent")
-        else:
-            print("unauthenticated requests being sent")
-
-    def help_authenticate(self):
-        self.say("""\
-function: always authenticate requests to this server
-usage: authenticate [ yes|no ]
-""")
-
-    def do_ntpversion(self, line):
-        "set the NTP version number to use for requests"
-        if not line:
-            pass
-        else:
-            try:
-                newversion = int(line)
-                if newversion >= ntp.magic.NTP_OLDVERSION and newversion <= ntp.magic.NTP_VERSION:
-                    self.pktversion = newversion
-                else:
-                    print("versions %d to %d, please"
-                          % (ntp.magic.NTP_OLDVERSION, ntp.magic.NTP_VERSION))
-            except ValueError:
-                print("What?")
-        print("NTP version being claimed is %d" % self.pktversion)
-
-    def help_ntpversion(self):
-        self.say("""\
-function: set the NTP version number to use for requests
-usage: ntpversion [ version number ]
-""")
-
-    def do_keytype(self, line):
-        "set key type to use for authenticated requests"
-        if not line:
-            self.say("Keytype: %s\n" % self.session.keytype)
-        elif not line in "DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1":
-            self.warn("Keytype %s is not supported by ntpd.\n" % line)
-        elif line not in hashlib.algorithms_available:
-            self.warn("Keytype %s is not supported by ntpq.\n" % line)
-        else:
-            self.session.keytype = line
-
-    def help_keytype(self):
-        self.say("""\
-function: set key type to use for authenticated requests, one of:
-    DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1
-usage: keytype [ digest-name ]
-""")
-
-    def do_associations(self, line):
-        "print list of association IDs and statuses for the server's peers"
-        if self.__dogetassoc():
-            self.__printassoc(showall=False)
-
-    def help_associations(self):
-        self.say("""\
-function: print list of association IDs and statuses for the server's peers
-usage: associations
-""")
-
-    def do_passociations(self, line):
-        "print list of associations returned by last associations command"
-        self.__printassoc(showall=False)
-
-    def help_passociations(self):
-        self.say("""\
-function: print list of associations returned by last associations command
-usage: passociations
-""")
-
-    def do_lassociations(self, line):
-        "print list of associations including all client information"
-        if self.__dogetassoc():
-            self.__printassoc(showall=True)
-
-    def help_lassociations(self):
-        self.say("""\
-function: print list of associations including all client information
-usage: lassociations
-""")
-
-    def do_lpassociations(self, line):
-        "print last obtained list of associations, including client information"
-        self.__printassoc(showall=True)
-
-    def help_lpassociations(self):
-        self.say("""\
-function: print last obtained list of associations, including client information
-usage: lpassociations
-""")
-
-    def do_addvars(self, line):
-        "add variables to the variable list or change their values"
-        if not line:
-            self.warn("usage: addvars name[=value][,...]\n")
-            return
-        vars_to_add = line.split(',')
-        for add_var in vars_to_add:
-            try:
-                (name, val) = add_var.split("=")
-            except ValueError:
-                (name, val) = (add_var, "")
-            self.uservars[name.strip()] = val.strip()
-
-    def help_addvars(self):
-        self.say("""\
-function: add variables to the variable list or change their values
-usage: addvars name[=value][,...]
-""")
-
-    def do_rmvars(self, line):
-        "remove variables from the variable list"
-        if not line:
-            self.warn("usage: rmvars name[,...]\n")
-            return
-        vars_to_rm = line.split(',')
-        for rm_var in vars_to_rm:
-            if rm_var not in self.uservars:
-                print("%s is not in the variable list" % rm_var)
-            else:
-                del self.uservars[rm_var]
-
-    def help_rmvars(self):
-        self.say("""\
-function: remove variables from the variable list
-usage: rmvars name[,...]
-""")
-
-    def do_clearvars(self, line):
-        "remove all variables from the variable list"
-        self.uservars.clear()
-
-    def help_clearvars(self):
-        self.say("""\
-function: remove all variables from the variable list
-usage: clearvars
-""")
-
-    def do_showvars(self, line):
-        "print variables on the variable list"
-        if len(self.uservars) == 0:
-            print("No variables on list.")
-        for (name, value) in self.uservars.items():
-            if value:
-                print("%s=%s" % (name, value))
-            else:
-                print(name)
-
-    def help_showvars(self):
-        self.say("""\
-function: print variables on the variable list
-usage: showvars
-""")
-
-    def do_readlist(self, line):
-        "read the system or peer variables included in the variable list"
-        associd = self.__assoc_valid(line)
-        if associd >= 0:
-            qtype = ntp.ntpc.TYPE_SYS if associd == 0 else ntp.ntpc.TYPE_PEER
-            self.__dolist(self.uservars.keys(), associd, ntp.control.CTL_OP_READVAR, qtype)
-
-    def help_readlist(self):
-        self.say("""\
-function: read the system or peer variables included in the variable list
-usage: readlist [ assocID ]
-""")
-
-    def do_rl(self, line):
-        "read the system or peer variables included in the variable list"
-        self.do_readlist(line)
-
-    def help_rl(self):
-        self.say("""\
-function: read the system or peer variables included in the variable list
-usage: rl [ assocID ]
-""")
-
-    def do_writelist(self, line):
-        "write the system or peer variables included in the variable list"
-        pass
-
-    def help_writelist(self):
-        self.say("""\
-function: write the system or peer variables included in the variable list
-usage: writelist [ assocID ]
-""")
-
-    def do_readvar(self, line):
-        "read system or peer variables"
-        associd = self.__assoc_valid(line)
-        if associd >= 0:
-            qtype = ntp.ntpc.TYPE_SYS if associd == 0 else ntp.ntpc.TYPE_PEER
-            self.__dolist(line.split()[1:], associd, ntp.control.CTL_OP_READVAR, qtype, quiet=True)
-
-    def help_readvar(self):
-        self.say("""\
-function: read system or peer variables
-usage: readvar [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
-""")
-
-    def do_rv(self, line):
-        "read system or peer variables"
-        self.do_readvar(line)
-
-    def help_rv(self):
-        self.say("""\
-function: read system or peer variables
-usage: rv [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
-""")
-
-    def do_writevar(self, line):
-        "write system or peer variables"
-        pass
-
-    def help_writevar(self):
-        self.say("""\
-function: write system or peer variables
-usage: writevar assocID name=value,[...]
-""")
-
-    def do_mreadlist(self, line):
-        "read the peer variables in the variable list for multiple peers"
-        if not line:
-                self.warn("usage: mreadlist assocIDlow assocIDhigh\n")
-                return
-        idrange = self.__assoc_range_valid(line)
-        if not idrange:
-            return
-        varlist = line.split()[2:]
-        for associd in idrange:
-            if (associd != idrange[0]):
-                self.say("\n")
-            if not self.__dolist(self.uservars,
-                                associd, ntp.control.CTL_OP_READVAR, ntp.ntpc.TYPE_PEER):
-                return
-
-    def help_mreadlist(self):
-        self.say("""\
-function: read the peer variables in the variable list for multiple peers
-usage: mreadlist assocIDlow assocIDhigh
-""")
-
-    def do_mrl(self, line):
-        "read the peer variables in the variable list for multiple peers"
-        if not line:
-                self.warn("usage: mrl assocIDlow assocIDhigh\n")
-                return
-        self.do_mreadlist(line)
-
-    def help_mrl(self):
-        self.say("""\
-function: read the peer variables in the variable list for multiple peers
-usage: mrl assocIDlow assocIDhigh
-""")
-
-    def do_mreadvar(self, line):
-        "read peer variables from multiple peers"
-        if not line:
-                self.warn("usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]\n")
-                return
-        idrange = self.__assoc_range_valid(line)
-        if not idrange:
-            return
-        varlist = line.split()[2:]
-        for associd in idrange:
-            if (associd != idrange[0]):
-                self.say("\n")
-            if not self.__dolist(varlist, associd, ntp.control.CTL_OP_READVAR, ntp.ntpc.TYPE_PEER):
-                return
-
-    def help_mreadvar(self):
-        self.say("""\
-function: read peer variables from multiple peers
-usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]
-""")
-
-    def do_mrv(self, line):
-        "read peer variables from multiple peers"
-        if not line:
-                self.warn("usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]\n")
-                return
-        self.do_mreadvar(line)
-
-    def help_mrv(self):
-        self.say("""\
-function: read peer variables from multiple peers
-usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]
-""")
-
-    def do_clocklist(self, line):
-        "read the clock variables included in the variable list"
-        assoc = self.__assoc_valid(line)
-        if assoc >= 0:
-            self.__dolist(self.uservars.keys(),
-                          assoc, ntp.control.CTL_OP_READCLOCK, ntp.ntpc.TYPE_CLOCK)
-
-    def help_clocklist(self):
-        self.say("""\
-function: read the clock variables included in the variable list
-usage: clocklist [ assocID ]
-""")
-
-    def do_cl(self, line):
-        "read the clock variables included in the variable list"
-        self.do_clocklist(line)
-
-    def help_cl(self):
-        self.say("""\
-function: read the clock variables included in the variable list
-usage: cl [ assocID ]
-""")
-
-    def do_clockvar(self, line):
-        "read clock variables"
-        assoc = self.__assoc_valid(line)
-        if assoc == 0:
-            self.warn("This command requires the association ID of a clock.\n")
-        elif assoc > 0:
-            self.__dolist(line.split()[1:], assoc, ntp.control.CTL_OP_READCLOCK, ntp.ntpc.TYPE_CLOCK)
-
-    def help_clockvar(self):
-        self.say("""\
-function: read clock variables
-usage: clockvar [ assocID ] [ name=value[,...] ]
-""")
-
-    def do_cv(self, line):
-        "read clock variables"
-        self.do_clockvar(line)
-
-    def help_cv(self):
-        self.say("""\
-function: read clock variables
-usage: cv [ assocID ] [ name=value[,...] ]
-""")
-
-    def do_pstats(self, line):
-        "show statistics for a peer"
-        pstats = (
-            ("srcadr",		"remote host:         ", NTP_ADD),
-            ("dstadr",		"local address:       ", NTP_ADD),
-            ("timerec",		"time last received:  ", NTP_INT),
-            ("timer",		"time until next send:", NTP_INT),
-            ("timereach",	"reachability change: ", NTP_INT),
-            ("sent",		"packets sent:        ", NTP_INT),
-            ("received",	"packets received:    ", NTP_INT),
-            ("badauth",		"bad authentication:  ", NTP_INT),
-            ("bogusorg",	"bogus origin:        ", NTP_INT),
-            ("oldpkt",		"duplicate:           ", NTP_INT),
-            ("seldisp",		"bad dispersion:      ", NTP_INT),
-            ("selbroken",	"bad reference time:  ", NTP_INT),
-            ("candidate",	"candidate order:     ", NTP_INT),
-        )
-        if not line:
-                self.warn("usage: pstats assocID\n")
-                return
-        associd = self.__assoc_valid(line)
-        if associd >= 0:
-            self.collect_display(associd=associd,
-                                 variables=pstats, decodestatus=True)
-
-    def help_pstats(self):
-        self.say("""\
-function: show statistics for a peer
-usage: pstats assocID
-""")
-
-    def do_peers(self, line):
-        "obtain and print a list of the server's peers [IP version]"
-        self.__dopeers(showall=False, mode="peers")
-
-    def help_peers(self):
-        self.say("""\
-function: obtain and print a list of the server's peers [IP version]
-usage: peers
-""")
-
-    def do_apeers(self, line):
-        "obtain and print a list of the server's peers and their assocIDs [IP version]"
-        self.__dopeers(showall=False, mode="apeers")
-
-    def help_apeers(self):
-        self.say("""\
-function: obtain and print a list of the server's peers and their assocIDs [IP version]
-usage: apeers
-""")
-
-    def do_lpeers(self, line):
-        "obtain and print a list of all peers and clients [IP version]"
-        self.__dopeers(showall=True, mode="peers")
-
-    def help_lpeers(self):
-        self.say("""\
-function: obtain and print a list of all peers and clients [IP version]
-usage: lpeers
-""")
-
-    def do_opeers(self, line):
-        "print peer list the old way, with dstadr shown rather than refid [IP version]"
-        self.__dopeers(showall=False, mode="opeers")
-
-    def help_opeers(self):
-        self.say("""\
-function: print peer list the old way, with dstadr shown rather than refid [IP version]
-usage: opeers
-""")
-
-    def do_lopeers(self, line):
-        "obtain and print a list of all peers and clients showing dstadr [IP version]"
-        self.__dopeers(showall=True, mode="opeers")
-
-    def help_lopeers(self):
-        self.say("""\
-function: obtain and print a list of all peers and clients showing dstadr [IP version]
-usage: lopeers
-""")
-
-    def do_config(self, line):
-        "send a remote configuration command to ntpd"
-        try:
-            self.session.password()
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return
-        if self.debug > 2:
-            self.warn("In Config\nKeyword = :config\nCommand = %s\n" % line)
-        try:
-            self.session.config(line)
-            m = re.match("column ([0-9]+) syntax error", self.session.response)
-            if m:
-                col = int(m.group(1))
-                if col >= 0 and col <= len(line):
-                    if self.interactive:
-                        self.say("_" * (len(self.prompt) + 2 + col))
-                    else:
-                        self.say(line + "\n")
-                    self.say("_" * (col- 1))
-                self.say("^\n")
-            self.say(self.session.response + "\n")
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-
-    def help_config(self):
-        self.say("""\
-function: send a remote configuration command to ntpd
-usage: config <configuration command line>
-""")
-
-    def do_config_from_file(self, line):
-        "configure ntpd using the configuration filename"
-        try:
-            with open(line) as rfp:
-                self.say(self.session.config(rfp.read()))
-        except IOError:
-            self.warn("Could not read %s\n" % line)
-
-    def help_config_from_file(self):
-        self.say("""\
-function: configure ntpd using the configuration filename
-usage: config_from_file <configuration filename>
-""")
-
-    def do_mrulist(self, line):
-        "display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
-        cmdvars = {}
-        for item in line.split(" "):
-            if not item:
-                continue
-            if '=' not in item:
-                cmdvars[item] = True
-            else:
-                eq = item.index("=")
-                var = item[:eq].strip()
-                val = item[eq+1:].strip()
-                try:
-                    val = int(val, 0)
-                except ValueError:
-                    try:
-                        val = float(val)
-                    except ValueError:
-                        if val[0] == '"' and val[-1] == '"':
-                            val = val[1:-1]
-                cmdvars[var] = val
-
-        self.say("Ctrl-C will stop MRU retrieval and display partial results.\n")
-        if self.rawmode:
-            mruhook = lambda v: self.printvars(variables=v,
-                                               dtype=ntp.ntpc.TYPE_SYS,
-                                               quiet=True)
-        else:
-            mruhook = None
-        try:
-            span = self.session.mrulist(variables=cmdvars, rawhook=mruhook)
-            if not self.rawmode:
-                if not span.is_complete():
-                    self.say("mrulist retrieval interrupted by operator.\n"
-                             "Displaying partial client list.\n")
-                try:
-                    formatter = ntp.util.MRUSummary(interpreter.showhostnames)
-                    self.say(ntp.util.MRUSummary.header + "\n")
-                    self.say(("=" * ntp.util.MRUSummary.width) + "\n")
-                    # reversed to put most recent entries at the top.
-                    for entry in reversed(span.entries):
-                        self.say(formatter.summary(entry) + "\n")
-                except KeyboardInterrupt:
-                    pass
-        except ntp.packet.ControlException as e:
-            # Giving up after 8 restarts from the beginning.
-            # With high-traffic NTP servers, this can occur if the
-            # MRU list is limited to less than about 16 seconds' of
-            # entries.  See the 'mru' ntp.conf entry.
-            self.warn(e.message + "\n")
-
-    def help_mrulist(self):
-        self.say("""\
-function: display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x...
-usage: mrulist [ tag=value ] [ tag=value ] [ tag=value ] [ tag=value ]
-""")
-
-    def do_ifstats(self, line):
-        "show statistics for each local address ntpd is using"
-        try:
-            self.session.password()
-            entries = self.session.ifstats()
-            if self.rawmode:
-                print(self.session.response)
-            else:
-                formatter = ntp.util.IfstatsSummary()
-                self.say(ntp.util.IfstatsSummary.header)
-                self.say(("=" * ntp.util.IfstatsSummary.width) + "\n")
-                for (i, entry) in enumerate(entries):
-                    self.say(formatter.summary(i, entry))
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return
-        pass
-
-    def help_ifstats(self):
-        self.say("""\
-function: show statistics for each local address ntpd is using
-usage: ifstats
-""")
-
-    def do_reslist(self, line):
-        "show ntpd access control list"
-        try:
-            self.session.password()
-            entries = self.session.reslist()
-            if self.rawmode:
-                print(self.session.response)
-            else:
-                formatter = ntp.util.ReslistSummary()
-                self.say(ntp.util.ReslistSummary.header)
-                self.say(("=" * ntp.util.ReslistSummary.width) + "\n")
-                for entry in entries:
-                    self.say(formatter.summary(entry))
-        except ntp.packet.ControlException as e:
-            self.warn(e.message + "\n")
-            return
-
-    def help_reslist(self):
-        self.say("""\
-function: show ntpd access control list
-usage: reslist
-""")
-
-    def do_sysinfo(self, _line):
-        "display system summary"
-        sysinfo = (
-            ("peeradr",		"system peer:      ", NTP_ADP),
-            ("peermode",	"system peer mode: ", NTP_MODE),
-            ("leap",		"leap indicator:   ", NTP_2BIT),
-            ("stratum",		"stratum:          ", NTP_INT),
-            ("precision",	"log2 precision:   ", NTP_INT),
-            ("rootdelay",	"root delay:       ", NTP_FLOAT),
-            ("rootdisp",	"root dispersion:  ", NTP_FLOAT),
-            ("refid",		"reference ID:     ", NTP_STR),
-            ("reftime",		"reference time:   ", NTP_LFP),
-            ("sys_jitter",	"system jitter:    ", NTP_FLOAT),
-            ("clk_jitter",	"clock jitter:     ", NTP_FLOAT),
-            ("clk_wander",	"clock wander:     ", NTP_FLOAT),
-            ("bcastdelay",	"broadcast delay:  ", NTP_FLOAT),
-            ("authdelay",	"symm. auth. delay:", NTP_FLOAT),
-        )
-        self.collect_display(associd=0, variables=sysinfo, decodestatus=True)
-
-    def help_sysinfo(self):
-        self.say("""\
-function: display system summary
-usage: sysinfo
-""")
-
-    def do_kerninfo(self, _line):
-        "display kernel loop and PPS statistics"
-        kerninfo = (
-            ("koffset",		"pll offset:          ", NTP_FLOAT),
-            ("kfreq",		"pll frequency:       ", NTP_FLOAT),
-            ("kmaxerr",		"maximum error:       ", NTP_FLOAT),
-            ("kesterr",		"estimated error:     ", NTP_FLOAT),
-            ("kstflags",	"kernel status:       ", NTP_STR),
-            ("ktimeconst",	"pll time constant:   ", NTP_INT),
-            ("kprecis",		"precision:           ", NTP_FLOAT),
-            ("kfreqtol",	"frequency tolerance: ", NTP_INT),
-            ("kppsfreq",	"pps frequency:       ", NTP_INT),
-            ("kppsstab",	"pps stability:       ", NTP_INT),
-            ("kppsjitter",	"pps jitter:          ", NTP_INT),
-            ("kppscalibdur",	"calibration interval ", NTP_INT),
-            ("kppscalibs",	"calibration cycles:  ", NTP_INT),
-            ("kppsjitexc",	"jitter exceeded:     ", NTP_INT),
-            ("kppsstbexc",	"stability exceeded:  ", NTP_INT),
-            ("kppscaliberrs",	"calibration errors:  ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=kerninfo, decodestatus=True)
-
-    def help_kerninfo(self):
-        self.say("""\
-function: display kernel loop and PPS statistics
-usage: kerninfo
-""")
-
-    def do_sysstats(self, _line):
-        "display system uptime and packet counts"
-        sysstats = (
-            ("ss_uptime",	"uptime:               ", NTP_INT),
-            ("ss_reset",	"sysstats reset:       ", NTP_INT),
-            ("ss_received",	"packets received:     ", NTP_INT),
-            ("ss_thisver",	"current version:      ", NTP_INT),
-            ("ss_oldver",	"older version:        ", NTP_INT),
-            ("ss_badformat",	"bad length or format: ", NTP_INT),
-            ("ss_badauth",	"authentication failed:", NTP_INT),
-            ("ss_declined",	"declined:             ", NTP_INT),
-            ("ss_restricted",	"restricted:           ", NTP_INT),
-            ("ss_limited",	"rate limited:         ", NTP_INT),
-            ("ss_kodsent",	"KoD responses:        ", NTP_INT),
-            ("ss_processed",	"processed for time:   ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=sysstats, decodestatus=False)
-
-    def help_sysstats(self):
-        self.say("""\
-function: display system uptime and packet counts
-usage: sysstats
-""")
-
-    def do_monstats(self, _line):
-        "display monitor (mrulist) counters and limits"
-        monstats = (
-            ("mru_enabled",	"enabled:            ", NTP_INT),
-            ("mru_depth",	"addresses:          ", NTP_INT),
-            ("mru_deepest",	"peak addresses:     ", NTP_INT),
-            ("mru_maxdepth",	"maximum addresses:  ", NTP_INT),
-            ("mru_mindepth",	"reclaim above count:", NTP_INT),
-            ("mru_maxage",	"reclaim older than: ", NTP_INT),
-            ("mru_mem",		"kilobytes:          ", NTP_INT),
-            ("mru_maxmem",	"maximum kilobytes:  ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=monstats, decodestatus=False)
-
-    def help_monstats(self):
-        self.say("""\
-function: display monitor (mrulist) counters and limits
-usage: monstats
-""")
-
-    def do_authinfo(self, _line):
-        "display symmetric authentication counters"
-        authinfo = (
-            ("authreset",	"time since reset:", NTP_INT),
-            ("authkeys",	"stored keys:     ", NTP_INT),
-            ("authfreek",	"free keys:       ", NTP_INT),
-            ("authklookups",	"key lookups:     ", NTP_INT),
-            ("authknotfound",	"keys not found:  ", NTP_INT),
-            ("authkuncached",	"uncached keys:   ", NTP_INT),
-            ("authkexpired",	"expired keys:    ", NTP_INT),
-            ("authencrypts",	"encryptions:     ", NTP_INT),
-            ("authdecrypts",	"decryptions:     ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=authinfo, decodestatus=False)
-
-    def help_authinfo(self):
-        self.say("""\
-function: display symmetric authentication counters
-usage: authinfo
-""")
-
-    def do_iostats(self, _line):
-        "display network input and output counters"
-        iostats = (
-            ("iostats_reset",	"time since reset:     ", NTP_INT),
-            ("total_rbuf",	"receive buffers:      ", NTP_INT),
-            ("free_rbuf",	"free receive buffers: ", NTP_INT),
-            ("used_rbuf",	"used receive buffers: ", NTP_INT),
-            ("rbuf_lowater",	"low water refills:    ", NTP_INT),
-            ("io_dropped",	"dropped packets:      ", NTP_INT),
-            ("io_ignored",	"ignored packets:      ", NTP_INT),
-            ("io_received",	"received packets:     ", NTP_INT),
-            ("io_sent",		"packets sent:         ", NTP_INT),
-            ("io_sendfailed",	"packet send failures: ", NTP_INT),
-            ("io_wakeups",	"input wakeups:        ", NTP_INT),
-            ("io_goodwakeups",	"useful input wakeups: ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=iostats, decodestatus=False)
-
-    def help_iostats(self):
-        self.say("""\
-function: display network input and output counters
-usage: iostats
-""")
-
-    def do_timerstats(self, line):
-        "display interval timer counters"
-        timerstats = (
-            ("timerstats_reset",	"time since reset:  ", NTP_INT),
-            ("timer_overruns",		"timer overruns:    ", NTP_INT),
-            ("timer_xmts",		"calls to transmit: ", NTP_INT),
-        )
-        self.collect_display(associd=0, variables=timerstats, decodestatus=False)
-
-    def help_timerstats(self):
-        self.say("""\
-function: display interval timer counters
-usage: timerstats
-""")
-
-# Default values we use.
-DEFHOST 	= "localhost"	# default host name
-
-#
-# main - parse arguments and handle options
-#
-
-usage = '''
-USAGE: ntpq [-46dphinOV] [-c str] [-D lvl] [ host ...]
-  Flg Arg Option-Name    Description
-   -4 no  ipv4           Force IPv4 DNS name resolution
-                                - prohibits the option 'ipv6'
-   -6 no  ipv6           Force IPv6 DNS name resolution
-                                - prohibits the option 'ipv4'
-   -c Str command        run a command and exit
-                                - may appear multiple times
-   -d no  debug-level    Increase output debug message level
-                                - may appear multiple times
-   -D Int set-debug-level Set the output debug message level
-                                - may appear multiple times
-   -h no  help           Print a usage message.
-   -p no  peers          Print a list of the peers
-                                - prohibits the option 'interactive'
-   -i no  interactive    Force ntpq to operate in interactive mode
-                                - prohibits these options:
-                                command
-                                peers
-   -n no  numeric        numeric host addresses
-   -V opt version        Output version information and exit
-   -w no  wide           enable wide display of addresses
-'''
-
-if __name__ == '__main__':
-    ntp.ntpc.setprogname("ntpq")
-    #init_auth()
-
-    try:
-        (options, arguments) = getopt.getopt(sys.argv[1:],
-                                             "46c:dD:hinpVw",
-                                             ["ipv4","ipv6", "command=",
-                                              "debug", "set-debug-level=",
-                                              "help", "interactive", "numeric",
-                                              "peers", "version",
-                                              "wide"])
-    except getopt.GetoptError as e:
-        sys.stderr.write("%s\n" % e)
-        sys.stderr.write(usage)
-        raise SystemExit(1)
-    progname = sys.argv[0]
-
-    session = ntp.packet.ControlSession()
-    interpreter = Ntpq(session)
-
-    for (switch, val) in options:
-        if switch in ("-4", "--ipv4"):
-            interpreter.ai_family = socket.AF_INET
-        elif switch in ("-6", "--ipv6"):
-            interpreter.ai_family = socket.AF_INET6
-        elif switch in ("-c", "--command"):
-            interpreter.ccmds.append(val)
-        elif switch in ("-d", "--debug"):
-            interpreter.debug += 1
-            session.debug += 1
-        elif switch in ("-D", "--set-debug-level"):
-            try:
-                session.debug = interpreter.debug = int(val)
-            except ValueError as e:
-                sys.stderr.write("'%s' is not a recognizable number\n" % val)
-                sys.stderr.write(usage)
-                raise SystemExit(1)
-        elif switch in ("-h", "--help"):
-            print(usage)
-            raise SystemExit(0)
-        elif switch in ("-i", "--interactive"):
-            interpreter.interactive = True
-        elif switch in ("-n", "--numeric"):
-            interpreter.showhostnames = False
-        elif switch in ("-p", "--peers"):
-            interpreter.ccmds.append("peers")
-        elif switch in ("-V", "--version"):
-            print("ntpq %s" % version)
-            raise SystemExit(0)
-        elif switch in ("-w", "--wide"):
-            interpreter.wideremote = True
-
-    if interpreter.interactive and len(interpreter.ccmds) > 0:
-        interpreter.warn("%s: invalid option combination.\n" % progname)
-        raise SystemExit(1)
-
-    if len(arguments) == 0:
-        interpreter.chosts.append((DEFHOST, session.ai_family))
-    else:
-        for token in arguments:
-            if token.startswith("-"):
-                if '4' == token[1]:
-                    session.ai_family = socket.AF_INET
-                elif '6' == token[1]:
-                    session.ai_family = socket.AF_INET6
-            else:
-                interpreter.chosts.append((token, session.ai_family))
-
-    if len(interpreter.ccmds) == 0 and not interpreter.interactive and os.isatty(0) and os.isatty(1):
-        interpreter.interactive = True
-
-    try:
-        if len(interpreter.ccmds) == 0:
-            if len(interpreter.chosts) > 1:
-                interpreter.warn("ntpq can only work interactively on one host.\n")
-                interpreter.chosts = interpreter.chosts[:1]
-            session.openhost(*interpreter.chosts[0])
-            interpreter.cmdloop()
-        else:
-            for ihost in interpreter.chosts:
-                if session.openhost(*ihost):
-                    for command in interpreter.ccmds:
-                        interpreter.onecmd(command)
-                    session.close()
-        raise SystemExit(0)
-    except KeyboardInterrupt:
-        interpreter.say("\n")
-    except ntp.packet.ControlException as e:
-        interpreter.warn(e.message + "\n")
-    except IOError:
-        print("Bailing out...")
-# end
diff --git a/ntpq/ntpq-man.txt b/ntpq/ntpq-man.txt
deleted file mode 100644
index 77e1a07..0000000
--- a/ntpq/ntpq-man.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-= ntpq(1) =
-:doctype: manpage
-
-== NAME ==
-ntpq - standard NTP query program
-
-include::../docs/includes/ntpq-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-66 (EX_NOINPUT)::
-  A specified configuration file could not be loaded.
-
-// end
diff --git a/ntpstats/README b/ntpstats/README
deleted file mode 100644
index 2c2b40c..0000000
--- a/ntpstats/README
+++ /dev/null
@@ -1,15 +0,0 @@
-This directory contains code for data reduction and visualization of NTP
-logfiles.  It's written around a class named NTPstats, which can be found
-in ntpstats.py.
-
-While all comers are invited to experiment with ntpstats.py, its interface
-and capabilities are at present private to the NTPsec suite, subject to
-change without notice, and should not be considered a public interface.
-This status may (and probably will) change in a future release.
-
-If you want to generate the ntpviz graphs regularly, add these lines to
-your root crontab:
-
-53 * * * * cd /usr/local/src/NTP/ntpsec/ntpstats; ./ntpviz -p 1 -o day
-45 11,23 * * * cd /usr/local/src/NTP/ntpsec/ntpstats; ./ntpviz -p 7 -o week
-
diff --git a/ntpstats/ntpviz b/ntpstats/ntpviz
deleted file mode 100755
index a3da517..0000000
--- a/ntpstats/ntpviz
+++ /dev/null
@@ -1,1738 +0,0 @@
-#!/usr/bin/env python
-# coding: utf-8
-"""\
-ntpviz - logfile visualizer for NTP log files
-
-ntpviz [-d LOGDIR] [-g] [-n name] [-p DAYS]
-         [-s starttime] [-e endtime]
-         [-o OUTDIR]
-         [ -c | --clip ]
-         [ -w SIZE | --width SIZE]
-         [--all-peer-jitters |
-          --all-peer-offsets |
-          --local-error |
-          --local-freq-temps |
-          --local-gps |
-          --local-jitter |
-          --local-offset |
-          --local-offset-histogram |
-          --local-offset-multiplot |
-          --local-stability |
-          --local-temps |
-          --peer-jitters=hosts |
-          --peer-offsets=hosts |
-         ]
-         [-D DLVL | --debug DLVL]
-         [-V | --version]
-         [@OPTIONFILE]
-
-See the manual page for details.
-
-Python by ESR, concept and GNUPLOT code by Dan Drown.
-"""
-#SPDX-License-Identifier: BSD-2-Clause
-from __future__ import print_function, division
-
-import argparse
-import csv
-import datetime
-import re
-import atexit, binascii, collections, os, socket, sys
-import subprocess
-import time
-import tempfile
-
-try:
-    import ntp.statfiles
-    import ntp.util
-except ImportError as e:
-    sys.stderr.write("ntpviz: can't find Python NTP library -- check PYTHONPATH.\n")
-    sys.stderr.write("%s\n" % e)
-    sys.exit(1)
-
-# overload ArgumentParser
-class MyArgumentParser(argparse.ArgumentParser):
-
-    def convert_arg_line_to_args(self, arg_line):
-        '''Make options file more tolerant'''
-        # strip out trailing comments
-        arg_line = re.sub('\s+#.*$', '', arg_line)
-
-        # ignore blank lines
-        if 0 == len(arg_line):
-            return []
-        # ignore comment lines
-        if '#' == arg_line[0]:
-            return []
-
-        return arg_line.split()
-
-
-def print_profile():
-    """called by atexit() on normal exit to print profile data"""
-    pr.disable()
-    pr.print_stats('tottime')
-    pr.print_stats('cumtime')
-
-# standard deviation functions
-# use this until we can guarantee Python 3.4 and the statistics module
-# http://stackoverflow.com/questions/15389768/standard-deviation-of-a-list#21505523
-
-def mean(data):
-    """Return the sample arithmetic mean of data."""
-    n = len(data)
-    if n < 1:
-        raise ValueError('mean requires at least one data point')
-    return sum(data)/n # in Python 2 use sum(data)/float(n)
-
-def _ss(data, mu=None):
-    """Return sum of square deviations of sequence data."""
-    if mu is None:
-        c = mean(data)
-    else:
-        c = mu
-    ss = sum((x-c)**2 for x in data)
-    return ss
-
-# fixme, need to handle mu=mean
-def pstdev(data, mu=None):
-    """Calculates the population standard deviation."""
-    n = len(data)
-    if n < 2:
-        # variance requires at least two data points
-        return 0
-    ss = _ss(data, mu)
-    pvar = ss/n # the population variance
-    return pvar**0.5
-
-# end standard deviation functions
-
-# class for calced values
-class VizStats(ntp.statfiles.NTPStats):
-    percs       = {}          # dictionary of percentages
-    title       = ''          # title
-    unit        = 's'         # display units: s, ppm, etc.
-    multiplier  = 1
-
-    # observe RFC 4180, end lines with CRLF
-    csv_head =  [
-            "Name", "Min", "1%", "5%", "50%", "95%", "99%", "Max", "",
-            "90% Range", "98% Range", "StdDev", "", "Mean", "Units"]
-
-    table_head =  """\
-<table style="text-align:right;">
-<thead>
-  <tr style="font-weight:bold;text-align:left;">
-    <td ></td>
-    <td colspan=8> Percentiles......</td>
-    <td colspan=3> Ranges......</td>
-    <td colspan=2></td>
-    <td ></td>
-  </tr>
-  <tr style="font-weight:bold;text-align:right;">
-    <td style="text-align:left;">Name</td>
-    <td>Min</td><td>1%</td><td>5%</td><td>50%</td><td>95%</td>
-    <td>99%</td><td>Max</td> <td style="width:10px;">&nbsp;</td>
-    <td>90%</td><td>95%</td><td>StdDev</td>
-    <td style="width:10px;">&nbsp;</td><td>Mean</td><td>Units</td>
-  </tr>
-</thead>
-"""
-
-    stats_html  = ''
-
-    def __init__( self, values, title, freq=0 ):
-
-        values.sort()
-        self.percs = self.percentiles( (100, 99, 95, 50, 5, 1, 0), values)
-
-        # find the target for autoranging
-        if args.clip:
-            # keep 99% and 1% under 999 in selected units
-            # clip to 1% and 99%
-            target = max(self.percs["p99"], -self.percs["p1"])
-        else:
-            # keep 99% and 1% under 999 in selected units
-            # but do not let 100% and 1% go over 5000 in selected units
-            target = max(self.percs["p99"], -self.percs["p1"],
-                         self.percs["p100"]/5, -self.percs["p0"]/5)
-
-        if 1 <= target:
-            self.multiplier = 1
-            if freq:
-                # go to ppm
-                self.unit = "ppm"
-            else:
-                # go to seconds
-                self.unit = "s"
-
-        elif 1e-3 <= target:
-            self.multiplier = 1e3
-            if freq:
-                # go to ppb
-                self.unit = "ppb"
-            else:
-                # go to millisec
-                self.unit = "ms"
-
-        elif 1e-6 <= target:
-            self.multiplier = 1e6
-            if freq:
-                self.unit = "10e-12"
-            else:
-                # go to microsec
-                self.unit = "µs"
-
-        else:
-            self.multiplier = 1e9
-            if freq:
-                self.unit = "10e-15"
-            else:
-                # go to nanosec
-                self.unit = "ns"
-
-        self.percs["mu"]      = mean( values )
-        self.percs["pstd"]    = pstdev( values, mu=self.percs["mu"] )
-
-        # range the data
-        self.percs.update({k: v * self.multiplier
-                     for k, v in list(self.percs.items())})
-
-        self.title       = title
-
-        # calculate ranges
-        self.percs["r90"] = self.percs["p95"] - self.percs["p5"]
-        self.percs["r98"] = self.percs["p99"] - self.percs["p1"]
-
-        # calculate mean +/- std dev
-        self.percs["m1sigma"] = self.percs["mu"] - self.percs["pstd"]
-        self.percs["p1sigma"] = self.percs["mu"] + self.percs["pstd"]
-
-        # pretty print the values
-        self.percs_f = {}
-        for k, v in self.percs.items():
-            self.percs[k]   = round(v, 3)
-            self.percs_f[k] = format(v, ",.3f")
-
-        # Python is stupid about nested objects, so add in some other stuff
-        self.percs_f["multiplier"] = self.percs["multiplier"] = self.multiplier
-        self.percs_f["title"]      = self.percs["title"]      = self.title
-        self.percs_f["unit"]       = self.percs["unit"]       = self.unit
-
-        if args.clip:
-            self.percs["min_y"] = self.percs["p1"]
-            self.percs["max_y"] = self.percs["p99"]
-            self.percs["clipped"] = " (clipped)"
-        else:
-            self.percs["min_y"] = self.percs["max_y"] = '*'
-            self.percs["clipped"] = ""
-
-        self.stats_html =  """\
-<br>
-<table style="margin-left:20px;border-spacing: 10px 0;">
-  <tr style="text-align:left;font-weight:bold;">
-    <td colspan=8> Percentiles......</td>
-    <td colspan=3> Ranges......</td>
-    <td colspan=2></td>
-    <td ></td>
-  </tr>
-  <tr style="font-weight:bold;font-weight:bold;text-align:right;">
-    <td style="min-width:55px;">Min</td><td style="min-width:55px;">1%%</td>
-    <td style="min-width:55px;">5%%</td><td style="min-width:55px;">50%%</td>
-    <td style="min-width:55px;">95%%</td><td style="min-width:55px;">99%%</td>
-    <td style="min-width:55px;">Max</td><td>&nbsp;</td>
-    <td style="min-width:55px;">90%%</td><td style="min-width:55px;">98%%</td>
-    <td style="min-width:55px;">StdDev</td>
-    <td>&nbsp;</td><td style="min-width:55px;">Mean</td><td>Units</td>
-  </tr>
-  <tr style="text-align:right;">
-    <td>%(p0)s</td><td>%(p1)s</td><td>%(p5)s</td><td>%(p50)s</td>
-    <td>%(p95)s</td><td>%(p95)s</td><td>%(p100)s</td><td>&nbsp;</td>
-    <td>%(r90)s</td><td>%(r98)s</td><td>%(pstd)s</td><td>&nbsp;</td>
-    <td>%(mu)s</td><td>%(unit)s</td>
-  </tr>
-</table>
-""" % self.percs_f
-
-        s =  ["%(title)s", "%(p0)s", "%(p1)s", "%(p5)s", "%(p50)s", "%(p95)s",
-              " %(p99)s", "%(p100)s", "", "%(r90)s", "%(r98)s", "%(pstd)s",
-              "", "%(mu)s", "%(unit)s"]
-
-        # csv is raw, html table is autoranged
-        self.csv   =  [ x % self.percs for x in s]
-        self.table =  [ x % self.percs_f for x in s]
-        self.table = "</td><td>".join(self.table)
-
-        self.table = '''\
-<tr style="vertical-align:top;">
- <td style="text-align:left;">%s</td>
-</tr>
-''' % self.table
-
-        return
-
-
-# end calc things now
-
-# RMS frequency jitter - Deviation from a root-mean-square linear approximation?
-# Investigate.
-
-def gnuplot(template, outfile=None):
-    "Run a specified GNUPLOT program."
-    if not len( template ):
-        # silently ignore empty plots
-        return ''
-    if outfile is None:
-        out = None
-    else:
-        out = open(outfile, "w")
-    ##
-
-    # can be 30% faster to write to a tmp file than to pipe to gnuplot
-    # bonus, we can keep the plot file for debug.
-    tmp_file, tmp_filename = tempfile.mkstemp( suffix='.plt')
-    # note that tmp_file is a file handle, it is not a file object
-    os.write( tmp_file, template)
-    os.close(tmp_file)
-
-    # shell=True is a security hazard, do not use
-    try:
-        rcode = subprocess.call( ['gnuplot', tmp_filename], stdout=out)
-    except OSError as e:
-        if e.errno == os.errno.ENOENT:
-            # gnuplot not found
-            sys.stderr.write("ntpviz: ERROR: gnuplot not found in path\n")
-        else:
-            # Something else went wrong while trying to run gnuplot
-            sys.stderr.write("ntpviz: ERROR: gnuplot failed\n")
-        raise SystemExit(1)
-
-    if 0 != rcode:
-        sys.stderr.write("ntpviz: WARNING: plot returned %s\n" % rcode)
-        sys.stderr.write("ntpviz: WARNING: plot file %s\n" % tmp_filename)
-    elif 2 <= args.debug_level:
-        sys.stderr.write("ntpviz: INFO: plot file %s\n" % tmp_filename)
-    else:
-        # remove tmp file
-        os.remove(tmp_filename)
-
-    return rcode
-
-class NTPViz(ntp.statfiles.NTPStats):
-    "Class for visualizing statistics from a single server."
-
-    # Python takes single quotes here. Since no % substitution
-    Common = """\
-set grid
-set autoscale xfixmin
-set autoscale xfixmax
-set xdata time
-set xtic rotate by -35 scale 0
-set xlabel "Time (DDMM hh:mm UTC)"
-set format x "%d%b %H:%M"
-set timefmt "%s"
-set lmargin 10
-set rmargin 10
-"""
-
-    def __init__(self, statsdir,
-                 sitename=None, period=None, starttime=None, endtime=None):
-        ntp.statfiles.NTPStats.__init__(self, statsdir=statsdir,
-                    sitename=sitename, period=period, starttime=starttime,
-                    endtime=endtime)
-
-    def plot_slice( self, rows, item1, item2=None):
-        "slice 0,item1, maybe item2, from rows, ready for gnuplot"
-        # speed up by only sending gnuplot the data it will actually use
-        # WARNING: this is hot code, only modify if you profile
-        plot_data = ''
-        last_time = 0
-        if item2:
-            for row in rows:
-                try:
-                    if 1024000 < row[0] - last_time:
-                        # data loss, add a break in the plot line
-                        plot_data += '\n'
-                    # fields: time, fld, and rtt
-                    plot_data += row[1] + ' ' + row[item1] + ' ' + row[item2] + '\n'
-                    last_time = row[0]
-                except IndexError:
-                    pass
-        else:
-            for row in rows:
-                try:
-                    if 1024000 < row[0] - last_time:
-                        # data loss, add a break in the plot line
-                        plot_data += '\n'
-                    # fields: time, fld
-                    plot_data += row[1] + ' ' + row[item1] + '\n'
-                    last_time = row[0]
-                except IndexError:
-                    pass
-        # I know you want to replace the plot_data string concat with
-        # or more join()s, do not do it, it is slower
-        # next you'll want to try %-substitution.  it too is slower
-        plot_data += "e\n"
-        return plot_data
-
-    def local_offset_gnuplot(self):
-        "Generate GNUPLOT code graphing local clock loop statistics"
-        if not len( self.loopstats):
-            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
-            return ''
-
-        # speed up by only sending gnuplot the data it will actually use
-        # fields: time, time offset, freq offset
-        plot_data = self.plot_slice( self.loopstats, 2, 3)
-
-        # compute clock offset
-        values = [float(line[2]) for line in self.loopstats]
-        stats = VizStats( values, "Local Clock Time Offset")
-
-        # compute frequency offset
-        values_f = [float(line[3]) for line in self.loopstats]
-        stats_f = VizStats(values_f, "Local Clock Frequency Offset", freq=1)
-
-        out = stats.percs
-        out["min_y2"] = stats_f.percs["min_y"]
-        out["max_y2"] = stats_f.percs["max_y"]
-        out["unit_f"] = stats_f.percs["unit"]
-        out["multiplier_f"] = stats_f.percs["multiplier"]
-        out["sitename"] = self.sitename
-        out['size'] = args.png_size
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: Local Clock Time/Frequency Offsets%(clipped)s"
-set ytics format "%%1.1f %(unit)s" nomirror textcolor rgb '#0060ad'
-set yrange [%(min_y)s:%(max_y)s]
-set y2tics format "%%2.1f %(unit_f)s" nomirror textcolor rgb '#dd181f'
-set y2range [%(min_y2)s:%(max_y2)s]
-set key bottom right box
-set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
-set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
-plot \
- "-" using 1:($2*%(multiplier)s) title "clock offset %(unit)s" with linespoints ls 1, \
- "-" using 1:($3*%(multiplier_f)s) title "frequency offset %(unit_f)s" with linespoints ls 2 axis x1y2
-""" % out
-
-        exp = """\
-<p>The time and frequency offsets between the ntpd calculated time
-and the local system clock.  Showing frequency offset (red, in parts
-per million, scale on right) and the time offset (blue, in μs, scale
-on left).  Quick changes in time offset will lead to larger frequency
-offsets.</p>
-
-<p>These are fields 3 (time) and 4 (frequency) from the loopstats log
-file.</p>
-
-"""
-
-        ret = {}
-        ret['html'] = stats.stats_html + stats_f.stats_html + exp
-        ret['stats'] = [stats, stats_f]
-        ret['title'] = "Local Clock Time/Frequency Offsets"
-        ret['plot'] = plot_template + plot_data + plot_data
-        return ret
-
-    def local_freq_temps_plot(self):
-        "Generate GNUPLOT code graphing local frequency and temps"
-        if not len( self.loopstats):
-            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
-            return ''
-
-        tempsmap = self.tempssplit()
-        tempslist = tempsmap.keys()
-        tempslist.sort()
-        if not len( tempsmap) or not len( tempslist):
-            sys.stderr.write("ntpviz: WARNING: no temps to graph\n")
-            return ''
-
-        # speed up by only sending gnuplot the data it will actually use
-        # fields: time, freq offset
-        plot_data = self.plot_slice( self.loopstats, 3)
-
-        # compute frequency offset
-        values_f = [float(line[3]) for line in self.loopstats]
-        stats_f = VizStats(values_f, "Local Clock Frequency Offset", freq=1)
-
-        stats = []
-        temps_data = ()
-        plot_data_t = ''
-        for key in tempslist:
-            # speed up by only sending gnuplot the data it will actually use
-            # fields: time, temp
-            plot_data_t += self.plot_slice( tempsmap[key], 3)
-
-        #out = stats.percs
-        out = {}
-        out["min_y2"] = stats_f.percs["min_y"]
-        out["max_y2"] = stats_f.percs["max_y"]
-        out["unit_f"] = stats_f.percs["unit"]
-        out["unit"] = 'C'
-        out["multiplier_f"] = stats_f.percs["multiplier"]
-        out["sitename"] = self.sitename
-        out['size'] = args.png_size
-        if args.clip:
-            out["clipped"] = " (clipped)"
-        else:
-            out["clipped"] = ""
-
-        # let temp autoscale
-        # set yrange [%(min_y)s:%(max_y)s]
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: Local Frequency Offset/Temps%(clipped)s"
-set ytics format "%%1.1f %(unit)s" nomirror textcolor rgb '#0060ad'
-set y2tics format "%%2.1f %(unit_f)s" nomirror textcolor rgb '#dd181f'
-set y2range [%(min_y2)s:%(max_y2)s]
-set key bottom right box
-set style line 1 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
-plot \
- "-" using 1:($2*%(multiplier_f)s) title "frequency offset %(unit_f)s" with linespoints ls 1 axis x1y2, \
-""" % out
-
-        for key in tempslist:
-            out['key'] = key
-            plot_template += "'-' using 1:2 title '%(key)s' with line, \\\n" \
-                 % out
-
-        # strip trailing ", \n"
-        plot_template = plot_template[:-4] + "\n"
-
-        exp = """\
-<p>The frequency offsets and temperatures.
-Showing frequency offset (red, in parts
-per million, scale on right) and the temeratures.</p>
-
-<p>These are field 4 (frequency) from the loopstats log
-file, and field 3 from the temp log .</p>
-
-"""
-
-        ret = {}
-        # ret['html'] = stats.stats_html + stats_f.stats_html + exp
-        ret['html'] = stats_f.stats_html + exp
-        ret['stats'] = [stats, stats_f]
-        ret['stats'] = [stats_f]
-        ret['title'] = "Local Frequency/Temp"
-        ret['plot'] = plot_template + plot_data + plot_data_t
-        return ret
-
-    def local_temps_gnuplot(self):
-        "Generate GNUPLOT code graphing local temperature statistics"
-        sitename = self.sitename
-        tempsmap = self.tempssplit()
-        tempslist = tempsmap.keys()
-        tempslist.sort()
-
-        if not len( tempsmap) or not len( tempslist):
-            sys.stderr.write("ntpviz: WARNING: no temps to graph\n")
-            return ''
-
-        stats = []
-        temps_data = ()
-        plot_data = ''
-        for key in tempslist:
-            # speed up by only sending gnuplot the data it will actually use
-            # fields: time, temp
-            plot_data += self.plot_slice( tempsmap[key], 3)
-
-        out = {}
-        out['sitename'] = sitename
-        out['size'] = args.png_size
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: Local Temparatures"
-set ytics format "%%1.1f °C" nomirror textcolor rgb '#0060ad'
-set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
-plot \\
-""" % out
-
-        for key in tempslist:
-            out['key'] = key
-            plot_template += "'-' using 1:2 title '%(key)s' with line, \\\n" \
-                 % out
-
-        # strip the trailing ", \n"
-        plot_template = plot_template[:-4] + "\n"
-        exp = """\
-<p>Local temperatures.  These will be site specific depending on what
-temperature sensors you have and collect data from.  Temperature
-changes change the local clock crystal frequency and stability.  Crystals
-oscillate faster when warmer. This the single most important
-component of frequency drift.</p>
-<p>The Local Termperatures are from field 3 from the tempstats log file.</p>
-"""
-        ret = {'html' : exp, 'stats' : stats }
-        ret['title'] = "Local Temperatures"
-        ret['plot'] = plot_template + plot_data
-        return ret
-
-    def local_gps_gnuplot(self):
-        "Generate GNUPLOT code graphing local gps statistics"
-        sitename = self.sitename
-        gpsmap = self.gpssplit()
-        gpslist = gpsmap.keys()
-        gpslist.sort()
-
-        if not len( gpsmap) or not len( gpslist):
-            if 1 <= args.debug_level:
-                sys.stderr.write("ntpviz: INFO: no gps data to graph\n")
-            return ''
-
-        stats = []
-        gps_data = ()
-        plot_data = ""
-        for key in gpslist:
-            # fields: time, tdop, nSats
-            plot_data += self.plot_slice( gpsmap[key], 3, 4)
-
-        out = {}
-        out['sitename'] = sitename
-        out['size'] = args.png_size
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: Local GPS
-set ytics format "%%1.1f tdop" nomirror textcolor rgb '#0060ad'
-set y2tics format "%%2.0f nSat"  nomirror textcolor rgb '#dd181f'
-set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
-set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
-plot \\
-""" % out
-
-        for key in gpslist:
-            plot_template += """\
-'-' using 1:2 title '%(key)s tdop' with line ls 1, \\
-'-' using 1:3 title '%(key)s nSat' with line ls 2 axis x1y2, \\
-""" % locals()
-
-        # strip the trailing ", \\n"
-        plot_template = plot_template[:-4] + "\n"
-        exp = """\
-<p>Local GPS.  The Time Dilution of Precision (tdop) is plotted in blue.
-The number of visible satellites (nSat) is plotted in red.</p>
-<p>tdop is field 3, and nSats is field 4, from the gpsd log file.  The
-gpsd log file is created by the gps-log.py program.</p>
-"""
-        ret = {'html' : exp, 'stats' : stats }
-        ret['title'] = "Local GPS"
-        ret['plot'] = plot_template + plot_data + plot_data
-        return ret
-
-    def local_error_gnuplot(self):
-        "Plot the local clock frequency error."
-        if not len( self.loopstats):
-            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
-            return ''
-
-        # grab and sort the values, no need for the timestamp, etc.
-
-        # compute freqency offset
-        values = [float(line[2]) for line in self.loopstats]
-        stats = VizStats( values, "Local Clock Frequency Offset", freq=1, )
-
-        # build the output dictionary, because Python can not format
-        # complex objects.
-        out = stats.percs
-        out["sitename"] = self.sitename
-        out['size'] = args.png_size
-
-        # speed up by only sending gnuplot the data it will actually use
-        # fields: time, freq error
-        plot_data = self.plot_slice( self.loopstats, 3)
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: Local Clock Frequency Offset%(clipped)s"
-set ytics format "%%1.1f %(unit)s" nomirror
-set yrange [%(min_y)s:%(max_y)s]
-set key bottom right box
-set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
-set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
-plot \
- "-" using 1:($2 * %(multiplier)s) title "local clock error" with linespoints ls 2, \
- %(p99)s title "99th percentile", \
- %(p95)s title "95th percentile", \
- %(p5)s title "5th percentile", \
- %(p1)s title "1st percentile"
-""" % out
-
-        exp = """\
-<p>This shows the frequency offset of the local clock (aka drift).  The
-graph includes percentile data to show how much the frequency changes
-over a longer period of time.  The majority of this change should come
-from temperature changes (ex: HVAC, the weather, CPU usage causing local
-heating).</p>
-
-<p>Smaller changes are better.  An ideal result would be a horizontal
-line at 0ppm.  Expected values of 99%-1% percentiles: 0.4ppm</p>
-
-<p>The Frequency Offset comes from field 4 of the loopstats log file.</p>
-"""
-        ret = {'html' : stats.stats_html + exp, 'stats' : [stats] }
-        ret['title'] = "Local Clock Frequency Offset"
-        ret['plot'] = plot_template + plot_data
-        return ret
-
-    def loopstats_gnuplot(self, fld, title, legend, freq):
-        "Generate GNUPLOT code of a given loopstats field"
-        if not len( self.loopstats):
-            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
-            return ''
-
-        # speed up by only sending gnuplot the data it will actually use
-        # fields: time, fld
-        plot_data = self.plot_slice( self.loopstats, fld)
-
-        # grab and process the values
-        values = [float(line[fld]) for line in self.loopstats]
-        stats = VizStats( values, title, freq=freq )
-
-        # build the output dictionary, because Python can not format
-        # complex objects.
-        out = stats.percs
-        out["sitename"] = self.sitename
-        out["fld"]      = fld
-        out["legend"]   = legend
-        out["min_y"] = '0'
-        out['size'] = args.png_size
-
-        if freq:
-            exp = """\
-<p>This shows the RMS Frequency Jitter (aka wander) of the local
-clock's frequency.  In other words, how fast the local clock changes
-freqency.</p>
-
-<p>Lower is better.  An ideal clock would be a horizontal line at
-0ppm.</p>
-
-<p> RMS Frequency Jitter is field 6 in the loopstats log file.</p>
-"""
-        else:
-            exp = """\
-<p>This shows the RMS Jitter of the local clock offset.  In other words,
-how fast the local clock offset is changing.</p>
-
-<p>Lower is better.  An ideal system would be a horizontal line at 0μs.</p>
-
-<p>RMS jitter is field 5 in the loopstats log file.</p>
-"""
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: %(title)s%(clipped)s"
-set ytics format "%%1.1f %(unit)s" nomirror
-set yrange [%(min_y)s:%(max_y)s]
-set key top right box
-set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
-set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
-plot \
- "-" using 1:($2*%(multiplier)s) title "%(legend)s" with linespoints ls 1, \
- %(p99)s title "99th percentile", \
- %(p95)s title "95th percentile", \
- %(p5)s title "5th percentile", \
- %(p1)s title "1st percentile"
-""" % out
-
-        ret = {'html' : stats.stats_html + exp, 'stats' : [stats],
-               'title' : title }
-        ret['plot'] = plot_template + plot_data
-        return ret
-
-    def local_offset_jitter_gnuplot(self):
-        "Generate GNUPLOT code of local clock loop standard deviation"
-        return self.loopstats_gnuplot(4, "Local RMS Time Jitter", "Jitter", 0)
-
-    def local_offset_stability_gnuplot(self):
-        "Generate GNUPLOT code graphing local clock stability"
-        return self.loopstats_gnuplot(5, "Local RMS Frequency Jitter",
-                                      "Stability", 1)
-
-    def peerstats_gnuplot(self, peerlist, fld, title, type):
-        "Plot a specified field from peerstats."
-
-        peerdict = self.peersplit()
-        if not peerlist:
-            peerlist = peerdict.keys()
-        if not len( peerlist):
-            sys.stderr.write("ntpviz: WARNING: no peer data to graph\n")
-            return ''
-        peerlist.sort() # For stability of output
-        namelist = []   # peer names
-
-        ip_todo = []
-        for key in peerlist:
-            # Trickiness - we allow peerlist elements to be DNS names.
-            # The socket.gethostbyname() call maps DNS names to IP addresses,
-            # passing through literal IPv4 addresses unaltered.  However,
-            # it barfs on either literal IPv6 addresses or refclock names.
-            try:
-                ip = socket.gethostbyname(key)
-                namelist.append(key)
-            except:
-                # ignore it
-                ip = key
-                # socket.getfqdn() is also flakey...
-                namelist.append(socket.getfqdn(key))
-
-            if ip in peerdict:
-                ip_todo.append(ip)
-            else:
-                # can this ever happen?
-                sys.stderr.write("ntpviz: ERROR: No such peer as %s" % key)
-                raise SystemExit(1)
-
-        rtt = 0
-        percentages = ""
-        stats = []
-        if len(peerlist) == 1:
-            # only one peer
-            if "offset" == type:
-                # doing offset, not jitter
-                rtt = 1
-                if "127.127." == peerlist[0][:8]:
-                    # don't do rtt for reclocks
-                    rtt = 0
-                    title = "Refclock Offset " + str(peerlist[0])
-                    exp = """\
-<p>This shows the offset of a local refclock in seconds.  This is
-useful to see how the measured offset is behaving.</p>
-
-<p>Closer to 0s is better.  An ideal system would be a horizontal line
-at 0s. Typical 90%% ranges may be: local serial GPS 200 ms; local PPS
-20µs</p>
-
-<p>Clock Offset is field 5 in the peerstats log file.</p>
-"""
-                else:
-                    title = "Peer Offset " + str(peerlist[0])
-                    exp = """\
-<p>This shows the offset of a peer or server in seconds.  This is
-useful to see how the measured offset is behaving.</p>
-
-<p>The chart also plots offset±rtt.  Where rtt is the round trip time
-to the remote.  NTP can not really know the offset of a remote chimer,
-NTP computes it by subtracting rtt/2 from the offset.  Plotting the
-offset±rtt reverses this calculation to more easily see the effects of
-rtt changes.</p>
-
-<p>Closer to 0s is better.  An ideal system would be a horizontal line
-at 0s. Typical 90% ranges may be: local LAN peer 80µs; 90% ranges for
-WAN servers may be 4ms and much larger. </p>
-
-<p>Clock Offset is field 5 in the peerstats log file.  The Round Trip
-Time (rtt) is field 6 in the peerstats file.</p>
-"""
-
-            else:
-                # doing jitter, not offset
-                if "127.127." == peerlist[0][:8]:
-                    title = "Refclock RMS Jitter " + str(peerlist[0])
-                    exp = """\
-<p>This shows the RMS Jitter of a local refclock.  Jitter is the
-current estimated dispersion; the variation in offset between samples.</p>
-
-<p>Closer to 0s is better.  An ideal system would be a horizontal
-line at 0s.</p>
-
-<p>RMS Jitter is field 8 in the peerstats log file.</p>
-"""
-                else:
-                    title = "Peer Jitter " + str(peerlist[0])
-                    exp = """\
-<p>This shows the RMS Jitter of a remote peer or server.  Jitter is
-the current estimated dispersion; the variation in offset between
-samples.</p>
-
-<p>Closer to 0s is better.  An ideal system would be a horizontal line
-at 0s.</p>
-
-<p>RMS Jitter is field 8 in the peerstats log file.</p>
-"""
-
-            # grab and sort the values, no need for the timestamp, etc.
-            values = [float(line[fld]) for line in peerdict[ip]]
-
-            stats = VizStats( values, title)
-
-            if len(namelist[0]) and peerlist[0] != namelist[0]:
-                # append hostname, if we have it
-                # after stats to keep summary short
-                title += " (%s)" % namelist[0]
-
-
-            percentages = " %(p50)s title '50th percentile', " \
-                           % stats.percs
-
-            exp = stats.stats_html + exp
-
-
-        else:
-            # many peers
-            title += "s"
-            # grab and sort the values, no need for the timestamp, etc.
-            values = [float(line[fld]) for line in self.peerstats]
-
-            stats = VizStats( values, title )
-
-            exp = stats.stats_html
-            if "offset" == type:
-                title = "Peer Offsets"
-                exp += """\
-<p>This shows the offset of all refclocks, peers and servers in
-%(unit)s.  This can be useful to see if offset changes are happening in
-a single clock or all clocks together.</p>
-
-<p>Clock Offset is field 5 in the peerstats log file.</p>
-""" % stats.percs
-            else:
-                title = "Peer Jitters"
-                exp += """\
-<p>This shows the RMS Jitter of all refclocks, peers and servers.
-Jitter is the current estimated dispersion; the variation in offset
-between samples.</p>
-
-<p>Closer to 0s is better.  An ideal system would be a horizontal line
-at 0s.</p>
-
-<p>RMS Jitter is field 8 in the peerstats log file.</p>
-"""
-
-        plot_data = ""
-        for ip in ip_todo:
-            # 20% speed up by only sending gnuplot the data it will
-            # actually use
-            if rtt:
-                # fields: time, fld, and rtt
-                plot_data += self.plot_slice( peerdict[ip], fld, 5)
-            else:
-                # fields: time, fld
-                plot_data += self.plot_slice( peerdict[ip], fld)
-
-        out = stats.percs
-        out['sitename'] = self.sitename
-        out['title'] = title
-        out['size'] = args.png_size
-
-        if 6 >= len(peerlist):
-            out['set_key'] = "set key top right box"
-        else:
-            # too many keys to show
-            out['set_key'] = "set key off"
-
-        plot_template = NTPViz.Common + """\
-set terminal png size %(size)s
-set title "%(sitename)s: %(title)s%(clipped)s"
-set ylabel ""
-set ytics format "%%1.1f %(unit)s" nomirror
-set yrange [%(min_y)s:%(max_y)s]
-%(set_key)s
-plot \
-""" % out
-
-        plot_template += percentages
-        for key in peerlist:
-            out['label'] = self.ip_label(key)
-            plot_template += "'-' using 1:($2*%(multiplier)s) title '%(label)s' with line, \\\n" \
-                 % out
-
-        if 1 == rtt:
-            plot_template += """\
-'-' using 1:(($2+$3/2)*%(multiplier)s) title 'offset+rtt/2' with line, \\
-'-' using 1:(($2-$3/2)*%(multiplier)s) title 'offset-rtt/2' with line
-""" % stats.percs
-            # sadly, gnuplot needs 3 identical copies of the data.
-            plot_template += plot_data + plot_data
-        else:
-            # strip the trailing ", \n"
-            plot_template = plot_template[:-4] + "\n"
-
-        ret = {'html' : exp, 'stats' : [stats], 'title' : title }
-        ret['plot'] = plot_template + plot_data
-        return ret
-
-    def peer_offsets_gnuplot(self, peerlist=None):
-        return self.peerstats_gnuplot(peerlist, 4, "Peer Clock Offset", "offset")
-
-    def peer_jitters_gnuplot(self, peerlist=None):
-        return self.peerstats_gnuplot(peerlist, 7, "Peer Clock Jitter", "jitter")
-
-    def local_offset_histogram_gnuplot(self):
-        "Plot a histogram of clock offset values from loopstats."
-        if not len( self.loopstats):
-            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
-            return ''
-
-        # TODO normalize to 0 to 100?
-
-        # grab and sort the values, no need for the timestamp, etc.
-        values = [float(row[2]) for row in self.loopstats]
-        stats = VizStats( values, 'Local Clock Offset' )
-        out = stats.percs
-        out['sitename'] = self.sitename
-        # flip the axis
-        out['min_x']    = out['min_y']
-        out['max_x']    = out['max_y']
-
-        rnd1 = 7        # round to 100 ns boxes
-        out['boxwidth'] = 1e-7
-
-        if 1e-6 > stats.percs["p99"] and -1e-6 < stats.percs["p1"]:
-            # go to nanosec
-            rnd1 = 9        # round to 1 ns boxes
-            out['boxwidth'] = 1e-9
-
-        cnt = collections.Counter()
-        for value in values:
-            # put into buckets
-            # for a +/- 50 microSec range that is 1,000 buckets to plot
-            cnt[ round( value, rnd1)] += 1
-
-        sigma = True
-        if args.clip:
-            if stats.percs['p1sigma'] > stats.percs['p99'] or \
-               stats.percs['m1sigma'] < stats.percs['p1']:
-                # sigma out of range, do not plot
-                sigma = ''
-
-        out['sigma'] = ''
-        if sigma:
-            # plus/minus of one sigma range
-            out['sigma'] = """\
-set style arrow 1 nohead
-set arrow from %(m1sigma)s,graph 0 to %(m1sigma)s,graph 0.90 as 1
-set style arrow 2 nohead
-set arrow from %(p1sigma)s,graph 0 to %(p1sigma)s,graph 0.90 as 2
-set label 1 "-1σ" at %(m1sigma)s, graph 0.96  left front offset -1,-1
-set label 2 "+1σ" at %(p1sigma)s, graph 0.96  left front offset -1,-1
-""" % out
-
-        out['size'] = args.png_size
-
-        # in 2016, 25% of screens are 1024x768, 42% are 1388x768
-        # but leave some room for the browser frame
-        plot_template = '''\
-set terminal png size %(size)s
-set title "%(sitename)s: Local Clock Time Offset Histogram%(clipped)s"
-set grid
-set boxwidth %(boxwidth)s
-set xtic rotate by -35 scale 0
-set xtics format "%%1.1f %(unit)s" nomirror
-set xrange [%(min_x)s:%(max_x)s]
-set yrange [0:*]
-set style arrow 3 nohead
-set arrow from %(p99)s,graph 0 to %(p99)s,graph 0.30 as 3
-set style arrow 4 nohead
-set arrow from %(p95)s,graph 0 to %(p95)s,graph 0.45 as 4
-set style arrow 5 nohead
-set arrow from %(p5)s,graph 0 to %(p5)s,graph 0.45 as 5
-set style arrow 6 nohead
-set arrow from %(p1)s,graph 0 to %(p1)s,graph 0.30 as 6
-set key off
-set lmargin 10
-set rmargin 10
-set style fill solid 0.5
-set label 3 "99%%" at %(p99)s, graph 0.35  left front offset -1,-1
-set label 4 "95%%" at %(p95)s, graph 0.50  left front offset -1,-1
-set label 5 "1%%" at %(p1)s, graph 0.35  left front offset -1,-1
-set label 6 "5%%" at %(p5)s, graph 0.50  left front offset -1,-1
-%(sigma)s
-plot \
- "-" using ($1 * %(multiplier)s):2 title "histogram" with boxes
-''' % out
-
-        histogram_data = ["%s %s\n" % (k, v) for k,v in cnt.items() ]
-
-        exp = """\
-<p>This shows the clock offsets of the local clock as a histogram.</p>
-
-<p>The Local Clock Offset is field 3 from the loopstats log file.</p>
-"""
-        # don't return stats, it's just a dupe
-        ret = {'html' : stats.stats_html + exp, 'stats' : []}
-        ret['title'] = "Local Clock Time Offset Histogram"
-        ret['plot'] = plot_template + "".join(histogram_data) + "e\n"
-        return ret
-
-# Multiplotting can't live inside NTPViz because it consumes a list
-# of such objects, not a single one.
-
-def local_offset_multiplot(statlist):
-    "Plot comparative local offsets for a list of NTPViz objects."
-
-    out = []
-    out['size'] = args.png_size
-
-    plot = NTPViz.Common + '''\
-set terminal png size %(size)s
-set title "Multiplot Local Clock Offsets"
-set ytics format "%1.2f μs" nomirror textcolor rgb "#0060ad"
-set key bottom right box
-plot \\
-''' % out
-    # FIXME: We probably need to be more flexible about computing the plot label
-    sitenames = [os.path.basename(os.path.dirname(d)) for d in args.statsdirs]
-    for (i, stats) in enumerate(statlist):
-        plot += '"-" using 1:($2*1000000) title "%s clock offset μs" with linespoints, \\\n' % (sitenames[i])
-    plot = plot[:-4] + "\n"
-
-    plot_data = ''
-    for stats in statlist:
-        # speed up by only sending gnuplot the data it will actually use
-        # fields: time, offset
-        plot_data += self.plot_slice( stats.loopstats, 2)
-
-    ret = {'html' : '', 'stats' : [] }
-    ret['title'] = "Multiplot"
-    ret['plot'] = plot + plot_data
-    return ret
-
-# here is how to create the base64 from an image file:
-# with open("path/to/file.png", "rb") as f:
-#    data = f.read()
-#    print data.encode("base64")
-#
-ntpsec_logo = """
-iVBORw0KGgoAAAANSUhEUgAAAEAAAABKCAQAAACh+5ozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdC
-AK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dE
-AP7wiPwpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFKElEQVRo3s2ZT0wcVRzHPzMLKCwsNgqLkYPS
-xBjbRF3TcKlC4VAhFU0AdRN7a+zBEsUEL0qImqoxMTWhBzEkTdqmREhMCgpeiiV6KVE46MVE1KQg
-uxv/df81tLvzPOzsMjs7sztvd7b4ndPsfPf3vu/33vv93vs9yGCIJMLyWaKJXTSxZMMTCITilJ1k
-KENRdeoB6rHGYboNb80cpAjEQZoNr90ctiHWcyBfgD0aCZTk2CFAYylKTd7bVZYNknycwGf5ryjT
-RE2/OWVr9Bh9ahbwnuGtnRdsTZ5h0/Rbhr1PDYhNUZyt2guwRjdazi8+G0lZeMWoeExna3mzxwbO
-BDgwlIWQYhefhCkSNl8SpCpkO/JAiHFO00D+kCokGa8JpRyylSTjIlSeAPiC7/AU/JomknLM9qRb
-Ijv8XaaANNs4hyU7VcJE6UBUZeR7wLjgqgXT4jQL6JYw5Qqy/U3e6YazLWY9cJ5DDOc+/kvU9aHQ
-8HFP7m2O8/kCwoyQYgAvAD8xwja1rjUugA7e15NzgnlGCRfSvATZII1A4yv1KIqL/R/iF9IIBCGC
-itfOtEoHs/qeJURQ90elaGOCbQSCtLKhDOd/LJTiZ1KfDXGW+aFiP2h00o8CJJhX3m75PabdLMZX
-jIrdfIq6vhDDhFxtfkV9xtqXlrmgjltzHGIMSBMhXcEAeGjFAyxrX1sTLAXcAvTsHuE5tixjgga6
-NA92OUXjAS5zfzGFpXZEabb5w7Jn99LMAI3EmecGf9n4SS3lPydbskKjD3GcIM3ch4c0Y9xghgv8
-hiZvrBwBg3zIgwj+1FN9LfsZ52Uu8ikhWWPyAoY5Swu/coEZYmio+DhGD31M8CgjViG2PEwgEFyn
-3dR8GMEsHahAF+/SBezGjkums1A71xEIJtwR0K837zdwdk0HiRNnQE6ATNL1cpJWFjll4+YF5vFy
-Qi6DyAhop5MkU0Rsvsd5hzC99FZLwAB+NlktwtjkGg08US0BDcDlogstwRoQkBkE2WVYePw6ondD
-ZZUFAALssz2mVSwgHzFCPMwjAHhoY1HehKyAAF5D76aZNXyL6nF/jX+qI2CdJJ2087Ohyfw6iZcA
-sOZ8AOQm4Sqb+HmpCKOXXhKsS9iUEhDiEnCc/TbfWzmJlytcqZYAuMgG+/kgF4qN8HOWfiJMyQxA
-MRRLRoscy0s62e18GNOmu3QukF0Fc8AkfTzFN6zwJXEET9LF83QQ4RRz7vTe3gOg0McCMQQpQmyx
-RRRBnAX6LPa9rnsABEt8yxG6eFavC8dZYYqrxMvpZ3mRMM4Ci3ycqwhFC+qmVRYAsvWjsgX4GC2/
-d5SurNoK8Oo1ch9vuNFP+XN2kJjLR9Nh64asPNDEa7xKIxVNLgN8+PAzCVZRwurEGuQzGoEwr7Ni
-USmVQ5ouPsFPpgzkIFBlD+a2TpOF6txmPtXVMpkTCZ5d2jaDblaoABjUqy4mCcZ2+jlHK3CTt/gc
-xdUqmUDwIqepBzY4ykahgFbO0Q9AirCp6u8OFPz6qpvhlcLMMeZ6Wcr+iSu5E+TuTGvIyqzuA4BX
-5E5P5kAUrZuucSP42CDl2zHdLhYI2DmzsylhURYFd5F7fmOy5wJqaFbb7h5Q65PdGoDvrtEqz4HM
-APTUfn97HZW4whKPKy14sgvf9QhoQi7ARImi8KNSlZAjgewqcCfzy0DfrGUFTPORi1c0pXGbNzOb
-vV0PuFZgdAjd4/+DZZjBnbgzNSJ3f7rnq0AltrcCPMR4mro9a3/9Pwl2Z1Rsm9zNAAAAJXRFWHRk
-YXRlOmNyZWF0ZQAyMDE1LTA2LTI5VDE4OjMwOjA3LTA0OjAwZxkj2wAAACV0RVh0ZGF0ZTptb2Rp
-ZnkAMjAxNS0wNi0yOVQxODozMDowNy0wNDowMBZEm2cAAAAASUVORK5CYII=
-"""
-
-ntpsec_ico = """\
-AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
-AAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/
-AAAA/wAAAP8AAAD/AAAAAAAAAP+fn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cf
-n59gn5+fYJ+fn2B/f39/AAAA/wAAAAAAAAAAAAAA/5+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+f
-n2Cfn59gn5+fYJ+fn2Cfn59gAAAA/wAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA
-/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59g
-n5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+f
-n59gn5+fYAAAAP8AAAD/AAAA/wAAAP8AAAD/n5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAA
-AAAAAAD/n5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA
-AAAAAAAAAAAAAAAA/5+fn2AAAAD/AAAAAAAAAAAAAAD/AAAA/01NTWAAAAD/n5+fYAAAAP8AAAAA
-AAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA/wAAAAAAAAAAAAAA/5+fn2AA
-AAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/n5+fYAAAAP8AAAAAAAAAAE1NTWAAAAAAAAAAAAAA
-AP+fn59gAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59gAAAA/wAAAP8AAAD/AAAA
-/wAAAP+fn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAEBAf+fn59gn5+fYJ+fn2Cfn59g
-n5+fYJ+fn2Cfn59gn5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8A
-AAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAA
-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAA
-/wAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAA/wAAAAAAAAAA
-AAAAAAAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8A
-AAAAgAAAAL/+AADf/QAAwAEAAO/7AADsGwAA6+sAAOsrAADrawAA6+sAAOwbAADv+wAA4AMAAN/9
-AADRxQAAxBEAAA==
-"""
-
-if __name__ == '__main__':
-
-    parser = MyArgumentParser(description="ntpd stats visualizer",
-                fromfile_prefix_chars='@',
-                epilog = """
-You can place command line options in a file, one per line.
-
-See the manual page for details.
-
-Python by ESR, concept and GNUPLOT code by Dan Drown.
-""")
-    group = parser.add_mutually_exclusive_group()
-
-    parser.add_argument('-c', '--clip',
-                action="store_true",
-                default = None,
-                dest='clip',
-                help="Clip plots at 1%% and 99%%")
-    parser.add_argument('-d', '--datadir',
-                default = "/var/log/ntpstats",
-                dest='statsdirs',
-                help="one or more logfile directories to read",
-                type=str)
-    parser.add_argument('-e', '--endtime',
-                default=None,
-                dest='endtime',
-                help="End time in POSIX (seconds) or ISO 8601",
-                type=str)
-    parser.add_argument('-g', '--generate',
-                action="store_true",
-                default=False,
-                dest='generate',
-                help="Run plot through gnuplot to make png")
-    parser.add_argument('-n', '--name',
-                default=socket.getfqdn(),
-                dest='sitename',
-                help="sitename (title)",
-                type=str)
-    parser.add_argument('-o', '--outdir',
-                default = "ntpgraphs",
-                dest='outdir',
-                help="output directory",
-                type=str)
-    parser.add_argument('-p', '--period',
-                default = 7,    # default to 7 days
-                dest='period',
-                help="period in days to graph (float)",
-                type=float)
-    parser.add_argument('-s', '--starttime',
-                default=None,
-                dest='starttime',
-                help="Start time in POSIX (seconds) or ISO 8601",
-                type=str)
-    parser.add_argument('-w', '--width',
-                choices=['s', 'm', 'l'],
-                default='m',
-                dest='width',
-                help="PNG width: s, m, or l",
-                type=str)
-    group.add_argument( '--all-peer-jitters',
-                default = False,
-                action="store_true",
-                dest='show_peer_jitters',
-                help="Plot all peer jitters")
-    group.add_argument( '--peer-jitters',
-                default = '',
-                dest='peer_jitters',
-                help="Plot peer jitters.  Comma separated host list.",
-                type=str)
-    group.add_argument( '--all-peer-offsets',
-                default = False,
-                action="store_true",
-                dest='show_peer_offsets',
-                help="Plot all peer offsets")
-    group.add_argument( '--peer-offsets',
-                default = '',
-                dest='peer_offsets',
-                help="Plot peer offsets.  Comma separated host list.",
-                type=str)
-    group.add_argument( '--local-error',
-                default=False,
-                action="store_true",
-                dest='show_local_error',
-                help="Plot local clock frequency offsets")
-    group.add_argument( '--local-freq-temps',
-                default = False,
-                action="store_true",
-                dest='show_freq_temps',
-                help="Plot local frequency vs temperature data")
-    group.add_argument( '--local-gps',
-                default = False,
-                action="store_true",
-                dest='show_gps',
-                help="Plot gpsd tdop and nSats")
-    group.add_argument( '--local-jitter',
-                default=False,
-                action="store_true",
-                dest='show_local_jitter',
-                help="Plot clock time jitter")
-    group.add_argument( '--local-offset',
-                default=False,
-                action="store_true",
-                dest='show_local_offset',
-                help="Plot Clock frequency offset")
-    group.add_argument( '--local-offset-histogram',
-                default=False,
-                action="store_true",
-                dest='show_local_offset_histogram',
-                help="Plot histogram of loopstats time offsets")
-    group.add_argument( '--local-offset-multiplot',
-                default = False,
-                action="store_true",
-                dest='show_local_offset_multiplot',
-                help="Plot comparative local offsets for multiple directories")
-    group.add_argument( '--local-stability',
-                default=False,
-                action="store_true",
-                dest='show_local_stability',
-                help="Plot RMS frequency-jitter")
-    group.add_argument( '--local-temps',
-                default = False,
-                action="store_true",
-                dest='show_temps',
-                help="Plot local temperature data")
-    parser.add_argument('-D', '--debug',
-                default=0,
-                dest='debug_level',
-                help="debug level, 0 (none) to 9 (most)",
-                type=int)
-    parser.add_argument('-V', '--version',
-                action="store_true",
-                default=False,
-                dest='version',
-                help="Print version and exit")
-
-    args = parser.parse_args()
-
-    version = ntp.util.stdversion()
-
-    if args.version:
-        print(version)
-        raise SystemExit(1)
-
-    if 's' == args.width:
-        # fit in 1024x768 browser
-        # in 2016 this is 22% of all browsers
-        args.png_size = '1000,720'
-    elif 'l' == args.width:
-        # fit in 1920x1080 browser
-        args.png_size = '1850,1000'
-    else:
-        # fit in 1388x768 browser
-        # in 2016 this is 42% of all browsers
-        args.png_size = '1340,720'
-
-    args.period = int( float(args.period) * ntp.statfiles.NTPStats.SecondsInDay)
-    if args.endtime is not None:
-        args.endtime = iso_to_posix(args.endtime)
-    if args.starttime is not None:
-        args.starttime = iso_to_posix(args.starttime)
-
-    args.statsdirs = [os.path.expanduser(path)
-                     for path in args.statsdirs.split(",")]
-
-    if True == args.show_peer_offsets:
-        args.show_peer_offsets = []
-    elif 0 < len(args.peer_offsets):
-        args.show_peer_offsets = args.peer_offsets.split(",")
-    else:
-        args.show_peer_offsets = None
-
-    if True == args.show_peer_jitters:
-        args.show_peer_jitters = []
-    elif 0 < len(args.peer_jitters):
-        args.show_peer_jitters = args.peer_jitters.split(",")
-    else:
-        args.show_peer_jitters = None
-
-    if 0 < args.debug_level:
-        sys.stderr.write("ntpviz: INFO: now running at debug: %s\n" % \
-            args.debug_level)
-        sys.stderr.write("ntpviz: INFO: Version: %s\n" % version)
-        sys.stderr.write("ntpviz: INFO: Parsed Options %s\n" % args)
-
-        if 9 == args.debug_level:
-            # crazy debug, also profile
-            import cProfile, pstats
-            pr = cProfile.Profile()
-            pr.enable()
-
-            # register to dump debug on all normal exits
-            atexit.register( print_profile )
-
-    nice = 19       # always run nicely
-    if 0 != nice:
-        try:
-            import psutil
-            # set ionice() to idle
-            p = psutil.Process(os.getpid())
-            p.ionice(psutil.IOPRIO_CLASS_IDLE)
-
-        except ImportError:
-            if 0 < args.debug_level:
-                sys.stderr.write("ntpviz: INFO: psutils not found\n")
-            pass
-
-        # set nice()
-        nice = os.nice( nice )
-        if 2 < args.debug_level:
-            sys.stderr.write("ntpviz: INFO: now running at nice: %s\n" % \
-                nice)
-
-    for fontpath in ("/usr/share/fonts/liberation",
-                     "/usr/share/fonts/liberation-fonts",
-                     "/usr/share/fonts/truetype/liberation"):
-
-        if os.path.exists(fontpath):
-            os.environ["GDFONTPATH"] = fontpath
-            break
-    else:
-        sys.stderr.write("ntpviz: WARNING: liberation truetype fonts not found\n")
-    os.environ["GNUPLOT_DEFAULT_GDFONT"] = "LiberationSans-Regular"
-
-    plot = None
-
-    if 1 == len(args.statsdirs):
-        statlist = [NTPViz(statsdir=args.statsdirs[0], sitename=args.sitename,
-                        period=args.period, starttime=args.starttime,
-                        endtime=args.endtime)]
-    else:
-        statlist = [NTPViz(statsdir=d, sitename=d,
-                        period=args.period, starttime=args.starttime,
-                        endtime=args.endtime)
-                for d in args.statsdirs]
-
-    if len(statlist) == 1:
-        stats = statlist[0]
-
-        if args.show_local_offset or \
-           args.show_local_error or \
-           args.show_local_jitter or \
-           args.show_local_stability or \
-           args.show_local_offset_histogram:
-            if not len( stats.loopstats ):
-                sys.stderr.write("ntpviz: ERROR: missing loopstats data\n")
-                raise SystemExit(1)
-
-            if args.show_local_offset:
-                plot = stats.local_offset_gnuplot()
-            elif args.show_local_error:
-                plot = stats.local_error_gnuplot()
-            elif args.show_local_jitter:
-                plot = stats.local_offset_jitter_gnuplot()
-            elif args.show_local_stability:
-                plot = stats.local_offset_stability_gnuplot()
-            elif args.show_local_offset_histogram:
-                plot = stats.local_offset_histogram_gnuplot()
-
-        if None != args.show_peer_offsets or \
-           None != args.show_peer_jitters:
-            if not len( stats.peerstats ):
-                sys.stderr.write("ntpviz: ERROR:  missing peerstats data\n")
-                raise SystemExit(1)
-            if None != args.show_peer_offsets:
-                plot = stats.peer_offsets_gnuplot(args.show_peer_offsets)
-            if None != args.show_peer_jitters:
-                plot = stats.peer_jitters_gnuplot(args.show_peer_jitters)
-
-        if args.show_freq_temps:
-            if not len( stats.temps):
-                sys.stderr.write("ntpviz: ERROR: missing temps data\n")
-                raise SystemExit(1)
-            plot = stats.local_freq_temps_plot()
-
-        if args.show_temps:
-            if not len( stats.temps):
-                sys.stderr.write("ntpviz: ERROR: missing temps data\n")
-                raise SystemExit(1)
-            plot = stats.local_temps_gnuplot()
-
-        if args.show_gps:
-            if not len( stats.gpsd):
-                sys.stderr.write("ntpviz: ERROR: missing gps data\n")
-                raise SystemExit(1)
-            plot = stats.local_gps_gnuplot()
-
-    if args.show_local_offset_multiplot:
-        plot = local_offset_multiplot(statlist)
-
-    if None != plot:
-        # finish up the plot, and exit
-        if args.generate:
-            gnuplot(plot['plot'])
-        else:
-            sys.stdout.write(plot['plot'])
-        raise SystemExit(0)
-
-    # Fall through to HTML code generation
-    if not os.path.isdir(args.outdir):
-        try:
-            os.mkdir(args.outdir)
-        except SystemError:
-            sys.stderr.write("ntpviz: ERROR: %s can't be created.\n" \
-                 % args.outdir)
-            raise SystemExit(1)
-
-    # if no ntpsec favicon.ico, write one.
-    ico_filename = os.path.join(args.outdir, "favicon.ico")
-    if not os.path.lexists( ico_filename ):
-        with open( ico_filename, "w" ) as wp:
-            wp.write(binascii.a2b_base64(ntpsec_ico))
-
-    # if no ntpsec logo, write one.
-    logo_filename = os.path.join(args.outdir, "ntpsec-logo.png")
-    if not os.path.lexists( logo_filename ):
-        with open( logo_filename, "w" ) as wp:
-            wp.write(binascii.a2b_base64(ntpsec_logo))
-
-    report_time = datetime.datetime.utcnow() # the time now is...
-    report_time = report_time.strftime("%c") # format it nicely
-
-    title = args.sitename
-
-    index_header = '''\
-<!DOCTYPE html>
-<html lang="en">
-<head>
-<link rel="shortcut icon" href="favicon.ico">
-<meta charset="UTF-8">
-<meta http-equiv="refresh" content="1800">
-<meta name="expires" content="0">
-<title>%(title)s</title>
-<style>
-dt {
-    font-weight: bold;
-    margin-left: 20px;
-}
-dd {
-    margin-top: 4px;
-    margin-bottom: 10px;
-}
-</style>
-</head>
-<body>
-<div style="width:910px">
-<a href='https://www.ntpsec.org/'>
-<img src="ntpsec-logo.png" alt="NTPsec" style="float:left;margin:20px 70px;">
-</a>
-<div>
-<h1 style="margin-bottom:10px;">%(title)s</h1>
-<b>Report generated:</b> %(report_time)s UTC <br>
-''' % locals()
-
-    # Ugh.  Not clear what to do in the multiplot case
-    if len(statlist) == 1:
-        start_time = datetime.datetime.utcfromtimestamp( stats.starttime
-                         ).strftime('%c')
-        end_time = datetime.datetime.utcfromtimestamp( stats.endtime
-                         ).strftime('%c')
-
-        index_header += '<b>Start Time:</b> %s UTC<br>\n' \
-                        '<b>End Time:</b> %s UTC<br>\n' \
-                 % (start_time, end_time)
-        index_header += '<b>Report Period:</b> %1.1f days <br>\n' \
-                 % (float(stats.period) / \
-                     float(ntp.statfiles.NTPStats.SecondsInDay))
-
-    if args.clip:
-        index_header += """\
-<span style="color:red;font-weight:bold;">Warning: plots clipped</span><br>
-"""
-
-    index_header += '</div>\n<div style="clear:both;"></div>'
-
-    index_trailer = '''\
-<h2>Glossary:</h2>
-
-<dl>
-<dt>frequency offset:</dt>
-<dd>The difference between the ntpd calculated frequency and the local
-system clock frequency (usually in parts per million, ppm)</dd>
-
-<dt>jitter, dispersion:</dt>
-<dd>The short term change in a value</dd>
-
-<dt>ms, millisecond:</dt>
-<dd>One thousandth of a second = 0.001s</dd>
-
-<dt>mu, mean:</dt>
-<dd>The arithmetic mean: the sum of all the values divided by the
-number of values.</dd>
-
-<dt>ns, nanosecond:</dt>
-<dd>One billionth of a second, also one thousandth of a microsecond,
-0.000000001s.</dd>
-
-<dt>percentile:</dt>
-<dd>The value below which a given percentage of values fall.</dd>
-
-<dt>ppb, parts per billion:</dt>
-<dd>Ratio between two values. These following are all the same:
-    1 ppb, one in one billion, 1/1,000,000,000, 0.000,000,001, and
-    0.000,000,1%</dd>
-
-<dt>ppm, parts per million:</dt>
-<dd>Ratio between two values. These following are all the same:
-    1 ppm, one in one million, 1/1,000,000, 0.000,001, and 0.000,1%</dd>
-
-<dt>ppt, parts per thousand:</dt>
-<dd>Ratio between two values. These following are all the same:
-    1 ppt, one in one thousand, 1/1,000, 0.001, and 0.1%</dd>
-
-<dt>refclock:</dt>
-<dd>Reference clock, a local GPS module or other local source of time.</dd>
-
-<dt>remote clock:</dt>
-<dd>Any clock reached over the network, LAN or WAN.  Also called a peer
-or server.</dd>
-
-<dt>time offset:</dt>
-<dd>The difference between the ntpd calculated time and the local system
- clock's time.  (Also can be called phase offset)</dd>
-
-<dt>upstream clock:</dt>
-<dd>Any remote clock or reference clock used as a source of time.</dd>
-
-<dt>σ, sigma:</dt>
-<dd>Sigma denotes the standard deviation (SD) and is centered on the
-arithmetic mean of the data set. The SD is simply the square root of
-the variance of the data set.  Two sigma is simply twice the standard
-deviation.  Three sigma is three times sigma.  Smaller is better.</dd>
-
-<dt>µs, us, microsecond:</dt>
-<dd>One millionth of a second, also one thousandth of a millisecond,
-0.000,001s.</dd>
-</dl>
-
-<br>
-<br>
-<br>
-<div style="float:left">
-This page autogenerated by <a href="https://docs.ntpsec.org/latest/ntpviz.html">
-ntpviz</a>, part of the <a href="https://www.ntpsec.org/">NTPsec project</a>
-</div>
-<div style="float:left;margin-left:350px;">
-    <a href="https://validator.w3.org/nu/">
-    <img src="https://www.w3.org/html/logo/downloads/HTML5_Logo_32.png"
-        alt="html 5">
-    </a>
-&nbsp;&nbsp;
-    <a href="https://jigsaw.w3.org/css-validator/check/referer">
-        <img style="border:0;width:88px;height:31px"
-            src="https://jigsaw.w3.org/css-validator/images/vcss"
-            alt="Valid CSS!" />
-    </a>
-</div>
-<div style="clear:both;"></div>
-</div>
-</body>
-</html>
-'''
-    imagewrapper = "<img src='%s.png' alt='%s plot'>\n"
-
-    # buffer the index.html output so the index.html is not empty
-    # during the run
-    index_buffer = index_header
-    # if header file, add it to index.html
-    header = os.path.join(args.outdir, "header")
-    if os.path.isfile(header):
-        try:
-            header_file = open( header, 'r')
-            header_txt = header_file.read()
-            index_buffer += '<br>\n' + header_txt + '\n'
-        except IOError:
-            pass
-
-    if len(statlist) > 1:
-        index_buffer += local_offset_multiplot(statlist)
-    else:
-        # imagepairs in the order of the heml entries
-        imagepairs = [
-            ("local-offset", stats.local_offset_gnuplot()),
-            # skipa next one, redundant to one above
-            #("local-error", stats.local_error_gnuplot()),
-            ("local-jitter", stats.local_offset_jitter_gnuplot()),
-            ("local-stability", stats.local_offset_stability_gnuplot()),
-            ("local-offset-histogram", stats.local_offset_histogram_gnuplot()),
-            ("local-temps", stats.local_temps_gnuplot()),
-            ("local-freq-temps", stats.local_freq_temps_plot()),
-            ("local-gps", stats.local_gps_gnuplot()),
-            ("peer-offsets", stats.peer_offsets_gnuplot()),
-        ]
-
-        peerlist = stats.peersplit().keys()
-        # sort for output order stability
-        peerlist.sort()
-        for key in peerlist:
-            imagepairs.append(("peer-offset-" + key,
-                           stats.peer_offsets_gnuplot([key])))
-
-        imagepairs.append(("peer-jitters",
-                           stats.peer_jitters_gnuplot()))
-        for key in peerlist:
-            imagepairs.append(("peer-jitter-" + key,
-                           stats.peer_jitters_gnuplot([key])))
-
-        stats = []
-        for (imagename, image) in imagepairs:
-            if not image:
-                continue
-            if 1 <= args.debug_level:
-                sys.stderr.write("ntpviz: plotting %s\n" % image['title'])
-            stats.append( image['stats'] )
-            # give each H2 an unique ID.
-            id = image['title'].lower()
-            id = id.replace(' ', '_').replace(':', '_')
-            index_buffer += """\
-<div>\n<h2 id="%s">%s:</h2>
-""" % (id, image['title'])
-
-            div_name = imagename.replace('-', ' ')
-            index_buffer += imagewrapper % \
-                             (imagename.replace(':', '%3A'), div_name)
-            if image['html']:
-                index_buffer += "<div>\n%s</div>\n" % image['html']
-            index_buffer += "<br><br>\n"
-            gnuplot(image['plot'], os.path.join(args.outdir, imagename + ".png"))
-            index_buffer += "</div>\n"
-
-    # dump stats
-    csvs = []
-    if True:
-        index_buffer += '<div id="Summary"><h2>Summary</h2>\n'
-        index_buffer += VizStats.table_head
-        for stat in stats:
-            if [] == stat:
-                continue
-            for sta in stat:
-                index_buffer += str( sta.table )
-                csvs.append(sta.csv)
-        # RFC 4180 specifies the mime-type of a csv
-        # your webserver should be programmed the same
-        index_buffer += """\
-</table>
-<a href="summary.csv" target="_blank"
-  type="text/csv;charset=UTF-8;header=present;">Summary as CSV file</a><br>
-</div>
-"""
-
-    # if footer file, add it to index.html
-    footer = os.path.join(args.outdir, "footer")
-    if os.path.isfile(footer):
-        try:
-            footer_file = open( footer, 'r')
-            footer_txt = footer_file.read()
-            index_buffer += '<br>\n' + footer_txt + '\n'
-        except IOError:
-            pass
-    index_buffer += index_trailer
-
-    # and send the file buffer
-    index_filename = os.path.join(args.outdir, "index.html")
-    with open(index_filename + ".tmp", "wb") as ifile:
-        ifile.write(index_buffer)
-
-    # create csv file, as a tmp file
-    csv_filename = os.path.join(args.outdir, "summary.csv")
-    with open( csv_filename + ".tmp", "wb" ) as csv_file:
-        csv_ob = csv.writer(csv_file)
-        csv_ob.writerow(VizStats.csv_head)
-        for row in csvs:
-            csv_ob.writerow(row)
-
-    # move new index and summary into place
-    # windows python 2.7, 3.6 has no working rename, so delete and move
-    try:
-        os.remove(csv_filename)
-        os.remove( index_filename)
-    except:
-        pass
-
-    os.rename( csv_filename + ".tmp", csv_filename)
-    os.rename( index_filename + ".tmp", index_filename)
-
-
-# end
diff --git a/ntpstats/ntpviz-man.txt b/ntpstats/ntpviz-man.txt
deleted file mode 100644
index a891da1..0000000
--- a/ntpstats/ntpviz-man.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-= ntpviz(1) =
-:doctype: manpage
-
-== NAME ==
-ntpviz - make visualizations of offset, jitter, etc. from stats file data
-
-include::../docs/includes/ntpviz-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0::
-  Successful program execution.
-1::
-  The operation failed, usually due to a missing logfile required for
-  a plot.
-2::
-  Illegal command-line option.
-
-// end
diff --git a/ntpsweep/ntpsweep b/ntpsweep/ntpsweep
deleted file mode 100755
index 9a335d1..0000000
--- a/ntpsweep/ntpsweep
+++ /dev/null
@@ -1,181 +0,0 @@
-#!/usr/bin/env python
-"""
-ntpsweep - Print various information about given ntp servers.
-USAGE: ntpsweep [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [hostfile]
-
-    -l, --host-list=str        Host to execute actions on
-                                   - may appear multiple times
-    -p, --peers                Recursively list all peers a host synchronizes to
-    -m, --maxlevel=num         Traverse peers up to this level (4 is a reasonable number)
-    -s, --strip=str            Strip this string from hostnames
-
-Options are specified by doubled hyphens and their name or by a single
-hyphen and the flag character.
-"""
-# SPDX-License-Identifier: BSD-2-clause
-#
-# Python translation by ESR of a Perl script written long ago by
-# Hans Lambermont <ntpsweep@lambermont.dyndns.org>
-#
-# It is unclear how useful this will be under modern conditions (e.g. most
-# hosts refuse to be queried, and requests to them will just time out).
-
-from __future__ import print_function
-
-import os, sys, getopt
-import ntp.packet, ntp.util
-
-def ntp_peers(host):
-    "Return a list of peer IP addrs for a specified host, empty list if query failed."
-    try:
-        with os.popen("ntpq -npw " + host) as rp:
-            hostlines = rp.readlines()[2:]	# Drop display header
-            # Strip tally mark from first field
-            return [ln.split()[0][1:] for ln in hostlines if ln[0] in " x.-+#*o"]
-    except OSError:
-        return []
-
-def scan_host(host, level):
-    stratum = 0
-    offset = 0
-    daemonversion = ""
-    system = ""
-    processor = ""
-    peers = []
-    known_host = False
-
-    if host in known_host_info:
-        known_host = True
-    else:
-        session = ntp.packet.ControlSession()
-        session.openhost(host)
-        sysvars = session.readvar()
-
-        # got answers ? If so, go on.
-        if isinstance(sysvars, dict):
-            stratum       = sysvars['stratum']
-            offset        = sysvars['offset']
-            daemonversion = sysvars['version']
-            system        = sysvars['system']
-            processor     = sysvars['processor']
-
-            # Shorten daemon_version string.
-            #daemonversion =~ s/(|Mon|Tue|Wed|Thu|Fri|Sat|Sun).*$//
-            daemonversion = daemonversion.replace("version=", "")
-            daemonversion = daemonversion.replace("ntpd ", "")
-            daemonversion = daemonversion.replace("(", "").replace(")", "")
-            daemonversion = daemonversion.replace("beta", "b")
-            daemonversion = daemonversion.replace("multicast", "mc")
-
-            # Shorten system string. Note, the assumptions here
-            # are very old, reflecting ancient big-iron Unixes
-            system = system.replace("UNIX/", "")
-            system = system.replace("RELEASE", "r")
-            system = system.replace("CURRENT", "c")
-
-            # Shorten processor string
-            processor = processor.replace("unknown", "")
-
-        # got answers ? If so, go on.
-        if daemonversion and recurse:
-            # Consider doing something more intelligent on failure
-            # than simply returning an empty list.  Though it might
-            # be the right thing to do under modern conditions in
-            # which most hosts will refuse to be queried.
-            known_host_peers[host] = ntp_peers(host)
-
-        # Collect info on host
-        if stratum:
-            known_host_info[host] = "%2d %9.3f %-11s %-12s %s"  \
-                                    % (stratum, offset, daemonversion[:11],
-                                       system[:12], processor[0:9])
-        else:
-            # Stratum level 0 is considered invalid
-            known_host_info[host] = " ?"
-
-    if stratum or known_host: # Valid or known host
-        printhost = (' ' * level) + (ntp.util.canonicalize_dns(host) or host)
-        # Shorten host string
-        if strip:
-            printhost = printhost.replace(strip, "")
-        # append number of peers in brackets if requested and valid
-        if recurse and known_host_info[host] != " ?" and host in known_host_peers:
-            printhost += " (%d)" % len(known_host_peers[host])
-        # Finally print complete host line
-        print("%-32s %s" % (printhost[:32], known_host_info[host]))
-        if recurse and (maxlevel == 0 or level < maxlevel):
-            trace.append(host)
-            # Loop through peers
-            for peer in known_host_peers[host]:
-                if peer in trace:
-                    # we've detected a loop!
-                    printhost = (' ' * (level + 1)) + "= " + peer
-                    # Shorten host string
-                    if strip:
-                        printhost = printhost.replace(strip, "")
-                    print("%-32s" % printhost[:32])
-                else:
-                    # FIXME: Ugh! Magic-address assumption.
-                    # Needed to deal with peers running legacy NTP.
-                    # Might cause problems in the future.  First
-                    # part of the guard is an attempt to skip
-                    # NTPsec-style clock IDs.
-                    if peer[0].isdigit() and not peer.startswith("127"):
-                        scan_host(peer, level + 1)
-    else: # We did not get answers from this host
-        printhost = (' ' * level) + (ntp.util.canonicalize_dns(host) or host)
-        if strip:
-            printhost = printhost.replace(strip, "")
-        print("%-32s  ?" % printhost[:32])
-
-if __name__ == '__main__':
-    try:
-        (options, arguments) = getopt.getopt(
-            sys.argv[1:], "h:l:m:ps:?",
-            ["host=", "host-list=", "maxlevel=", "peers", "strip="])
-    except getopt.GetoptError as err:
-        sys.stderr.write(str(err) + "\n")
-        raise SystemExit(1)
-    hostlist = []
-    maxlevel = 1
-    recurse = False
-    strip = ""
-    for (switch, val) in options:
-        if switch == "-h" or switch == "--host":
-            hostlist = [val]
-        elif switch == "-l" or switch == "--host-list":
-            hostlist = val.split(",")
-        elif switch == "-m" or switch == "--maxlevel":
-            maxlevel = int(val)
-        elif switch == "-p" or switch == "--peers":
-            recurse = True
-        elif switch == "-s" or switch == "--strip":
-            strip = val
-        elif switch == "-?" or switch == "--help":
-            print(__doc__, file=sys.stderr)
-            raise SystemExit(0)
-
-    if arguments:
-        hostlist += [ln.strip() for ln in open(arguments[0]).readlines()]
-
-    if not hostlist:
-        hostlist = ["localhost"]
-
-    # Print header
-    print("""\
-Host                             st offset(s) version     system       processor
---------------------------------+--+---------+-----------+------------+---------\
-""")
-
-    known_host_info = {}
-    known_host_peers = {}
-    trace = []
-    for host in hostlist:
-        try:
-            scan_host(host, 0)
-        except ntp.packet.ControlException as e:
-            sys.stderr.write(e.message + "\n")
-            sys.exit(1)
-    sys.exit(0)
-
-# end
diff --git a/ntpsweep/ntpsweep-man.txt b/ntpsweep/ntpsweep-man.txt
deleted file mode 100644
index 9f8dfbc..0000000
--- a/ntpsweep/ntpsweep-man.txt
+++ /dev/null
@@ -1,54 +0,0 @@
-= ntpsweep(1) =
-:doctype: manpage
-
-== NAME ==
-ntpsweep - print various informations about given NTP servers
-
-== SYNOPSIS ==
-+ntpsweep+ [+-l+ 'host']... [-p] [+-m+ 'number'] [+-s+ 'prefix'] [+-h+ 'string']
-
-== DESCRIPTION ==
-
-`ntpsweep` prints per host the NTP stratum level, the clock offset in
-seconds, the daemon version, the operating system and the processor.
-Optionally recursing through all peers.
-
-If no hosts are specified, `ntpsweep` reports on localhost.
-
-`ntpsweep` relies on `ntpq` and Mode 6 queries to probe servers.  This
-depends on the remote host's _restrict_ configuration allowing
-queries. Nowadays effectively all public hosts set _noquery_, so this
-script is unlikely to be useful unless you have multiple specially-
-configured timeservers on a LAN.
-
-== OPTIONS ==
-
-+-l+ string, +--host-list+=_string_::
-  Host to execute actions on. This option may appear an unlimited number
-  of times.
-+
-Use this option to specify the host on which this script operates. May
-appear multiple times.
-
-+-p+, +--peers+::
-  Recursively list all peers a host synchronizes to.
-
-+-m+ number, +--maxlevel+=_number_::
-  Traverse peers up to this level (4 is a reasonable number). This
-  option takes an integer number as its argument.
-
-+-s+ string, +--strip+=_string_::
-  Strip this string from hostnames.
-
-+-h+ string, +--host+=_string_::
-  Specify a single host.  Deprecated option for backwards compatibility.
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-
diff --git a/ntptrace/ntptrace b/ntptrace/ntptrace
deleted file mode 100755
index a365391..0000000
--- a/ntptrace/ntptrace
+++ /dev/null
@@ -1,162 +0,0 @@
-#!/usr/bin/env python
-"""
-ntptrace - trace peers of an NTP server
-
-Usage: ntptrace [-n | --numeric] [-m number | --max-hosts=number]
-                [-r hostname | --host=hostname] [--help | --more-help]
-                hostname
-
-See the manual page for details.
-"""
-#SPDX-License-Identifier: BSD-2-Clause
-
-from __future__ import print_function
-
-import getopt
-import re
-import subprocess
-import sys
-import ntp.util
-
-def get_info(host):
-    info = ntp_read_vars(0, [], host)
-    if info is None or 'stratum' not in info:
-        return
-
-    info['offset'] = round(float(info['offset']) / 1000, 6)
-    info['syncdistance'] = \
-        (float(info['rootdisp']) + (float(info['rootdelay']) / 2)) / 1000
-
-    return info
-
-
-def get_next_host(peer, host):
-    info = ntp_read_vars(peer, ["srcadr"], host)
-    if info is None:
-        return
-    return info['srcadr']
-
-
-def ntp_read_vars(peer, vars, host):
-    obsolete = {'phase': 'offset',
-                'rootdispersion': 'rootdisp'}
-
-    if not len(vars):
-        do_all = True
-    else:
-        do_all = False
-    outvars = {}.fromkeys(vars)
-
-    if do_all:
-        outvars['status_line'] = {}
-
-    cmd = ["ntpq", "-n", "-c", "rv %s %s" % (peer, ",".join(vars))]
-    if host is not None:
-        cmd.append(host)
-
-    try:
-        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode('utf-8').splitlines()
-    except subprocess.CalledProcessError as e:
-        print("Could not start ntpq: %s" % e.output, file=sys.stderr)
-        raise SystemExit(1)
-    except OSError as e:
-        print("Could not start ntpq: %s" % e.strerror, file=sys.stderr)
-        raise SystemExit(1)
-
-    for line in output:
-        if re.search(r'Connection refused', line):
-            return
-
-        match = re.search(r'^asso?c?id=0 status=(\S{4}) (\S+), (\S+),', line, flags=re.IGNORECASE)
-        if match:
-            outvars['status_line']['status'] = match.group(1)
-            outvars['status_line']['leap'] = match.group(2)
-            outvars['status_line']['sync'] = match.group(3)
-
-        iterator = re.finditer(r'(\w+)=([^,]+),?\s?', line)
-        for match in iterator:
-            key = match.group(1)
-            val = match.group(2)
-            val = re.sub(r'^"([^"]+)"$', r'\1', val)
-            if key in obsolete:
-                key = obsolete[key]
-            if do_all or key in outvars:
-                outvars[key] = val
-
-    return outvars
-
-
-usage = r"""ntptrace - Trace peers of an NTP server.
-USAGE: ntptrace [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [host]
-
-    -n, --numeric                Print IP addresses instead of hostnames
-    -m, --max-hosts=num          Maximum number of peers to trace
-    -r, --host=str               Single remote host
-    -?, --help                   Display usage information and exit
-        --more-help              Pass the extended usage text through a pager
-
-Options are specified by doubled hyphens and their name or by a single
-hyphen and the flag character."""
-
-try:
-    (options, arguments) = getopt.getopt(
-        sys.argv[1:], "m:nr:?",
-        ["help", "host=", "max-hosts=", "more-help", "numeric"])
-except getopt.GetoptError as err:
-    sys.stderr.write(str(err) + "\n")
-    raise SystemExit(1)
-
-numeric = False
-maxhosts = 99
-host = '127.0.0.1'
-
-for (switch, val) in options:
-    if switch == "-m" or switch == "--max-hosts":
-        maxhosts = int(val)
-    elif switch == "-n" or switch == "--numeric":
-        numeric = True
-    elif switch == "-r" or switch == "--host":
-        host = val
-    elif switch == "-?" or switch == "--help" or switch == "--more-help":
-        print(usage, file=sys.stderr)
-        raise SystemExit(0)
-
-if len(arguments):
-    host = arguments[0]
-
-hostcount = 0
-
-while True:
-    hostcount += 1
-
-    info = get_info(host)
-
-    if info is None:
-        break
-
-    if not numeric:
-        host = ntp.util.canonicalize_dns(host)
-
-    print("%s: stratum %d, offset %f, synch distance %f" %
-          (host, int(info['stratum']), info['offset'], info['syncdistance']), end='')
-    if int(info['stratum']) == 1:
-        print(", refid '%s'" % info['refid'], end='')
-    print()
-
-    if int(info['stratum']) == 0 or int(info['stratum']) == 1 or int(info['stratum']) == 16:
-        break
-
-    if re.search(r'^127\.127\.\d{1,3}\.\d{1,3}$', info['refid']):
-        break
-
-    if hostcount == maxhosts:
-        break
-
-    next_host = get_next_host(info['peer'], host)
-
-    if next_host is None:
-        break
-    if re.search(r'^127\.127\.\d{1,3}\.\d{1,3}$', next_host):
-        break
-
-    host = next_host
diff --git a/ntptrace/ntptrace-man.txt b/ntptrace/ntptrace-man.txt
deleted file mode 100644
index d254b2c..0000000
--- a/ntptrace/ntptrace-man.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-= ntptrace(1) =
-:doctype: manpage
-
-== NAME ==
-ntptrace - trace peers of an NTP server
-
-include::../docs/includes/ntptrace-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the invocation was not valid.
diff --git a/ntpwait/ntpwait b/ntpwait/ntpwait
deleted file mode 100755
index 22da0b8..0000000
--- a/ntpwait/ntpwait
+++ /dev/null
@@ -1,200 +0,0 @@
-#!/usr/bin/env python
-"""\
-ntpwait - Wait for ntpd to stabilize the system clock.
-USAGE: ntpwait [-n tries] [-s sleeptime] [-v] [-h]
-
-    -n, --tries=num              Number of times to check ntpd
-    -s, --sleep=num              How long to sleep between tries
-    -v, --verbose                Be verbose
-    -h, --help                   Issue help
-
-Options are specified by doubled hyphens and their name or by a single
-hyphen and the flag character.
-
-A spurious 'not running' message can result from queries being disabled.
-"""
-#SPDX-License-Identifier: BSD-2-Clause
-from __future__ import print_function, division
-
-import sys, getopt, re, time
-import socket
-import ntp.magic
-import ntp.packet
-
-# General notes on Python 2/3 compatibility:
-#
-# This code uses the following strategy to allow it to run on both Python 2
-# and Python 3:
-#
-# - Use binary I/O to read/write data from/to files and subprocesses;
-#   where the exact bytes are important (such as in checking for
-#   modified files), use the binary data directly
-#
-# - Use latin-1 encoding to transform binary data to/from Unicode when
-#   necessary for operations where Python 3 expects Unicode; the
-#   polystr and polybytes functions are used to do this so that
-#   when running on Python 2, the byte string data is used unchanged;
-#   also, the make_wrapper function constructs a text stream that can
-#   wrap a file opened in binary mode for cases where a file object
-#   that can be passed around from function to function is needed
-#
-# - Construct custom stdin, stdout, and stderr streams when running
-#   on Python 3 that force latin-1 encoding, and wrap them around the
-#   underlying binary buffers (in Python 2, the streams are binary
-#   and are used unchanged); this ensures that the same transformation
-#   is done on data from/to the standard streams, as is done on binary
-#   data from/to files and subprocesses; the make_std_wrapper function
-#   does this
-
-master_encoding = 'latin-1'
-
-if str is bytes:  # Python 2
-    polystr = str
-    polybytes = bytes
-
-    def string_escape(s):
-        return s.decode('string_escape')
-
-    def make_wrapper(fp):
-        return fp
-
-else:  # Python 3
-    import io
-
-    def polystr(o):
-        "Polymorphic string factory function"
-        if isinstance(o, str):
-            return o
-        if not isinstance(o, bytes):
-            return str(o)
-        return str(o, encoding=master_encoding)
-
-    def polybytes(s):
-        "Polymorphic string encoding function"
-        if isinstance(s, bytes):
-            return s
-        if not isinstance(s, str):
-            return bytes(s)
-        return bytes(s, encoding=master_encoding)
-
-    def string_escape(s):
-        "Polymorphic string_escape/unicode_escape"
-        # This hack is necessary because Unicode strings in Python 3 don't
-        # have a decode method, so there's no simple way to ask it for the
-        # equivalent of decode('string_escape') in Python 2. This function
-        # assumes that it will be called with a Python 3 'str' instance
-        return s.encode(master_encoding).decode('unicode_escape')
-
-    def make_wrapper(fp):
-        "Wrapper factory function to enforce master encoding"
-        # This can be used to wrap normally binary streams for API
-        # compatibility with functions that need a text stream in
-        # Python 3; it ensures that the binary bytes are decoded using
-        # the master encoding we use to turn bytes to Unicode in
-        # polystr above
-        # newline="\n" ensures that Python 3 won't mangle line breaks
-        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")
-
-    def make_std_wrapper(stream):
-        "Standard input/output wrapper factory function"
-        # This ensures that the encoding of standard output and standard
-        # error on Python 3 matches the master encoding we use to turn
-        # bytes to Unicode in polystr above
-        # line_buffering=True ensures that interactive command sessions work as expected
-        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)
-
-    sys.stdin = make_std_wrapper(sys.stdin)
-    sys.stdout = make_std_wrapper(sys.stdout)
-    sys.stderr = make_std_wrapper(sys.stderr)
-
-class Unbuffered(object):
-    def __init__(self, stream):
-        self.stream = stream
-
-    def write(self, data):
-        self.stream.write(data)
-        self.stream.flush()
-
-    def __getattr__(self, attr):
-        return getattr(self.stream, attr)
-
-if __name__ == "__main__":
-    try:
-        (options, arguments) = getopt.getopt(sys.argv[1:], "hn:s:v", [
-            "tries=", "sleep=", "verbose", "help"
-        ])
-    except getopt.GetoptError as err:
-        sys.stderr.write(str(err) + "\n")
-        raise SystemExit(2)
-    tries = 100
-    sleep = 6
-    verbose = 0
-    for (switch, val) in options:
-        if switch in ("-n", "--tries"):
-            tries = int(val)
-        elif switch in ("-s", "--sleep"):
-            sleep = int(val)
-        elif switch in ("-v", "--verbose"):
-            verbose += 1
-        elif switch in ("-h", "--help"):
-            sys.stdout.write(__doc__)
-            raise SystemExit(0)
-
-    # Autoflush stdout
-    sys.stdout = Unbuffered(sys.stdout)
-
-    if verbose:
-        sys.stdout.write("Waiting for ntpd to synchronize...  ")
-
-    for i in range(1, tries):
-        session = ntp.packet.ControlSession()
-        #session.debug = 4
-        if not session.openhost("localhost"):
-            if verbose:
-                sys.stdout.write("\bntpd is not running!\n")
-            continue
-
-        try:
-            msg = session.doquery(2)	# Request system variables
-        except socket.error:
-            if verbose:
-                sys.stdout.write("\b" + "*+:."[i % 4])
-            time.sleep(sleep)
-            continue
-
-        if verbose >= 2:
-            sys.stderr.write(repr(session.response) + "\n")
-
-        if msg and msg.startswith("***"):
-            if verbose:
-                sys.stdout.write("\b" + msg + "\n")
-            sys.exit(1)
-
-        m = re.search(r"leap=([^,]*),", session.response)
-        if m:
-            leap = int(m.group(1))
-        else:
-            sys.stdout.write("\bLeap status not available\n")
-            sys.exit(1)
-
-        if leap == ntp.magic.LEAP_NOTINSYNC:
-            if verbose:
-                sys.stdout.write("\b" + "*+:."[i % 4])
-            if i < tries:
-                time.sleep(sleep)
-            continue
-
-        if leap in (ntp.magic.LEAP_NOWARNING, ntp.magic.LEAP_ADDSECOND, ntp.magic.LEAP_DELSECOND):
-            # We could check "sync" here to make sure we like the source...
-            if verbose:
-                sys.stdout.write("\bOK!\n")
-            sys.exit(0)
-
-        sys.stdout.write("\bUnexpected 'leap' status <%s>\n" % leap)
-        sys.exit(1)
-
-    if verbose:
-        sys.stdout.write("\bNo!\nntpd did not synchronize.\n")
-    sys.exit(1)
-
-# end
diff --git a/ntpwait/ntpwait-man.txt b/ntpwait/ntpwait-man.txt
deleted file mode 100644
index 7ffb6bb..0000000
--- a/ntpwait/ntpwait-man.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-= ntpwait(8) =
-:doctype: manpage
-
-== NAME ==
-ntpwait - Wait for ntpd to stabilize the system clock
-
-include::../docs/includes/ntpwait-body.txt[]
-
-== EXIT STATUS ==
-
-One of the following exit values will be returned:
-
-0 (EXIT_SUCCESS)::
-  Successful program execution.
-1 (EXIT_FAILURE)::
-  The operation failed or the command syntax was not valid.
-
-// end
-
diff --git a/wscript b/wscript
index 64bf896..03cb3b1 100644
--- a/wscript
+++ b/wscript
@@ -116,7 +116,7 @@ def afterparty(ctx):
     # module built in libntp.
     if ctx.cmd == 'clean':
         ctx.exec_command("rm -f wafhelpers/*.pyc pylib/__pycache__/*.pyc wafhelpers/__pycache__/*.pyc")
-    for x in ("ntpq", "ntpdig", "ntpstats", "ntpsweep", "ntptrace", "ntpwait"):
+    for x in ("ntpclients",):	# List used to be longer...
             path_build = ctx.bldnode.make_node("pylib")
             path_source = ctx.srcnode.make_node(x + "/ntp")
             relpath = "../" + path_build.path_from(ctx.srcnode)
@@ -136,13 +136,13 @@ def afterparty(ctx):
         os.system("ln -sf %s/libntp/ntpc.so %s/pylib/ntpc.so " % (bldnode, bldnode))
 
 python_scripts = [
-        "ntpq/ntpq",
-        "ntpstats/ntpviz",
-        "ntptrace/ntptrace",
-        "ntpwait/ntpwait",
-        "ntpsweep/ntpsweep",
-        "ntpkeygen/ntpkeygen",
-        "ntpdig/ntpdig",
+        "ntpclients/ntpdig",
+        "ntpclients/ntpkeygen",
+        "ntpclients/ntpq",
+        "ntpclients/ntpsweep",
+        "ntpclients/ntptrace",
+        "ntpclients/ntpviz",
+        "ntpclients/ntpwait",
 ]
 
 def build(ctx):
@@ -182,7 +182,7 @@ def build(ctx):
         ctx.recurse("attic")
         ctx.recurse("tests")
 
-        scripts = ["ntpleapfetch/ntpleapfetch"] + python_scripts
+        scripts = ["ntpclients/ntpleapfetch"] + python_scripts
 
         ctx(
                 features      = "subst",
@@ -196,13 +196,14 @@ def build(ctx):
         if ctx.cmd == 'clean':
             afterparty(ctx)
 
-        ctx.manpage(8, "ntpleapfetch/ntpleapfetch-man.txt")
-        ctx.manpage(1, "ntpq/ntpq-man.txt")
-        ctx.manpage(1, "ntptrace/ntptrace-man.txt")
-        ctx.manpage(1, "ntpstats/ntpviz-man.txt")
-        ctx.manpage(8, "ntpwait/ntpwait-man.txt")
-        ctx.manpage(1, "ntpsweep/ntpsweep-man.txt")
-        ctx.manpage(8, "ntpkeygen/ntpkeygen-man.txt")
+        ctx.manpage(8, "ntpclients/ntpleapfetch-man.txt")
+        ctx.manpage(1, "ntpclients/ntpdig-man.txt")
+        ctx.manpage(8, "ntpclients/ntpkeygen-man.txt")
+        ctx.manpage(1, "ntpclients/ntpq-man.txt")
+        ctx.manpage(1, "ntpclients/ntpsweep-man.txt")
+        ctx.manpage(1, "ntpclients/ntptrace-man.txt")
+        ctx.manpage(1, "ntpclients/ntpviz-man.txt")
+        ctx.manpage(8, "ntpclients/ntpwait-man.txt")
 
         # Skip running unit tests on a cross compile build
         if not ctx.env.ENABLE_CROSS:
-- 
2.7.4

